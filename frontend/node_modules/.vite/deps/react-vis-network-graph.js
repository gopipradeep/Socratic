import {
  require_react
} from "./chunk-5LFKFUIN.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/lodash/fp/_mapping.js
var require_mapping = __commonJS({
  "node_modules/lodash/fp/_mapping.js"(exports) {
    exports.aliasToReal = {
      // Lodash aliases.
      "each": "forEach",
      "eachRight": "forEachRight",
      "entries": "toPairs",
      "entriesIn": "toPairsIn",
      "extend": "assignIn",
      "extendAll": "assignInAll",
      "extendAllWith": "assignInAllWith",
      "extendWith": "assignInWith",
      "first": "head",
      // Methods that are curried variants of others.
      "conforms": "conformsTo",
      "matches": "isMatch",
      "property": "get",
      // Ramda aliases.
      "__": "placeholder",
      "F": "stubFalse",
      "T": "stubTrue",
      "all": "every",
      "allPass": "overEvery",
      "always": "constant",
      "any": "some",
      "anyPass": "overSome",
      "apply": "spread",
      "assoc": "set",
      "assocPath": "set",
      "complement": "negate",
      "compose": "flowRight",
      "contains": "includes",
      "dissoc": "unset",
      "dissocPath": "unset",
      "dropLast": "dropRight",
      "dropLastWhile": "dropRightWhile",
      "equals": "isEqual",
      "identical": "eq",
      "indexBy": "keyBy",
      "init": "initial",
      "invertObj": "invert",
      "juxt": "over",
      "omitAll": "omit",
      "nAry": "ary",
      "path": "get",
      "pathEq": "matchesProperty",
      "pathOr": "getOr",
      "paths": "at",
      "pickAll": "pick",
      "pipe": "flow",
      "pluck": "map",
      "prop": "get",
      "propEq": "matchesProperty",
      "propOr": "getOr",
      "props": "at",
      "symmetricDifference": "xor",
      "symmetricDifferenceBy": "xorBy",
      "symmetricDifferenceWith": "xorWith",
      "takeLast": "takeRight",
      "takeLastWhile": "takeRightWhile",
      "unapply": "rest",
      "unnest": "flatten",
      "useWith": "overArgs",
      "where": "conformsTo",
      "whereEq": "isMatch",
      "zipObj": "zipObject"
    };
    exports.aryMethod = {
      "1": [
        "assignAll",
        "assignInAll",
        "attempt",
        "castArray",
        "ceil",
        "create",
        "curry",
        "curryRight",
        "defaultsAll",
        "defaultsDeepAll",
        "floor",
        "flow",
        "flowRight",
        "fromPairs",
        "invert",
        "iteratee",
        "memoize",
        "method",
        "mergeAll",
        "methodOf",
        "mixin",
        "nthArg",
        "over",
        "overEvery",
        "overSome",
        "rest",
        "reverse",
        "round",
        "runInContext",
        "spread",
        "template",
        "trim",
        "trimEnd",
        "trimStart",
        "uniqueId",
        "words",
        "zipAll"
      ],
      "2": [
        "add",
        "after",
        "ary",
        "assign",
        "assignAllWith",
        "assignIn",
        "assignInAllWith",
        "at",
        "before",
        "bind",
        "bindAll",
        "bindKey",
        "chunk",
        "cloneDeepWith",
        "cloneWith",
        "concat",
        "conformsTo",
        "countBy",
        "curryN",
        "curryRightN",
        "debounce",
        "defaults",
        "defaultsDeep",
        "defaultTo",
        "delay",
        "difference",
        "divide",
        "drop",
        "dropRight",
        "dropRightWhile",
        "dropWhile",
        "endsWith",
        "eq",
        "every",
        "filter",
        "find",
        "findIndex",
        "findKey",
        "findLast",
        "findLastIndex",
        "findLastKey",
        "flatMap",
        "flatMapDeep",
        "flattenDepth",
        "forEach",
        "forEachRight",
        "forIn",
        "forInRight",
        "forOwn",
        "forOwnRight",
        "get",
        "groupBy",
        "gt",
        "gte",
        "has",
        "hasIn",
        "includes",
        "indexOf",
        "intersection",
        "invertBy",
        "invoke",
        "invokeMap",
        "isEqual",
        "isMatch",
        "join",
        "keyBy",
        "lastIndexOf",
        "lt",
        "lte",
        "map",
        "mapKeys",
        "mapValues",
        "matchesProperty",
        "maxBy",
        "meanBy",
        "merge",
        "mergeAllWith",
        "minBy",
        "multiply",
        "nth",
        "omit",
        "omitBy",
        "overArgs",
        "pad",
        "padEnd",
        "padStart",
        "parseInt",
        "partial",
        "partialRight",
        "partition",
        "pick",
        "pickBy",
        "propertyOf",
        "pull",
        "pullAll",
        "pullAt",
        "random",
        "range",
        "rangeRight",
        "rearg",
        "reject",
        "remove",
        "repeat",
        "restFrom",
        "result",
        "sampleSize",
        "some",
        "sortBy",
        "sortedIndex",
        "sortedIndexOf",
        "sortedLastIndex",
        "sortedLastIndexOf",
        "sortedUniqBy",
        "split",
        "spreadFrom",
        "startsWith",
        "subtract",
        "sumBy",
        "take",
        "takeRight",
        "takeRightWhile",
        "takeWhile",
        "tap",
        "throttle",
        "thru",
        "times",
        "trimChars",
        "trimCharsEnd",
        "trimCharsStart",
        "truncate",
        "union",
        "uniqBy",
        "uniqWith",
        "unset",
        "unzipWith",
        "without",
        "wrap",
        "xor",
        "zip",
        "zipObject",
        "zipObjectDeep"
      ],
      "3": [
        "assignInWith",
        "assignWith",
        "clamp",
        "differenceBy",
        "differenceWith",
        "findFrom",
        "findIndexFrom",
        "findLastFrom",
        "findLastIndexFrom",
        "getOr",
        "includesFrom",
        "indexOfFrom",
        "inRange",
        "intersectionBy",
        "intersectionWith",
        "invokeArgs",
        "invokeArgsMap",
        "isEqualWith",
        "isMatchWith",
        "flatMapDepth",
        "lastIndexOfFrom",
        "mergeWith",
        "orderBy",
        "padChars",
        "padCharsEnd",
        "padCharsStart",
        "pullAllBy",
        "pullAllWith",
        "rangeStep",
        "rangeStepRight",
        "reduce",
        "reduceRight",
        "replace",
        "set",
        "slice",
        "sortedIndexBy",
        "sortedLastIndexBy",
        "transform",
        "unionBy",
        "unionWith",
        "update",
        "xorBy",
        "xorWith",
        "zipWith"
      ],
      "4": [
        "fill",
        "setWith",
        "updateWith"
      ]
    };
    exports.aryRearg = {
      "2": [1, 0],
      "3": [2, 0, 1],
      "4": [3, 2, 0, 1]
    };
    exports.iterateeAry = {
      "dropRightWhile": 1,
      "dropWhile": 1,
      "every": 1,
      "filter": 1,
      "find": 1,
      "findFrom": 1,
      "findIndex": 1,
      "findIndexFrom": 1,
      "findKey": 1,
      "findLast": 1,
      "findLastFrom": 1,
      "findLastIndex": 1,
      "findLastIndexFrom": 1,
      "findLastKey": 1,
      "flatMap": 1,
      "flatMapDeep": 1,
      "flatMapDepth": 1,
      "forEach": 1,
      "forEachRight": 1,
      "forIn": 1,
      "forInRight": 1,
      "forOwn": 1,
      "forOwnRight": 1,
      "map": 1,
      "mapKeys": 1,
      "mapValues": 1,
      "partition": 1,
      "reduce": 2,
      "reduceRight": 2,
      "reject": 1,
      "remove": 1,
      "some": 1,
      "takeRightWhile": 1,
      "takeWhile": 1,
      "times": 1,
      "transform": 2
    };
    exports.iterateeRearg = {
      "mapKeys": [1],
      "reduceRight": [1, 0]
    };
    exports.methodRearg = {
      "assignInAllWith": [1, 0],
      "assignInWith": [1, 2, 0],
      "assignAllWith": [1, 0],
      "assignWith": [1, 2, 0],
      "differenceBy": [1, 2, 0],
      "differenceWith": [1, 2, 0],
      "getOr": [2, 1, 0],
      "intersectionBy": [1, 2, 0],
      "intersectionWith": [1, 2, 0],
      "isEqualWith": [1, 2, 0],
      "isMatchWith": [2, 1, 0],
      "mergeAllWith": [1, 0],
      "mergeWith": [1, 2, 0],
      "padChars": [2, 1, 0],
      "padCharsEnd": [2, 1, 0],
      "padCharsStart": [2, 1, 0],
      "pullAllBy": [2, 1, 0],
      "pullAllWith": [2, 1, 0],
      "rangeStep": [1, 2, 0],
      "rangeStepRight": [1, 2, 0],
      "setWith": [3, 1, 2, 0],
      "sortedIndexBy": [2, 1, 0],
      "sortedLastIndexBy": [2, 1, 0],
      "unionBy": [1, 2, 0],
      "unionWith": [1, 2, 0],
      "updateWith": [3, 1, 2, 0],
      "xorBy": [1, 2, 0],
      "xorWith": [1, 2, 0],
      "zipWith": [1, 2, 0]
    };
    exports.methodSpread = {
      "assignAll": { "start": 0 },
      "assignAllWith": { "start": 0 },
      "assignInAll": { "start": 0 },
      "assignInAllWith": { "start": 0 },
      "defaultsAll": { "start": 0 },
      "defaultsDeepAll": { "start": 0 },
      "invokeArgs": { "start": 2 },
      "invokeArgsMap": { "start": 2 },
      "mergeAll": { "start": 0 },
      "mergeAllWith": { "start": 0 },
      "partial": { "start": 1 },
      "partialRight": { "start": 1 },
      "without": { "start": 1 },
      "zipAll": { "start": 0 }
    };
    exports.mutate = {
      "array": {
        "fill": true,
        "pull": true,
        "pullAll": true,
        "pullAllBy": true,
        "pullAllWith": true,
        "pullAt": true,
        "remove": true,
        "reverse": true
      },
      "object": {
        "assign": true,
        "assignAll": true,
        "assignAllWith": true,
        "assignIn": true,
        "assignInAll": true,
        "assignInAllWith": true,
        "assignInWith": true,
        "assignWith": true,
        "defaults": true,
        "defaultsAll": true,
        "defaultsDeep": true,
        "defaultsDeepAll": true,
        "merge": true,
        "mergeAll": true,
        "mergeAllWith": true,
        "mergeWith": true
      },
      "set": {
        "set": true,
        "setWith": true,
        "unset": true,
        "update": true,
        "updateWith": true
      }
    };
    exports.realToAlias = function() {
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, object2 = exports.aliasToReal, result = {};
      for (var key in object2) {
        var value = object2[key];
        if (hasOwnProperty2.call(result, value)) {
          result[value].push(key);
        } else {
          result[value] = [key];
        }
      }
      return result;
    }();
    exports.remap = {
      "assignAll": "assign",
      "assignAllWith": "assignWith",
      "assignInAll": "assignIn",
      "assignInAllWith": "assignInWith",
      "curryN": "curry",
      "curryRightN": "curryRight",
      "defaultsAll": "defaults",
      "defaultsDeepAll": "defaultsDeep",
      "findFrom": "find",
      "findIndexFrom": "findIndex",
      "findLastFrom": "findLast",
      "findLastIndexFrom": "findLastIndex",
      "getOr": "get",
      "includesFrom": "includes",
      "indexOfFrom": "indexOf",
      "invokeArgs": "invoke",
      "invokeArgsMap": "invokeMap",
      "lastIndexOfFrom": "lastIndexOf",
      "mergeAll": "merge",
      "mergeAllWith": "mergeWith",
      "padChars": "pad",
      "padCharsEnd": "padEnd",
      "padCharsStart": "padStart",
      "propertyOf": "get",
      "rangeStep": "range",
      "rangeStepRight": "rangeRight",
      "restFrom": "rest",
      "spreadFrom": "spread",
      "trimChars": "trim",
      "trimCharsEnd": "trimEnd",
      "trimCharsStart": "trimStart",
      "zipAll": "zip"
    };
    exports.skipFixed = {
      "castArray": true,
      "flow": true,
      "flowRight": true,
      "iteratee": true,
      "mixin": true,
      "rearg": true,
      "runInContext": true
    };
    exports.skipRearg = {
      "add": true,
      "assign": true,
      "assignIn": true,
      "bind": true,
      "bindKey": true,
      "concat": true,
      "difference": true,
      "divide": true,
      "eq": true,
      "gt": true,
      "gte": true,
      "isEqual": true,
      "lt": true,
      "lte": true,
      "matchesProperty": true,
      "merge": true,
      "multiply": true,
      "overArgs": true,
      "partial": true,
      "partialRight": true,
      "propertyOf": true,
      "random": true,
      "range": true,
      "rangeRight": true,
      "subtract": true,
      "zip": true,
      "zipObject": true,
      "zipObjectDeep": true
    };
  }
});

// node_modules/lodash/fp/placeholder.js
var require_placeholder = __commonJS({
  "node_modules/lodash/fp/placeholder.js"(exports, module) {
    module.exports = {};
  }
});

// node_modules/lodash/fp/_baseConvert.js
var require_baseConvert = __commonJS({
  "node_modules/lodash/fp/_baseConvert.js"(exports, module) {
    var mapping = require_mapping();
    var fallbackHolder = require_placeholder();
    var push2 = Array.prototype.push;
    function baseArity(func, n) {
      return n == 2 ? function(a, b) {
        return func.apply(void 0, arguments);
      } : function(a) {
        return func.apply(void 0, arguments);
      };
    }
    function baseAry(func, n) {
      return n == 2 ? function(a, b) {
        return func(a, b);
      } : function(a) {
        return func(a);
      };
    }
    function cloneArray(array2) {
      var length2 = array2 ? array2.length : 0, result = Array(length2);
      while (length2--) {
        result[length2] = array2[length2];
      }
      return result;
    }
    function createCloner(func) {
      return function(object2) {
        return func({}, object2);
      };
    }
    function flatSpread(func, start) {
      return function() {
        var length2 = arguments.length, lastIndex = length2 - 1, args = Array(length2);
        while (length2--) {
          args[length2] = arguments[length2];
        }
        var array2 = args[start], otherArgs = args.slice(0, start);
        if (array2) {
          push2.apply(otherArgs, array2);
        }
        if (start != lastIndex) {
          push2.apply(otherArgs, args.slice(start + 1));
        }
        return func.apply(this, otherArgs);
      };
    }
    function wrapImmutable(func, cloner) {
      return function() {
        var length2 = arguments.length;
        if (!length2) {
          return;
        }
        var args = Array(length2);
        while (length2--) {
          args[length2] = arguments[length2];
        }
        var result = args[0] = cloner.apply(void 0, args);
        func.apply(void 0, args);
        return result;
      };
    }
    function baseConvert(util, name, func, options2) {
      var isLib = typeof name == "function", isObj = name === Object(name);
      if (isObj) {
        options2 = func;
        func = name;
        name = void 0;
      }
      if (func == null) {
        throw new TypeError();
      }
      options2 || (options2 = {});
      var config = {
        "cap": "cap" in options2 ? options2.cap : true,
        "curry": "curry" in options2 ? options2.curry : true,
        "fixed": "fixed" in options2 ? options2.fixed : true,
        "immutable": "immutable" in options2 ? options2.immutable : true,
        "rearg": "rearg" in options2 ? options2.rearg : true
      };
      var defaultHolder = isLib ? func : fallbackHolder, forceCurry = "curry" in options2 && options2.curry, forceFixed = "fixed" in options2 && options2.fixed, forceRearg = "rearg" in options2 && options2.rearg, pristine = isLib ? func.runInContext() : void 0;
      var helpers = isLib ? func : {
        "ary": util.ary,
        "assign": util.assign,
        "clone": util.clone,
        "curry": util.curry,
        "forEach": util.forEach,
        "isArray": util.isArray,
        "isError": util.isError,
        "isFunction": util.isFunction,
        "isWeakMap": util.isWeakMap,
        "iteratee": util.iteratee,
        "keys": util.keys,
        "rearg": util.rearg,
        "toInteger": util.toInteger,
        "toPath": util.toPath
      };
      var ary = helpers.ary, assign3 = helpers.assign, clone2 = helpers.clone, curry = helpers.curry, each2 = helpers.forEach, isArray3 = helpers.isArray, isError = helpers.isError, isFunction = helpers.isFunction, isWeakMap = helpers.isWeakMap, keys4 = helpers.keys, rearg = helpers.rearg, toInteger2 = helpers.toInteger, toPath = helpers.toPath;
      var aryMethodKeys = keys4(mapping.aryMethod);
      var wrappers = {
        "castArray": function(castArray) {
          return function() {
            var value = arguments[0];
            return isArray3(value) ? castArray(cloneArray(value)) : castArray.apply(void 0, arguments);
          };
        },
        "iteratee": function(iteratee) {
          return function() {
            var func2 = arguments[0], arity = arguments[1], result = iteratee(func2, arity), length2 = result.length;
            if (config.cap && typeof arity == "number") {
              arity = arity > 2 ? arity - 2 : 1;
              return length2 && length2 <= arity ? result : baseAry(result, arity);
            }
            return result;
          };
        },
        "mixin": function(mixin) {
          return function(source) {
            var func2 = this;
            if (!isFunction(func2)) {
              return mixin(func2, Object(source));
            }
            var pairs2 = [];
            each2(keys4(source), function(key) {
              if (isFunction(source[key])) {
                pairs2.push([key, func2.prototype[key]]);
              }
            });
            mixin(func2, Object(source));
            each2(pairs2, function(pair) {
              var value = pair[1];
              if (isFunction(value)) {
                func2.prototype[pair[0]] = value;
              } else {
                delete func2.prototype[pair[0]];
              }
            });
            return func2;
          };
        },
        "nthArg": function(nthArg) {
          return function(n) {
            var arity = n < 0 ? 1 : toInteger2(n) + 1;
            return curry(nthArg(n), arity);
          };
        },
        "rearg": function(rearg2) {
          return function(func2, indexes) {
            var arity = indexes ? indexes.length : 0;
            return curry(rearg2(func2, indexes), arity);
          };
        },
        "runInContext": function(runInContext) {
          return function(context) {
            return baseConvert(util, runInContext(context), options2);
          };
        }
      };
      function castCap(name2, func2) {
        if (config.cap) {
          var indexes = mapping.iterateeRearg[name2];
          if (indexes) {
            return iterateeRearg(func2, indexes);
          }
          var n = !isLib && mapping.iterateeAry[name2];
          if (n) {
            return iterateeAry(func2, n);
          }
        }
        return func2;
      }
      function castCurry(name2, func2, n) {
        return forceCurry || config.curry && n > 1 ? curry(func2, n) : func2;
      }
      function castFixed(name2, func2, n) {
        if (config.fixed && (forceFixed || !mapping.skipFixed[name2])) {
          var data2 = mapping.methodSpread[name2], start = data2 && data2.start;
          return start === void 0 ? ary(func2, n) : flatSpread(func2, start);
        }
        return func2;
      }
      function castRearg(name2, func2, n) {
        return config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name2]) ? rearg(func2, mapping.methodRearg[name2] || mapping.aryRearg[n]) : func2;
      }
      function cloneByPath(object2, path2) {
        path2 = toPath(path2);
        var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, result = clone2(Object(object2)), nested = result;
        while (nested != null && ++index2 < length2) {
          var key = path2[index2], value = nested[key];
          if (value != null && !(isFunction(value) || isError(value) || isWeakMap(value))) {
            nested[key] = clone2(index2 == lastIndex ? value : Object(value));
          }
          nested = nested[key];
        }
        return result;
      }
      function convertLib(options3) {
        return _.runInContext.convert(options3)(void 0);
      }
      function createConverter(name2, func2) {
        var realName = mapping.aliasToReal[name2] || name2, methodName = mapping.remap[realName] || realName, oldOptions = options2;
        return function(options3) {
          var newUtil = isLib ? pristine : helpers, newFunc = isLib ? pristine[methodName] : func2, newOptions = assign3(assign3({}, oldOptions), options3);
          return baseConvert(newUtil, realName, newFunc, newOptions);
        };
      }
      function iterateeAry(func2, n) {
        return overArg(func2, function(func3) {
          return typeof func3 == "function" ? baseAry(func3, n) : func3;
        });
      }
      function iterateeRearg(func2, indexes) {
        return overArg(func2, function(func3) {
          var n = indexes.length;
          return baseArity(rearg(baseAry(func3, n), indexes), n);
        });
      }
      function overArg(func2, transform) {
        return function() {
          var length2 = arguments.length;
          if (!length2) {
            return func2();
          }
          var args = Array(length2);
          while (length2--) {
            args[length2] = arguments[length2];
          }
          var index2 = config.rearg ? 0 : length2 - 1;
          args[index2] = transform(args[index2]);
          return func2.apply(void 0, args);
        };
      }
      function wrap2(name2, func2, placeholder) {
        var result, realName = mapping.aliasToReal[name2] || name2, wrapped = func2, wrapper = wrappers[realName];
        if (wrapper) {
          wrapped = wrapper(func2);
        } else if (config.immutable) {
          if (mapping.mutate.array[realName]) {
            wrapped = wrapImmutable(func2, cloneArray);
          } else if (mapping.mutate.object[realName]) {
            wrapped = wrapImmutable(func2, createCloner(func2));
          } else if (mapping.mutate.set[realName]) {
            wrapped = wrapImmutable(func2, cloneByPath);
          }
        }
        each2(aryMethodKeys, function(aryKey) {
          each2(mapping.aryMethod[aryKey], function(otherName) {
            if (realName == otherName) {
              var data2 = mapping.methodSpread[realName], afterRearg = data2 && data2.afterRearg;
              result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);
              result = castCap(realName, result);
              result = castCurry(realName, result, aryKey);
              return false;
            }
          });
          return !result;
        });
        result || (result = wrapped);
        if (result == func2) {
          result = forceCurry ? curry(result, 1) : function() {
            return func2.apply(this, arguments);
          };
        }
        result.convert = createConverter(realName, func2);
        result.placeholder = func2.placeholder = placeholder;
        return result;
      }
      if (!isObj) {
        return wrap2(name, func, defaultHolder);
      }
      var _ = func;
      var pairs = [];
      each2(aryMethodKeys, function(aryKey) {
        each2(mapping.aryMethod[aryKey], function(key) {
          var func2 = _[mapping.remap[key] || key];
          if (func2) {
            pairs.push([key, wrap2(key, func2, _)]);
          }
        });
      });
      each2(keys4(_), function(key) {
        var func2 = _[key];
        if (typeof func2 == "function") {
          var length2 = pairs.length;
          while (length2--) {
            if (pairs[length2][0] == key) {
              return;
            }
          }
          func2.convert = createConverter(key, func2);
          pairs.push([key, func2]);
        }
      });
      each2(pairs, function(pair) {
        _[pair[0]] = pair[1];
      });
      _.convert = convertLib;
      _.placeholder = _;
      each2(keys4(_), function(key) {
        each2(mapping.realToAlias[key] || [], function(alias) {
          _[alias] = _[key];
        });
      });
      return _;
    }
    module.exports = baseConvert;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString2;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString2 = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject2 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_metaMap.js
var require_metaMap = __commonJS({
  "node_modules/lodash/_metaMap.js"(exports, module) {
    var WeakMap2 = require_WeakMap();
    var metaMap = WeakMap2 && new WeakMap2();
    module.exports = metaMap;
  }
});

// node_modules/lodash/_baseSetData.js
var require_baseSetData = __commonJS({
  "node_modules/lodash/_baseSetData.js"(exports, module) {
    var identity = require_identity();
    var metaMap = require_metaMap();
    var baseSetData = !metaMap ? identity : function(func, data2) {
      metaMap.set(func, data2);
      return func;
    };
    module.exports = baseSetData;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject2 = require_isObject();
    var objectCreate2 = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate2) {
          return objectCreate2(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_createCtor.js
var require_createCtor = __commonJS({
  "node_modules/lodash/_createCtor.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var isObject2 = require_isObject();
    function createCtor(Ctor) {
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return new Ctor();
          case 1:
            return new Ctor(args[0]);
          case 2:
            return new Ctor(args[0], args[1]);
          case 3:
            return new Ctor(args[0], args[1], args[2]);
          case 4:
            return new Ctor(args[0], args[1], args[2], args[3]);
          case 5:
            return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
        return isObject2(result) ? result : thisBinding;
      };
    }
    module.exports = createCtor;
  }
});

// node_modules/lodash/_createBind.js
var require_createBind = __commonJS({
  "node_modules/lodash/_createBind.js"(exports, module) {
    var createCtor = require_createCtor();
    var root = require_root();
    var WRAP_BIND_FLAG = 1;
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }
    module.exports = createBind;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// node_modules/lodash/_composeArgs.js
var require_composeArgs = __commonJS({
  "node_modules/lodash/_composeArgs.js"(exports, module) {
    var nativeMax = Math.max;
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }
    module.exports = composeArgs;
  }
});

// node_modules/lodash/_composeArgsRight.js
var require_composeArgsRight = __commonJS({
  "node_modules/lodash/_composeArgsRight.js"(exports, module) {
    var nativeMax = Math.max;
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }
    module.exports = composeArgsRight;
  }
});

// node_modules/lodash/_countHolders.js
var require_countHolders = __commonJS({
  "node_modules/lodash/_countHolders.js"(exports, module) {
    function countHolders(array2, placeholder) {
      var length2 = array2.length, result = 0;
      while (length2--) {
        if (array2[length2] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    module.exports = countHolders;
  }
});

// node_modules/lodash/_baseLodash.js
var require_baseLodash = __commonJS({
  "node_modules/lodash/_baseLodash.js"(exports, module) {
    function baseLodash() {
    }
    module.exports = baseLodash;
  }
});

// node_modules/lodash/_LazyWrapper.js
var require_LazyWrapper = __commonJS({
  "node_modules/lodash/_LazyWrapper.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var baseLodash = require_baseLodash();
    var MAX_ARRAY_LENGTH = 4294967295;
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;
    module.exports = LazyWrapper;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/lodash/_getData.js
var require_getData = __commonJS({
  "node_modules/lodash/_getData.js"(exports, module) {
    var metaMap = require_metaMap();
    var noop = require_noop();
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };
    module.exports = getData;
  }
});

// node_modules/lodash/_realNames.js
var require_realNames = __commonJS({
  "node_modules/lodash/_realNames.js"(exports, module) {
    var realNames = {};
    module.exports = realNames;
  }
});

// node_modules/lodash/_getFuncName.js
var require_getFuncName = __commonJS({
  "node_modules/lodash/_getFuncName.js"(exports, module) {
    var realNames = require_realNames();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function getFuncName(func) {
      var result = func.name + "", array2 = realNames[result], length2 = hasOwnProperty2.call(realNames, result) ? array2.length : 0;
      while (length2--) {
        var data2 = array2[length2], otherFunc = data2.func;
        if (otherFunc == null || otherFunc == func) {
          return data2.name;
        }
      }
      return result;
    }
    module.exports = getFuncName;
  }
});

// node_modules/lodash/_LodashWrapper.js
var require_LodashWrapper = __commonJS({
  "node_modules/lodash/_LodashWrapper.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var baseLodash = require_baseLodash();
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = void 0;
    }
    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;
    module.exports = LodashWrapper;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray3 = Array.isArray;
    module.exports = isArray3;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray2(source, array2) {
      var index2 = -1, length2 = source.length;
      array2 || (array2 = Array(length2));
      while (++index2 < length2) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    module.exports = copyArray2;
  }
});

// node_modules/lodash/_wrapperClone.js
var require_wrapperClone = __commonJS({
  "node_modules/lodash/_wrapperClone.js"(exports, module) {
    var LazyWrapper = require_LazyWrapper();
    var LodashWrapper = require_LodashWrapper();
    var copyArray2 = require_copyArray();
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray2(wrapper.__actions__);
      result.__index__ = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }
    module.exports = wrapperClone;
  }
});

// node_modules/lodash/wrapperLodash.js
var require_wrapperLodash = __commonJS({
  "node_modules/lodash/wrapperLodash.js"(exports, module) {
    var LazyWrapper = require_LazyWrapper();
    var LodashWrapper = require_LodashWrapper();
    var baseLodash = require_baseLodash();
    var isArray3 = require_isArray();
    var isObjectLike = require_isObjectLike();
    var wrapperClone = require_wrapperClone();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function lodash(value) {
      if (isObjectLike(value) && !isArray3(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty2.call(value, "__wrapped__")) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;
    module.exports = lodash;
  }
});

// node_modules/lodash/_isLaziable.js
var require_isLaziable = __commonJS({
  "node_modules/lodash/_isLaziable.js"(exports, module) {
    var LazyWrapper = require_LazyWrapper();
    var getData = require_getData();
    var getFuncName = require_getFuncName();
    var lodash = require_wrapperLodash();
    function isLaziable(func) {
      var funcName = getFuncName(func), other = lodash[funcName];
      if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data2 = getData(other);
      return !!data2 && func === data2[0];
    }
    module.exports = isLaziable;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setData.js
var require_setData = __commonJS({
  "node_modules/lodash/_setData.js"(exports, module) {
    var baseSetData = require_baseSetData();
    var shortOut = require_shortOut();
    var setData = shortOut(baseSetData);
    module.exports = setData;
  }
});

// node_modules/lodash/_getWrapDetails.js
var require_getWrapDetails = __commonJS({
  "node_modules/lodash/_getWrapDetails.js"(exports, module) {
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
    var reSplitDetails = /,? & /;
    function getWrapDetails(source) {
      var match2 = source.match(reWrapDetails);
      return match2 ? match2[1].split(reSplitDetails) : [];
    }
    module.exports = getWrapDetails;
  }
});

// node_modules/lodash/_insertWrapDetails.js
var require_insertWrapDetails = __commonJS({
  "node_modules/lodash/_insertWrapDetails.js"(exports, module) {
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
    function insertWrapDetails(source, details) {
      var length2 = details.length;
      if (!length2) {
        return source;
      }
      var lastIndex = length2 - 1;
      details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
      details = details.join(length2 > 2 ? ", " : " ");
      return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
    }
    module.exports = insertWrapDetails;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty4 = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module.exports = defineProperty4;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    var constant = require_constant();
    var defineProperty4 = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty4 ? identity : function(func, string2) {
      return defineProperty4(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length2 = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return index2;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array2, value, fromIndex) {
      var index2 = fromIndex - 1, length2 = array2.length;
      while (++index2 < length2) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes2(array2, value) {
      var length2 = array2 == null ? 0 : array2.length;
      return !!length2 && baseIndexOf(array2, value, 0) > -1;
    }
    module.exports = arrayIncludes2;
  }
});

// node_modules/lodash/_updateWrapDetails.js
var require_updateWrapDetails = __commonJS({
  "node_modules/lodash/_updateWrapDetails.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var arrayIncludes2 = require_arrayIncludes();
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_CURRY_RIGHT_FLAG = 16;
    var WRAP_PARTIAL_FLAG = 32;
    var WRAP_PARTIAL_RIGHT_FLAG = 64;
    var WRAP_ARY_FLAG = 128;
    var WRAP_REARG_FLAG = 256;
    var WRAP_FLIP_FLAG = 512;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = "_." + pair[0];
        if (bitmask & pair[1] && !arrayIncludes2(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }
    module.exports = updateWrapDetails;
  }
});

// node_modules/lodash/_setWrapToString.js
var require_setWrapToString = __commonJS({
  "node_modules/lodash/_setWrapToString.js"(exports, module) {
    var getWrapDetails = require_getWrapDetails();
    var insertWrapDetails = require_insertWrapDetails();
    var setToString = require_setToString();
    var updateWrapDetails = require_updateWrapDetails();
    function setWrapToString(wrapper, reference, bitmask) {
      var source = reference + "";
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }
    module.exports = setWrapToString;
  }
});

// node_modules/lodash/_createRecurry.js
var require_createRecurry = __commonJS({
  "node_modules/lodash/_createRecurry.js"(exports, module) {
    var isLaziable = require_isLaziable();
    var setData = require_setData();
    var setWrapToString = require_setWrapToString();
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_BOUND_FLAG = 4;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_PARTIAL_FLAG = 32;
    var WRAP_PARTIAL_RIGHT_FLAG = 64;
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
      bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func,
        bitmask,
        thisArg,
        newPartials,
        newHolders,
        newPartialsRight,
        newHoldersRight,
        argPos,
        ary,
        arity
      ];
      var result = wrapFunc.apply(void 0, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }
    module.exports = createRecurry;
  }
});

// node_modules/lodash/_getHolder.js
var require_getHolder = __commonJS({
  "node_modules/lodash/_getHolder.js"(exports, module) {
    function getHolder(func) {
      var object2 = func;
      return object2.placeholder;
    }
    module.exports = getHolder;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/_reorder.js
var require_reorder = __commonJS({
  "node_modules/lodash/_reorder.js"(exports, module) {
    var copyArray2 = require_copyArray();
    var isIndex = require_isIndex();
    var nativeMin = Math.min;
    function reorder(array2, indexes) {
      var arrLength = array2.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array2);
      while (length2--) {
        var index2 = indexes[length2];
        array2[length2] = isIndex(index2, arrLength) ? oldArray[index2] : void 0;
      }
      return array2;
    }
    module.exports = reorder;
  }
});

// node_modules/lodash/_replaceHolders.js
var require_replaceHolders = __commonJS({
  "node_modules/lodash/_replaceHolders.js"(exports, module) {
    var PLACEHOLDER = "__lodash_placeholder__";
    function replaceHolders(array2, placeholder) {
      var index2 = -1, length2 = array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array2[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    module.exports = replaceHolders;
  }
});

// node_modules/lodash/_createHybrid.js
var require_createHybrid = __commonJS({
  "node_modules/lodash/_createHybrid.js"(exports, module) {
    var composeArgs = require_composeArgs();
    var composeArgsRight = require_composeArgsRight();
    var countHolders = require_countHolders();
    var createCtor = require_createCtor();
    var createRecurry = require_createRecurry();
    var getHolder = require_getHolder();
    var reorder = require_reorder();
    var replaceHolders = require_replaceHolders();
    var root = require_root();
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_CURRY_RIGHT_FLAG = 16;
    var WRAP_ARY_FLAG = 128;
    var WRAP_FLIP_FLAG = 512;
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor(func);
      function wrapper() {
        var length2 = arguments.length, args = Array(length2), index2 = length2;
        while (index2--) {
          args[index2] = arguments[index2];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length2 -= holdersCount;
        if (isCurried && length2 < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            thisArg,
            args,
            newHolders,
            argPos,
            ary,
            arity - length2
          );
        }
        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
        length2 = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length2 > 1) {
          args.reverse();
        }
        if (isAry && ary < length2) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }
    module.exports = createHybrid;
  }
});

// node_modules/lodash/_createCurry.js
var require_createCurry = __commonJS({
  "node_modules/lodash/_createCurry.js"(exports, module) {
    var apply = require_apply();
    var createCtor = require_createCtor();
    var createHybrid = require_createHybrid();
    var createRecurry = require_createRecurry();
    var getHolder = require_getHolder();
    var replaceHolders = require_replaceHolders();
    var root = require_root();
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);
      function wrapper() {
        var length2 = arguments.length, args = Array(length2), index2 = length2, placeholder = getHolder(wrapper);
        while (index2--) {
          args[index2] = arguments[index2];
        }
        var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
        length2 -= holders.length;
        if (length2 < arity) {
          return createRecurry(
            func,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            void 0,
            args,
            holders,
            void 0,
            void 0,
            arity - length2
          );
        }
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }
    module.exports = createCurry;
  }
});

// node_modules/lodash/_createPartial.js
var require_createPartial = __commonJS({
  "node_modules/lodash/_createPartial.js"(exports, module) {
    var apply = require_apply();
    var createCtor = require_createCtor();
    var root = require_root();
    var WRAP_BIND_FLAG = 1;
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }
    module.exports = createPartial;
  }
});

// node_modules/lodash/_mergeData.js
var require_mergeData = __commonJS({
  "node_modules/lodash/_mergeData.js"(exports, module) {
    var composeArgs = require_composeArgs();
    var composeArgsRight = require_composeArgsRight();
    var replaceHolders = require_replaceHolders();
    var PLACEHOLDER = "__lodash_placeholder__";
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_BOUND_FLAG = 4;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_ARY_FLAG = 128;
    var WRAP_REARG_FLAG = 256;
    var nativeMin = Math.min;
    function mergeData(data2, source) {
      var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
      var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
      if (!(isCommon || isCombo)) {
        return data2;
      }
      if (srcBitmask & WRAP_BIND_FLAG) {
        data2[2] = source[2];
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      var value = source[3];
      if (value) {
        var partials = data2[3];
        data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
      }
      value = source[5];
      if (value) {
        partials = data2[5];
        data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
      }
      value = source[7];
      if (value) {
        data2[7] = value;
      }
      if (srcBitmask & WRAP_ARY_FLAG) {
        data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
      }
      if (data2[9] == null) {
        data2[9] = source[9];
      }
      data2[0] = source[0];
      data2[1] = newBitmask;
      return data2;
    }
    module.exports = mergeData;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol2;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject2 = require_isObject();
    var isSymbol2 = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module) {
    var toFinite = require_toFinite();
    function toInteger2(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module.exports = toInteger2;
  }
});

// node_modules/lodash/_createWrap.js
var require_createWrap = __commonJS({
  "node_modules/lodash/_createWrap.js"(exports, module) {
    var baseSetData = require_baseSetData();
    var createBind = require_createBind();
    var createCurry = require_createCurry();
    var createHybrid = require_createHybrid();
    var createPartial = require_createPartial();
    var getData = require_getData();
    var mergeData = require_mergeData();
    var setData = require_setData();
    var setWrapToString = require_setWrapToString();
    var toInteger2 = require_toInteger();
    var FUNC_ERROR_TEXT = "Expected a function";
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_CURRY_RIGHT_FLAG = 16;
    var WRAP_PARTIAL_FLAG = 32;
    var WRAP_PARTIAL_RIGHT_FLAG = 64;
    var nativeMax = Math.max;
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length2 = partials ? partials.length : 0;
      if (!length2) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = void 0;
      }
      ary = ary === void 0 ? ary : nativeMax(toInteger2(ary), 0);
      arity = arity === void 0 ? arity : toInteger2(arity);
      length2 -= holders ? holders.length : 0;
      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = void 0;
      }
      var data2 = isBindKey ? void 0 : getData(func);
      var newData = [
        func,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary,
        arity
      ];
      if (data2) {
        mergeData(newData, data2);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(void 0, newData);
      }
      var setter = data2 ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }
    module.exports = createWrap;
  }
});

// node_modules/lodash/ary.js
var require_ary = __commonJS({
  "node_modules/lodash/ary.js"(exports, module) {
    var createWrap = require_createWrap();
    var WRAP_ARY_FLAG = 128;
    function ary(func, n, guard) {
      n = guard ? void 0 : n;
      n = func && n == null ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, void 0, void 0, void 0, void 0, n);
    }
    module.exports = ary;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty4 = require_defineProperty();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty4) {
        defineProperty4(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty2.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length2 = props.length;
      while (++index2 < length2) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var propertyIsEnumerable4 = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable4.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray3 = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys4(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    module.exports = keys4;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys4 = require_keys();
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys4(source), object2);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice3 = arrayProto.splice;
    function listCacheDelete(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice3.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries2) {
      var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map = getNative(root, "Map");
    module.exports = Map;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries2) {
      var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map3, key) {
      var data2 = map3.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries2) {
      var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries2) {
      var data2 = this.__data__ = new ListCache(entries2);
      this.size = data2.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject2 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject2(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    module.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable4 = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol2) {
        return propertyIsEnumerable4.call(object2, symbol2);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array2, values3) {
      var index2 = -1, length2 = values3.length, offset = array2.length;
      while (++index2 < length2) {
        array2[offset + index2] = values3[index2];
      }
      return array2;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray3 = require_isArray();
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray3(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys4 = require_keys();
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys4, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set = getNative(root, "Set");
    module.exports = Set;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView2 = require_DataView();
    var Map = require_Map();
    var Promise2 = require_Promise();
    var Set = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function initCloneArray(array2) {
      var length2 = array2.length, result = new array2.constructor(length2);
      if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol2) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol2)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object2);
        case boolTag:
        case dateTag:
          return new Ctor(+object2);
        case dataViewTag:
          return cloneDataView(object2, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object2, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object2);
        case regexpTag:
          return cloneRegExp(object2);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object2);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray2 = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray3 = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject2 = require_isObject();
    var isSet = require_isSet();
    var keys4 = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray3(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray2(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys4;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone2(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module.exports = clone2;
  }
});

// node_modules/lodash/curry.js
var require_curry = __commonJS({
  "node_modules/lodash/curry.js"(exports, module) {
    var createWrap = require_createWrap();
    var WRAP_CURRY_FLAG = 8;
    function curry(func, arity, guard) {
      arity = guard ? void 0 : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
      result.placeholder = curry.placeholder;
      return result;
    }
    curry.placeholder = {};
    module.exports = curry;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/lodash/isError.js
var require_isError = __commonJS({
  "node_modules/lodash/isError.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var isPlainObject = require_isPlainObject();
    var domExcTag = "[object DOMException]";
    var errorTag = "[object Error]";
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
    }
    module.exports = isError;
  }
});

// node_modules/lodash/isWeakMap.js
var require_isWeakMap = __commonJS({
  "node_modules/lodash/isWeakMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var weakMapTag = "[object WeakMap]";
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }
    module.exports = isWeakMap;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values3) {
      var index2 = -1, length2 = values3 == null ? 0 : values3.length;
      this.__data__ = new MapCache();
      while (++index2 < length2) {
        this.add(values3[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map3) {
      var index2 = -1, result = Array(map3.size);
      map3.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert2 = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert2 || (convert2 = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray3 = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray3(object2), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports, module) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length2;
      }
      object2 = Object(object2);
      while (index2--) {
        var data2 = matchData[index2];
        if (noCustomizer && data2[2] ? data2[1] !== object2[data2[0]] : !(data2[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length2) {
        data2 = matchData[index2];
        var key = data2[0], objValue = object2[key], srcValue = data2[1];
        if (noCustomizer && data2[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports, module) {
    var isObject2 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject2(value);
    }
    module.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports, module) {
    var isStrictComparable = require_isStrictComparable();
    var keys4 = require_keys();
    function getMatchData(object2) {
      var result = keys4(object2), length2 = result.length;
      while (length2--) {
        var key = result[length2], value = object2[key];
        result[length2] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    module.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports, module) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    module.exports = baseMatches;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray3 = require_isArray();
    var isSymbol2 = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray3(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match2, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray3 = require_isArray();
    var isSymbol2 = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray3(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol2(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString3(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString3;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray3 = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString3 = require_toString();
    function castPath(value, object2) {
      if (isArray3(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath(toString3(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol2 = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol2(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object2, path2) {
      path2 = castPath(path2, object2);
      var index2 = 0, length2 = path2.length;
      while (object2 != null && index2 < length2) {
        object2 = object2[toKey(path2[index2++])];
      }
      return index2 && index2 == length2 ? object2 : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get2(object2, path2, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path2);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get2;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module) {
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    module.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray3 = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object2, path2, hasFunc) {
      path2 = castPath(path2, object2);
      var index2 = -1, length2 = path2.length, result = false;
      while (++index2 < length2) {
        var key = toKey(path2[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length2) {
        return result;
      }
      length2 = object2 == null ? 0 : object2.length;
      return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray3(object2) || isArguments(object2));
    }
    module.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object2, path2) {
      return object2 != null && hasPath(object2, path2, baseHasIn);
    }
    module.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    var get2 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object2) {
        var objValue = get2(object2, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module) {
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path2) {
      return function(object2) {
        return baseGet(object2, path2);
      };
    }
    module.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    module.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports, module) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray3 = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module.exports = baseIteratee;
  }
});

// node_modules/lodash/iteratee.js
var require_iteratee = __commonJS({
  "node_modules/lodash/iteratee.js"(exports, module) {
    var baseClone = require_baseClone();
    var baseIteratee = require_baseIteratee();
    var CLONE_DEEP_FLAG = 1;
    function iteratee(func) {
      return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
    }
    module.exports = iteratee;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray3 = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array2, depth, predicate, isStrict, result) {
      var index2 = -1, length2 = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length2) {
        var value = array2[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    function flatten(array2) {
      var length2 = array2 == null ? 0 : array2.length;
      return length2 ? baseFlatten(array2, 1) : [];
    }
    module.exports = flatten;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array2 = Array(length2);
        while (++index2 < length2) {
          array2[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform(array2);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/lodash/_flatRest.js"(exports, module) {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    module.exports = flatRest;
  }
});

// node_modules/lodash/rearg.js
var require_rearg = __commonJS({
  "node_modules/lodash/rearg.js"(exports, module) {
    var createWrap = require_createWrap();
    var flatRest = require_flatRest();
    var WRAP_REARG_FLAG = 256;
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, void 0, void 0, void 0, indexes);
    });
    module.exports = rearg;
  }
});

// node_modules/lodash/toPath.js
var require_toPath = __commonJS({
  "node_modules/lodash/toPath.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var copyArray2 = require_copyArray();
    var isArray3 = require_isArray();
    var isSymbol2 = require_isSymbol();
    var stringToPath = require_stringToPath();
    var toKey = require_toKey();
    var toString3 = require_toString();
    function toPath(value) {
      if (isArray3(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol2(value) ? [value] : copyArray2(stringToPath(toString3(value)));
    }
    module.exports = toPath;
  }
});

// node_modules/lodash/fp/_util.js
var require_util = __commonJS({
  "node_modules/lodash/fp/_util.js"(exports, module) {
    module.exports = {
      "ary": require_ary(),
      "assign": require_baseAssign(),
      "clone": require_clone(),
      "curry": require_curry(),
      "forEach": require_arrayEach(),
      "isArray": require_isArray(),
      "isError": require_isError(),
      "isFunction": require_isFunction(),
      "isWeakMap": require_isWeakMap(),
      "iteratee": require_iteratee(),
      "keys": require_baseKeys(),
      "rearg": require_rearg(),
      "toInteger": require_toInteger(),
      "toPath": require_toPath()
    };
  }
});

// node_modules/lodash/fp/convert.js
var require_convert = __commonJS({
  "node_modules/lodash/fp/convert.js"(exports, module) {
    var baseConvert = require_baseConvert();
    var util = require_util();
    function convert2(name, func, options2) {
      return baseConvert(util, name, func, options2);
    }
    module.exports = convert2;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module.exports = baseRest;
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object2, key, value) {
      if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray2 = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray3 = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject2 = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray3(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray2(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject2(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object2, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject2 = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object2, source, srcIndex, customizer, stack) {
      if (object2 === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject2(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/_customDefaultsMerge.js
var require_customDefaultsMerge = __commonJS({
  "node_modules/lodash/_customDefaultsMerge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var isObject2 = require_isObject();
    function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
      if (isObject2(objValue) && isObject2(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    module.exports = customDefaultsMerge;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject2 = require_isObject();
    function isIterateeCall(value, index2, object2) {
      if (!isObject2(object2)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type == "string" && index2 in object2) {
        return eq(object2[index2], value);
      }
      return false;
    }
    module.exports = isIterateeCall;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object2 = Object(object2);
        while (++index2 < length2) {
          var source = sources[index2];
          if (source) {
            assigner(object2, source, index2, customizer);
          }
        }
        return object2;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/lodash/mergeWith.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
      baseMerge(object2, source, srcIndex, customizer);
    });
    module.exports = mergeWith;
  }
});

// node_modules/lodash/defaultsDeep.js
var require_defaultsDeep = __commonJS({
  "node_modules/lodash/defaultsDeep.js"(exports, module) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var customDefaultsMerge = require_customDefaultsMerge();
    var mergeWith = require_mergeWith();
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    module.exports = defaultsDeep;
  }
});

// node_modules/lodash/fp/defaultsDeep.js
var require_defaultsDeep2 = __commonJS({
  "node_modules/lodash/fp/defaultsDeep.js"(exports, module) {
    var convert2 = require_convert();
    var func = convert2("defaultsDeep", require_defaultsDeep());
    func.placeholder = require_placeholder();
    module.exports = func;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    module.exports = isEqual;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array2, value, comparator) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (comparator(value, array2[index2])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes2 = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array2, values3, iteratee, comparator) {
      var index2 = -1, includes4 = arrayIncludes2, isCommon = true, length2 = array2.length, result = [], valuesLength = values3.length;
      if (!length2) {
        return result;
      }
      if (iteratee) {
        values3 = arrayMap(values3, baseUnary(iteratee));
      }
      if (comparator) {
        includes4 = arrayIncludesWith;
        isCommon = false;
      } else if (values3.length >= LARGE_ARRAY_SIZE) {
        includes4 = cacheHas;
        isCommon = false;
        values3 = new SetCache(values3);
      }
      outer:
        while (++index2 < length2) {
          var value = array2[index2], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values3[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes4(values3, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    function last(array2) {
      var length2 = array2 == null ? 0 : array2.length;
      return length2 ? array2[length2 - 1] : void 0;
    }
    module.exports = last;
  }
});

// node_modules/lodash/differenceWith.js
var require_differenceWith = __commonJS({
  "node_modules/lodash/differenceWith.js"(exports, module) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var last = require_last();
    var differenceWith = baseRest(function(array2, values3) {
      var comparator = last(values3);
      if (isArrayLikeObject(comparator)) {
        comparator = void 0;
      }
      return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject, true), void 0, comparator) : [];
    });
    module.exports = differenceWith;
  }
});

// node_modules/react-vis-network-graph/node_modules/vis-network/standalone/esm/vis-network.js
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path2, base) {
      return commonjsRequire(path2, base === void 0 || base === null ? module.path : base);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
function drawCircle(ctx, x, y, r) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2 * Math.PI, false);
  ctx.closePath();
}
function drawSquare(ctx, x, y, r) {
  ctx.beginPath();
  ctx.rect(x - r, y - r, r * 2, r * 2);
  ctx.closePath();
}
function drawTriangle(ctx, x, y, r) {
  ctx.beginPath();
  r *= 1.15;
  y += 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s;
  var h = Math.sqrt(s * s - s2 * s2);
  ctx.moveTo(x, y - (h - ir));
  ctx.lineTo(x + s2, y + ir);
  ctx.lineTo(x - s2, y + ir);
  ctx.lineTo(x, y - (h - ir));
  ctx.closePath();
}
function drawTriangleDown(ctx, x, y, r) {
  ctx.beginPath();
  r *= 1.15;
  y -= 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s;
  var h = Math.sqrt(s * s - s2 * s2);
  ctx.moveTo(x, y + (h - ir));
  ctx.lineTo(x + s2, y - ir);
  ctx.lineTo(x - s2, y - ir);
  ctx.lineTo(x, y + (h - ir));
  ctx.closePath();
}
function drawStar(ctx, x, y, r) {
  ctx.beginPath();
  r *= 0.82;
  y += 0.1 * r;
  for (var n = 0; n < 10; n++) {
    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
  }
  ctx.closePath();
}
function drawDiamond(ctx, x, y, r) {
  ctx.beginPath();
  ctx.lineTo(x, y + r);
  ctx.lineTo(x + r, y);
  ctx.lineTo(x, y - r);
  ctx.lineTo(x - r, y);
  ctx.closePath();
}
function drawRoundRect(ctx, x, y, w, h, r) {
  var r2d = Math.PI / 180;
  if (w - 2 * r < 0) {
    r = w / 2;
  }
  if (h - 2 * r < 0) {
    r = h / 2;
  }
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
  ctx.lineTo(x + w, y + h - r);
  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
  ctx.lineTo(x + r, y + h);
  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
  ctx.lineTo(x, y + r);
  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
  ctx.closePath();
}
function drawEllipse(ctx, x, y, w, h) {
  var kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
  ctx.beginPath();
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
}
function drawDatabase(ctx, x, y, w, h) {
  var f2 = 1 / 3;
  var wEllipse = w;
  var hEllipse = h * f2;
  var kappa = 0.5522848, ox = wEllipse / 2 * kappa, oy = hEllipse / 2 * kappa, xe = x + wEllipse, ye = y + hEllipse, xm = x + wEllipse / 2, ym = y + hEllipse / 2, ymb = y + (h - hEllipse / 2), yeb = y + h;
  ctx.beginPath();
  ctx.moveTo(xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.lineTo(xe, ymb);
  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);
  ctx.lineTo(x, ym);
}
function drawDashedLine(ctx, x, y, x2, y2, pattern) {
  ctx.beginPath();
  ctx.moveTo(x, y);
  var patternLength = pattern.length;
  var dx = x2 - x;
  var dy = y2 - y;
  var slope = dy / dx;
  var distRemaining = Math.sqrt(dx * dx + dy * dy);
  var patternIndex = 0;
  var draw = true;
  var xStep = 0;
  var dashLength = +pattern[0];
  while (distRemaining >= 0.1) {
    dashLength = +pattern[patternIndex++ % patternLength];
    if (dashLength > distRemaining) {
      dashLength = distRemaining;
    }
    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    xStep = dx < 0 ? -xStep : xStep;
    x += xStep;
    y += slope * xStep;
    if (draw === true) {
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
    }
    distRemaining -= dashLength;
    draw = !draw;
  }
}
function drawHexagon(ctx, x, y, r) {
  ctx.beginPath();
  var sides = 6;
  var a = Math.PI * 2 / sides;
  ctx.moveTo(x + r, y);
  for (var i = 1; i < sides; i++) {
    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
  }
  ctx.closePath();
}
function getShape(name) {
  if (Object.prototype.hasOwnProperty.call(shapeMap, name)) {
    return shapeMap[name];
  } else {
    return function(ctx) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      CanvasRenderingContext2D.prototype[name].call(ctx, args);
    };
  }
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    defineProperty$6(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayWithHoles(arr) {
  if (isArray$3(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof symbol$2 === "undefined" || !isIterable$1(Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = getIterator$1(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _unsupportedIterableToArray(o, minLen) {
  var _context;
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = slice$3(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from_1$4(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
function _arrayWithoutHoles(arr) {
  if (isArray$3(arr)) return arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof symbol$2 !== "undefined" && isIterable$1(Object(iter))) return from_1$4(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it2;
  if (typeof symbol$4 === "undefined" || getIteratorMethod$1(o) == null) {
    if (isArray$5(o) || (it2 = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it2) o = it2;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it2 = getIterator$1(o);
  }, n: function n() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null) it2.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  var _context13;
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = slice$5(_context13 = Object.prototype.toString.call(o)).call(_context13, 8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from_1$2(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function pureDeepObjectAssign(base) {
  var _context;
  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    updates[_key - 1] = arguments[_key];
  }
  return deepObjectAssign.apply(void 0, concat$2(_context = [{}, base]).call(_context, updates));
}
function deepObjectAssign() {
  var merged = deepObjectAssignNonentry.apply(void 0, arguments);
  stripDelete(merged);
  return merged;
}
function deepObjectAssignNonentry() {
  for (var _len2 = arguments.length, values3 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values3[_key2] = arguments[_key2];
  }
  if (values3.length < 2) {
    return values3[0];
  } else if (values3.length > 2) {
    var _context2;
    return deepObjectAssignNonentry.apply(void 0, concat$2(_context2 = [deepObjectAssign(values3[0], values3[1])]).call(_context2, toConsumableArray(slice$5(values3).call(values3, 2))));
  }
  var a = values3[0];
  var b = values3[1];
  var _iterator = _createForOfIteratorHelper(ownKeys$3(b)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var prop = _step.value;
      if (Object.prototype.propertyIsEnumerable.call(b, b[prop])) ;
      else if (b[prop] === DELETE) {
        delete a[prop];
      } else if (a[prop] !== null && b[prop] !== null && _typeof_1(a[prop]) === "object" && _typeof_1(b[prop]) === "object" && !isArray$5(a[prop]) && !isArray$5(b[prop])) {
        a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);
      } else {
        a[prop] = clone(b[prop]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return a;
}
function clone(a) {
  if (isArray$5(a)) {
    return map$2(a).call(a, function(value) {
      return clone(value);
    });
  } else if (_typeof_1(a) === "object" && a !== null) {
    return deepObjectAssignNonentry({}, a);
  } else {
    return a;
  }
}
function stripDelete(a) {
  for (var _i = 0, _Object$keys = keys$3(a); _i < _Object$keys.length; _i++) {
    var prop = _Object$keys[_i];
    if (a[prop] === DELETE) {
      delete a[prop];
    } else if (_typeof_1(a[prop]) === "object" && a[prop] !== null) {
      stripDelete(a[prop]);
    }
  }
}
function Alea() {
  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    seed[_key3] = arguments[_key3];
  }
  return AleaImplementation(seed.length ? seed : [now$2()]);
}
function AleaImplementation(seed) {
  var _mashSeed = mashSeed(seed), _mashSeed2 = slicedToArray(_mashSeed, 3), s0 = _mashSeed2[0], s1 = _mashSeed2[1], s2 = _mashSeed2[2];
  var c2 = 1;
  var random = function random2() {
    var t = 2091639 * s0 + c2 * 23283064365386963e-26;
    s0 = s1;
    s1 = s2;
    return s2 = t - (c2 = t | 0);
  };
  random.uint32 = function() {
    return random() * 4294967296;
  };
  random.fract53 = function() {
    return random() + (random() * 2097152 | 0) * 11102230246251565e-32;
  };
  random.algorithm = "Alea";
  random.seed = seed;
  random.version = "0.9";
  return random;
}
function mashSeed() {
  var mash = Mash();
  var s0 = mash(" ");
  var s1 = mash(" ");
  var s2 = mash(" ");
  for (var i = 0; i < arguments.length; i++) {
    s0 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s0 < 0) {
      s0 += 1;
    }
    s1 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s1 < 0) {
      s1 += 1;
    }
    s2 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s2 < 0) {
      s2 += 1;
    }
  }
  return [s0, s1, s2];
}
function Mash() {
  var n = 4022871197;
  return function(data2) {
    var string2 = data2.toString();
    for (var i = 0; i < string2.length; i++) {
      n += string2.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 4294967296;
    }
    return (n >>> 0) * 23283064365386963e-26;
  };
}
function isNumber(value) {
  return value instanceof Number || typeof value === "number";
}
function recursiveDOMDelete(DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      var child = DOMobject.firstChild;
      if (child) {
        recursiveDOMDelete(child);
        DOMobject.removeChild(child);
      }
    }
  }
}
function isString(value) {
  return value instanceof String || typeof value === "string";
}
function isObject$1(value) {
  return _typeof_1(value) === "object" && value !== null;
}
function copyOrDelete(a, b, prop, allowDeletion) {
  var doDeletion = false;
  if (allowDeletion === true) {
    doDeletion = b[prop] === null && a[prop] !== void 0;
  }
  if (doDeletion) {
    delete a[prop];
  } else {
    a[prop] = b[prop];
  }
}
function fillIfDefined(a, b) {
  var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  for (var prop in a) {
    if (b[prop] !== void 0) {
      if (b[prop] === null || _typeof_1(b[prop]) !== "object") {
        copyOrDelete(a, b, prop, allowDeletion);
      } else {
        var aProp = a[prop];
        var bProp = b[prop];
        if (isObject$1(aProp) && isObject$1(bProp)) {
          fillIfDefined(aProp, bProp, allowDeletion);
        }
      }
    }
  }
}
function selectiveDeepExtend(props, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (isArray$5(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (var p = 0; p < props.length; p++) {
    var prop = props[p];
    if (Object.prototype.hasOwnProperty.call(b, prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === void 0) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$5(b[prop])) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }
  return a;
}
function selectiveNotDeepExtend(propsToExclude, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (isArray$5(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (var prop in b) {
    if (!Object.prototype.hasOwnProperty.call(b, prop)) {
      continue;
    }
    if (indexOf$3(propsToExclude).call(propsToExclude, prop) !== -1) {
      continue;
    }
    if (b[prop] && b[prop].constructor === Object) {
      if (a[prop] === void 0) {
        a[prop] = {};
      }
      if (a[prop].constructor === Object) {
        deepExtend(a[prop], b[prop]);
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    } else if (isArray$5(b[prop])) {
      a[prop] = [];
      for (var i = 0; i < b[prop].length; i++) {
        a[prop].push(b[prop][i]);
      }
    } else {
      copyOrDelete(a, b, prop, allowDeletion);
    }
  }
  return a;
}
function deepExtend(a, b) {
  var protoExtend = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  for (var prop in b) {
    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {
      if (_typeof_1(b[prop]) === "object" && b[prop] !== null && getPrototypeOf$2(b[prop]) === Object.prototype) {
        if (a[prop] === void 0) {
          a[prop] = deepExtend({}, b[prop], protoExtend);
        } else if (_typeof_1(a[prop]) === "object" && a[prop] !== null && getPrototypeOf$2(a[prop]) === Object.prototype) {
          deepExtend(a[prop], b[prop], protoExtend);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$5(b[prop])) {
        var _context3;
        a[prop] = slice$5(_context3 = b[prop]).call(_context3);
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }
  return a;
}
function getType(object2) {
  var type = _typeof_1(object2);
  if (type === "object") {
    if (object2 === null) {
      return "null";
    }
    if (object2 instanceof Boolean) {
      return "Boolean";
    }
    if (object2 instanceof Number) {
      return "Number";
    }
    if (object2 instanceof String) {
      return "String";
    }
    if (isArray$5(object2)) {
      return "Array";
    }
    if (object2 instanceof Date) {
      return "Date";
    }
    return "Object";
  }
  if (type === "number") {
    return "Number";
  }
  if (type === "boolean") {
    return "Boolean";
  }
  if (type === "string") {
    return "String";
  }
  if (type === void 0) {
    return "undefined";
  }
  return type;
}
function copyAndExtendArray(arr, newValue) {
  var _context4;
  return concat$2(_context4 = []).call(_context4, toConsumableArray(arr), [newValue]);
}
function copyArray(arr) {
  return slice$5(arr).call(arr);
}
function getAbsoluteLeft(elem) {
  return elem.getBoundingClientRect().left;
}
function getAbsoluteTop(elem) {
  return elem.getBoundingClientRect().top;
}
function addClassName(elem, classNames) {
  var classes = elem.className.split(" ");
  var newClasses = classNames.split(" ");
  classes = concat$2(classes).call(classes, filter$2(newClasses).call(newClasses, function(className) {
    return indexOf$3(classes).call(classes, className) < 0;
  }));
  elem.className = classes.join(" ");
}
function removeClassName(elem, classNames) {
  var classes = elem.className.split(" ");
  var oldClasses = classNames.split(" ");
  classes = filter$2(classes).call(classes, function(className) {
    return indexOf$3(oldClasses).call(oldClasses, className) < 0;
  });
  elem.className = classes.join(" ");
}
function forEach$3(object2, callback) {
  if (isArray$5(object2)) {
    var len = object2.length;
    for (var i = 0; i < len; i++) {
      callback(object2[i], i, object2);
    }
  } else {
    for (var key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        callback(object2[key], key, object2);
      }
    }
  }
}
function addEventListener(element, action, listener, useCapture) {
  if (element.addEventListener) {
    var _context5;
    if (useCapture === void 0) {
      useCapture = false;
    }
    if (action === "mousewheel" && indexOf$3(_context5 = navigator.userAgent).call(_context5, "Firefox") >= 0) {
      action = "DOMMouseScroll";
    }
    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent("on" + action, listener);
  }
}
function removeEventListener(element, action, listener, useCapture) {
  if (element.removeEventListener) {
    var _context6;
    if (useCapture === void 0) {
      useCapture = false;
    }
    if (action === "mousewheel" && indexOf$3(_context6 = navigator.userAgent).call(_context6, "Firefox") >= 0) {
      action = "DOMMouseScroll";
    }
    element.removeEventListener(action, listener, useCapture);
  } else {
    element.detachEvent("on" + action, listener);
  }
}
function hexToRGB(hex2) {
  var result;
  switch (hex2.length) {
    case 3:
    case 4:
      result = shortHexRE.exec(hex2);
      return result ? {
        r: _parseInt$2(result[1] + result[1], 16),
        g: _parseInt$2(result[2] + result[2], 16),
        b: _parseInt$2(result[3] + result[3], 16)
      } : null;
    case 6:
    case 7:
      result = fullHexRE.exec(hex2);
      return result ? {
        r: _parseInt$2(result[1], 16),
        g: _parseInt$2(result[2], 16),
        b: _parseInt$2(result[3], 16)
      } : null;
    default:
      return null;
  }
}
function overrideOpacity(color, opacity) {
  if (indexOf$3(color).call(color, "rgba") !== -1) {
    return color;
  } else if (indexOf$3(color).call(color, "rgb") !== -1) {
    var rgb = color.substr(indexOf$3(color).call(color, "(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var _rgb = hexToRGB(color);
    if (_rgb == null) {
      return color;
    } else {
      return "rgba(" + _rgb.r + "," + _rgb.g + "," + _rgb.b + "," + opacity + ")";
    }
  }
}
function RGBToHex(red, green, blue) {
  var _context7;
  return "#" + slice$5(_context7 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context7, 1);
}
function parseColor(inputColor, defaultColor) {
  if (isString(inputColor)) {
    var colorStr = inputColor;
    if (isValidRGB(colorStr)) {
      var _context8;
      var rgb = map$2(_context8 = colorStr.substr(4).substr(0, colorStr.length - 5).split(",")).call(_context8, function(value) {
        return _parseInt$2(value);
      });
      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);
    }
    if (isValidHex(colorStr) === true) {
      var hsv = hexToHSV(colorStr);
      var lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      var darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      return {
        background: colorStr,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      return {
        background: colorStr,
        border: colorStr,
        highlight: {
          background: colorStr,
          border: colorStr
        },
        hover: {
          background: colorStr,
          border: colorStr
        }
      };
    }
  } else {
    if (defaultColor) {
      var color = {
        background: inputColor.background || defaultColor.background,
        border: inputColor.border || defaultColor.border,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,
          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,
          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background
        }
      };
      return color;
    } else {
      var _color = {
        background: inputColor.background || void 0,
        border: inputColor.border || void 0,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || void 0,
          border: inputColor.highlight && inputColor.highlight.border || void 0
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || void 0,
          background: inputColor.hover && inputColor.hover.background || void 0
        }
      };
      return _color;
    }
  }
}
function RGBToHSV(red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue));
  if (minRGB === maxRGB) {
    return {
      h: 0,
      s: 0,
      v: minRGB
    };
  }
  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;
  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return {
    h: hue,
    s: saturation,
    v: value
  };
}
function HSVToRGB(h, s, v) {
  var r;
  var g;
  var b;
  var i = Math.floor(h * 6);
  var f2 = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f2 * s);
  var t = v * (1 - (1 - f2) * s);
  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;
    case 1:
      r = q, g = v, b = p;
      break;
    case 2:
      r = p, g = v, b = t;
      break;
    case 3:
      r = p, g = q, b = v;
      break;
    case 4:
      r = t, g = p, b = v;
      break;
    case 5:
      r = v, g = p, b = q;
      break;
  }
  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}
function HSVToHex(h, s, v) {
  var rgb = HSVToRGB(h, s, v);
  return RGBToHex(rgb.r, rgb.g, rgb.b);
}
function hexToHSV(hex2) {
  var rgb = hexToRGB(hex2);
  if (!rgb) {
    throw new TypeError("'".concat(hex2, "' is not a valid color."));
  }
  return RGBToHSV(rgb.r, rgb.g, rgb.b);
}
function isValidHex(hex2) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex2);
  return isOk;
}
function isValidRGB(rgb) {
  return rgbRE.test(rgb);
}
function isValidRGBA(rgba) {
  return rgbaRE.test(rgba);
}
function bridgeObject(referenceObject) {
  if (referenceObject === null || _typeof_1(referenceObject) !== "object") {
    return null;
  }
  if (referenceObject instanceof Element) {
    return referenceObject;
  }
  var objectTo = create$2(referenceObject);
  for (var i in referenceObject) {
    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {
      if (_typeof_1(referenceObject[i]) == "object") {
        objectTo[i] = bridgeObject(referenceObject[i]);
      }
    }
  }
  return objectTo;
}
function mergeOptions(mergeTarget, options2, option) {
  var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var isPresent = function isPresent2(obj) {
    return obj !== null && obj !== void 0;
  };
  var isObject2 = function isObject3(obj) {
    return obj !== null && _typeof_1(obj) === "object";
  };
  var isEmpty = function isEmpty2(obj) {
    for (var x in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, x)) {
        return false;
      }
    }
    return true;
  };
  if (!isObject2(mergeTarget)) {
    throw new Error("Parameter mergeTarget must be an object");
  }
  if (!isObject2(options2)) {
    throw new Error("Parameter options must be an object");
  }
  if (!isPresent(option)) {
    throw new Error("Parameter option must have a value");
  }
  if (!isObject2(globalOptions)) {
    throw new Error("Parameter globalOptions must be an object");
  }
  var doMerge = function doMerge2(target, options3, option2) {
    if (!isObject2(target[option2])) {
      target[option2] = {};
    }
    var src = options3[option2];
    var dst = target[option2];
    for (var prop in src) {
      if (Object.prototype.hasOwnProperty.call(src, prop)) {
        dst[prop] = src[prop];
      }
    }
  };
  var srcOption = options2[option];
  var globalPassed = isObject2(globalOptions) && !isEmpty(globalOptions);
  var globalOption = globalPassed ? globalOptions[option] : void 0;
  var globalEnabled = globalOption ? globalOption.enabled : void 0;
  if (srcOption === void 0) {
    return;
  }
  if (typeof srcOption === "boolean") {
    if (!isObject2(mergeTarget[option])) {
      mergeTarget[option] = {};
    }
    mergeTarget[option].enabled = srcOption;
    return;
  }
  if (srcOption === null && !isObject2(mergeTarget[option])) {
    if (isPresent(globalOption)) {
      mergeTarget[option] = create$2(globalOption);
    } else {
      return;
    }
  }
  if (!isObject2(srcOption)) {
    return;
  }
  var enabled = true;
  if (srcOption.enabled !== void 0) {
    enabled = srcOption.enabled;
  } else {
    if (globalEnabled !== void 0) {
      enabled = globalOption.enabled;
    }
  }
  doMerge(mergeTarget, options2, option);
  mergeTarget[option].enabled = enabled;
}
function topMost(pile, accessors) {
  var candidate;
  if (!isArray$5(accessors)) {
    accessors = [accessors];
  }
  var _iterator2 = _createForOfIteratorHelper(pile), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var member = _step2.value;
      if (member) {
        candidate = member[accessors[0]];
        for (var i = 1; i < accessors.length; i++) {
          if (candidate) {
            candidate = candidate[accessors[i]];
          }
        }
        if (typeof candidate !== "undefined") {
          break;
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return candidate;
}
function parseDOT(data2) {
  dot = data2;
  return parseGraph();
}
function first() {
  index = 0;
  c = dot.charAt(0);
}
function next2() {
  index++;
  c = dot.charAt(index);
}
function nextPreview() {
  return dot.charAt(index + 1);
}
function isAlphaNumeric(c2) {
  return regexAlphaNumeric.test(c2);
}
function merge(a, b) {
  if (!a) {
    a = {};
  }
  if (b) {
    for (var name in b) {
      if (b.hasOwnProperty(name)) {
        a[name] = b[name];
      }
    }
  }
  return a;
}
function setValue(obj, path2, value) {
  var keys4 = path2.split(".");
  var o = obj;
  while (keys4.length) {
    var key = keys4.shift();
    if (keys4.length) {
      if (!o[key]) {
        o[key] = {};
      }
      o = o[key];
    } else {
      o[key] = value;
    }
  }
}
function addNode(graph, node) {
  var i, len;
  var current = null;
  var graphs = [graph];
  var root = graph;
  while (root.parent) {
    graphs.push(root.parent);
    root = root.parent;
  }
  if (root.nodes) {
    for (i = 0, len = root.nodes.length; i < len; i++) {
      if (node.id === root.nodes[i].id) {
        current = root.nodes[i];
        break;
      }
    }
  }
  if (!current) {
    current = {
      id: node.id
    };
    if (graph.node) {
      current.attr = merge(current.attr, graph.node);
    }
  }
  for (i = graphs.length - 1; i >= 0; i--) {
    var _context;
    var g = graphs[i];
    if (!g.nodes) {
      g.nodes = [];
    }
    if (indexOf$3(_context = g.nodes).call(_context, current) === -1) {
      g.nodes.push(current);
    }
  }
  if (node.attr) {
    current.attr = merge(current.attr, node.attr);
  }
}
function addEdge(graph, edge) {
  if (!graph.edges) {
    graph.edges = [];
  }
  graph.edges.push(edge);
  if (graph.edge) {
    var attr = merge({}, graph.edge);
    edge.attr = merge(attr, edge.attr);
  }
}
function createEdge(graph, from2, to, type, attr) {
  var edge = {
    from: from2,
    to,
    type
  };
  if (graph.edge) {
    edge.attr = merge({}, graph.edge);
  }
  edge.attr = merge(edge.attr || {}, attr);
  if (attr != null) {
    if (attr.hasOwnProperty("arrows") && attr["arrows"] != null) {
      edge["arrows"] = {
        to: {
          enabled: true,
          type: attr.arrows.type
        }
      };
      attr["arrows"] = null;
    }
  }
  return edge;
}
function getToken() {
  tokenType = TOKENTYPE.NULL;
  token = "";
  while (c === " " || c === "	" || c === "\n" || c === "\r") {
    next2();
  }
  do {
    var isComment = false;
    if (c === "#") {
      var i = index - 1;
      while (dot.charAt(i) === " " || dot.charAt(i) === "	") {
        i--;
      }
      if (dot.charAt(i) === "\n" || dot.charAt(i) === "") {
        while (c != "" && c != "\n") {
          next2();
        }
        isComment = true;
      }
    }
    if (c === "/" && nextPreview() === "/") {
      while (c != "" && c != "\n") {
        next2();
      }
      isComment = true;
    }
    if (c === "/" && nextPreview() === "*") {
      while (c != "") {
        if (c === "*" && nextPreview() === "/") {
          next2();
          next2();
          break;
        } else {
          next2();
        }
      }
      isComment = true;
    }
    while (c === " " || c === "	" || c === "\n" || c === "\r") {
      next2();
    }
  } while (isComment);
  if (c === "") {
    tokenType = TOKENTYPE.DELIMITER;
    return;
  }
  var c2 = c + nextPreview();
  if (DELIMITERS[c2]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c2;
    next2();
    next2();
    return;
  }
  if (DELIMITERS[c]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c;
    next2();
    return;
  }
  if (isAlphaNumeric(c) || c === "-") {
    token += c;
    next2();
    while (isAlphaNumeric(c)) {
      token += c;
      next2();
    }
    if (token === "false") {
      token = false;
    } else if (token === "true") {
      token = true;
    } else if (!isNaN(Number(token))) {
      token = Number(token);
    }
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  }
  if (c === '"') {
    next2();
    while (c != "" && (c != '"' || c === '"' && nextPreview() === '"')) {
      if (c === '"') {
        token += c;
        next2();
      } else if (c === "\\" && nextPreview() === "n") {
        token += "\n";
        next2();
      } else {
        token += c;
      }
      next2();
    }
    if (c != '"') {
      throw newSyntaxError('End of string " expected');
    }
    next2();
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  }
  tokenType = TOKENTYPE.UNKNOWN;
  while (c != "") {
    token += c;
    next2();
  }
  throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
}
function parseGraph() {
  var graph = {};
  first();
  getToken();
  if (token === "strict") {
    graph.strict = true;
    getToken();
  }
  if (token === "graph" || token === "digraph") {
    graph.type = token;
    getToken();
  }
  if (tokenType === TOKENTYPE.IDENTIFIER) {
    graph.id = token;
    getToken();
  }
  if (token != "{") {
    throw newSyntaxError("Angle bracket { expected");
  }
  getToken();
  parseStatements(graph);
  if (token != "}") {
    throw newSyntaxError("Angle bracket } expected");
  }
  getToken();
  if (token !== "") {
    throw newSyntaxError("End of file expected");
  }
  getToken();
  delete graph.node;
  delete graph.edge;
  delete graph.graph;
  return graph;
}
function parseStatements(graph) {
  while (token !== "" && token != "}") {
    parseStatement(graph);
    if (token === ";") {
      getToken();
    }
  }
}
function parseStatement(graph) {
  var subgraph = parseSubgraph(graph);
  if (subgraph) {
    parseEdge(graph, subgraph);
    return;
  }
  var attr = parseAttributeStatement(graph);
  if (attr) {
    return;
  }
  if (tokenType != TOKENTYPE.IDENTIFIER) {
    throw newSyntaxError("Identifier expected");
  }
  var id2 = token;
  getToken();
  if (token === "=") {
    getToken();
    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError("Identifier expected");
    }
    graph[id2] = token;
    getToken();
  } else {
    parseNodeStatement(graph, id2);
  }
}
function parseSubgraph(graph) {
  var subgraph = null;
  if (token === "subgraph") {
    subgraph = {};
    subgraph.type = "subgraph";
    getToken();
    if (tokenType === TOKENTYPE.IDENTIFIER) {
      subgraph.id = token;
      getToken();
    }
  }
  if (token === "{") {
    getToken();
    if (!subgraph) {
      subgraph = {};
    }
    subgraph.parent = graph;
    subgraph.node = graph.node;
    subgraph.edge = graph.edge;
    subgraph.graph = graph.graph;
    parseStatements(subgraph);
    if (token != "}") {
      throw newSyntaxError("Angle bracket } expected");
    }
    getToken();
    delete subgraph.node;
    delete subgraph.edge;
    delete subgraph.graph;
    delete subgraph.parent;
    if (!graph.subgraphs) {
      graph.subgraphs = [];
    }
    graph.subgraphs.push(subgraph);
  }
  return subgraph;
}
function parseAttributeStatement(graph) {
  if (token === "node") {
    getToken();
    graph.node = parseAttributeList();
    return "node";
  } else if (token === "edge") {
    getToken();
    graph.edge = parseAttributeList();
    return "edge";
  } else if (token === "graph") {
    getToken();
    graph.graph = parseAttributeList();
    return "graph";
  }
  return null;
}
function parseNodeStatement(graph, id2) {
  var node = {
    id: id2
  };
  var attr = parseAttributeList();
  if (attr) {
    node.attr = attr;
  }
  addNode(graph, node);
  parseEdge(graph, id2);
}
function parseEdge(graph, from2) {
  while (token === "->" || token === "--") {
    var to;
    var type = token;
    getToken();
    var subgraph = parseSubgraph(graph);
    if (subgraph) {
      to = subgraph;
    } else {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Identifier or subgraph expected");
      }
      to = token;
      addNode(graph, {
        id: to
      });
      getToken();
    }
    var attr = parseAttributeList();
    var edge = createEdge(graph, from2, to, type, attr);
    addEdge(graph, edge);
    from2 = to;
  }
}
function parseAttributeList() {
  var i;
  var attr = null;
  var edgeStyles = {
    "dashed": true,
    "solid": false,
    "dotted": [1, 5]
  };
  var arrowTypes = {
    dot: "circle",
    box: "box",
    crow: "crow",
    curve: "curve",
    icurve: "inv_curve",
    normal: "triangle",
    inv: "inv_triangle",
    diamond: "diamond",
    tee: "bar",
    vee: "vee"
  };
  var attr_list = new Array();
  var attr_names = new Array();
  while (token === "[") {
    getToken();
    attr = {};
    while (token !== "" && token != "]") {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute name expected");
      }
      var name = token;
      getToken();
      if (token != "=") {
        throw newSyntaxError("Equal sign = expected");
      }
      getToken();
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute value expected");
      }
      var value = token;
      if (name === "style") {
        value = edgeStyles[value];
      }
      var arrowType;
      if (name === "arrowhead") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          "to": {
            "enabled": true,
            "type": arrowType
          }
        };
      }
      if (name === "arrowtail") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          "from": {
            "enabled": true,
            "type": arrowType
          }
        };
      }
      attr_list.push({
        "attr": attr,
        "name": name,
        "value": value
      });
      attr_names.push(name);
      getToken();
      if (token == ",") {
        getToken();
      }
    }
    if (token != "]") {
      throw newSyntaxError("Bracket ] expected");
    }
    getToken();
  }
  if (includes$4(attr_names).call(attr_names, "dir")) {
    var idx = {};
    idx.arrows = {};
    for (i = 0; i < attr_list.length; i++) {
      if (attr_list[i].name === "arrows") {
        if (attr_list[i].value.to != null) {
          idx.arrows.to = i;
        } else if (attr_list[i].value.from != null) {
          idx.arrows.from = i;
        } else {
          throw newSyntaxError("Invalid value of arrows");
        }
      } else if (attr_list[i].name === "dir") {
        idx.dir = i;
      }
    }
    var dir_type = attr_list[idx.dir].value;
    if (!includes$4(attr_names).call(attr_names, "arrows")) {
      if (dir_type === "both") {
        attr_list.push({
          "attr": attr_list[idx.dir].attr,
          "name": "arrows",
          "value": {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
        attr_list.push({
          "attr": attr_list[idx.dir].attr,
          "name": "arrows",
          "value": {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "forward") {
        attr_list.push({
          "attr": attr_list[idx.dir].attr,
          "name": "arrows",
          "value": {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
      } else if (dir_type === "back") {
        attr_list.push({
          "attr": attr_list[idx.dir].attr,
          "name": "arrows",
          "value": {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "none") {
        attr_list.push({
          "attr": attr_list[idx.dir].attr,
          "name": "arrows",
          "value": ""
        });
        idx.arrows.to = attr_list.length - 1;
      } else {
        throw newSyntaxError('Invalid dir type "' + dir_type + '"');
      }
    }
    var from_type;
    var to_type;
    if (dir_type === "both") {
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          "attr": attr_list[idx.arrows.to].attr,
          "name": attr_list[idx.arrows.to].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
        splice$2(attr_list).call(attr_list, idx.arrows.from, 1);
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "arrow";
        attr_list[idx.arrows.to] = {
          "attr": attr_list[idx.arrows.to].attr,
          "name": attr_list[idx.arrows.to].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          "attr": attr_list[idx.arrows.from].attr,
          "name": attr_list[idx.arrows.from].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
    } else if (dir_type === "back") {
      if (idx.arrows.to && idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          "attr": attr_list[idx.arrows.from].attr,
          "name": attr_list[idx.arrows.from].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.to) {
        to_type = "";
        from_type = "arrow";
        idx.arrows.from = idx.arrows.to;
        attr_list[idx.arrows.from] = {
          "attr": attr_list[idx.arrows.from].attr,
          "name": attr_list[idx.arrows.from].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          "attr": attr_list[idx.arrows.from].attr,
          "name": attr_list[idx.arrows.from].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
      attr_list[idx.arrows.from] = {
        "attr": attr_list[idx.arrows.from].attr,
        "name": attr_list[idx.arrows.from].name,
        "value": {
          from: {
            enabled: true,
            type: attr_list[idx.arrows.from].value.from.type
          }
        }
      };
    } else if (dir_type === "none") {
      var idx_arrow;
      if (idx.arrows.to) {
        idx_arrow = idx.arrows.to;
      } else {
        idx_arrow = idx.arrows.from;
      }
      attr_list[idx_arrow] = {
        "attr": attr_list[idx_arrow].attr,
        "name": attr_list[idx_arrow].name,
        "value": ""
      };
    } else if (dir_type === "forward") {
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          "attr": attr_list[idx.arrows.to].attr,
          "name": attr_list[idx.arrows.to].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          "attr": attr_list[idx.arrows.to].attr,
          "name": attr_list[idx.arrows.to].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = "";
        idx.arrows.to = idx.arrows.from;
        attr_list[idx.arrows.to] = {
          "attr": attr_list[idx.arrows.to].attr,
          "name": attr_list[idx.arrows.to].name,
          "value": {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
      attr_list[idx.arrows.to] = {
        "attr": attr_list[idx.arrows.to].attr,
        "name": attr_list[idx.arrows.to].name,
        "value": {
          to: {
            enabled: true,
            type: attr_list[idx.arrows.to].value.to.type
          }
        }
      };
    } else {
      throw newSyntaxError('Invalid dir type "' + dir_type + '"');
    }
    splice$2(attr_list).call(attr_list, idx.dir, 1);
  }
  var nof_attr_list;
  if (includes$4(attr_names).call(attr_names, "penwidth")) {
    var tmp_attr_list = [];
    nof_attr_list = attr_list.length;
    for (i = 0; i < nof_attr_list; i++) {
      if (attr_list[i].name !== "width") {
        if (attr_list[i].name === "penwidth") {
          attr_list[i].name = "width";
        }
        tmp_attr_list.push(attr_list[i]);
      }
    }
    attr_list = tmp_attr_list;
  }
  nof_attr_list = attr_list.length;
  for (i = 0; i < nof_attr_list; i++) {
    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);
  }
  return attr;
}
function newSyntaxError(message) {
  return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index + ")");
}
function chop(text, maxLength) {
  return text.length <= maxLength ? text : text.substr(0, 27) + "...";
}
function forEach22(array1, array2, fn) {
  if (isArray$5(array1)) {
    forEach$2(array1).call(array1, function(elem1) {
      if (isArray$5(array2)) {
        forEach$2(array2).call(array2, function(elem2) {
          fn(elem1, elem2);
        });
      } else {
        fn(elem1, array2);
      }
    });
  } else {
    if (isArray$5(array2)) {
      forEach$2(array2).call(array2, function(elem2) {
        fn(array1, elem2);
      });
    } else {
      fn(array1, array2);
    }
  }
}
function setProp(object2, path2, value) {
  var names = path2.split(".");
  var prop = names.pop();
  var obj = object2;
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    if (!(name in obj)) {
      obj[name] = {};
    }
    obj = obj[name];
  }
  obj[prop] = value;
  return object2;
}
function convertAttr(attr, mapping) {
  var converted = {};
  for (var prop in attr) {
    if (attr.hasOwnProperty(prop)) {
      var visProp = mapping[prop];
      if (isArray$5(visProp)) {
        forEach$2(visProp).call(visProp, function(visPropI) {
          setProp(converted, visPropI, attr[prop]);
        });
      } else if (typeof visProp === "string") {
        setProp(converted, visProp, attr[prop]);
      } else {
        setProp(converted, prop, attr[prop]);
      }
    }
  }
  return converted;
}
function DOTToGraph(data2) {
  var dotData = parseDOT(data2);
  var graphData = {
    nodes: [],
    edges: [],
    options: {}
  };
  if (dotData.nodes) {
    var _context2;
    forEach$2(_context2 = dotData.nodes).call(_context2, function(dotNode) {
      var graphNode = {
        id: dotNode.id,
        label: String(dotNode.label || dotNode.id)
      };
      merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
      if (graphNode.image) {
        graphNode.shape = "image";
      }
      graphData.nodes.push(graphNode);
    });
  }
  if (dotData.edges) {
    var _context3;
    var convertEdge = function convertEdge2(dotEdge) {
      var graphEdge = {
        from: dotEdge.from,
        to: dotEdge.to
      };
      merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));
      if (graphEdge.arrows == null && dotEdge.type === "->") {
        graphEdge.arrows = "to";
      }
      return graphEdge;
    };
    forEach$2(_context3 = dotData.edges).call(_context3, function(dotEdge) {
      var from2, to;
      if (dotEdge.from instanceof Object) {
        from2 = dotEdge.from.nodes;
      } else {
        from2 = {
          id: dotEdge.from
        };
      }
      if (dotEdge.to instanceof Object) {
        to = dotEdge.to.nodes;
      } else {
        to = {
          id: dotEdge.to
        };
      }
      if (dotEdge.from instanceof Object && dotEdge.from.edges) {
        var _context4;
        forEach$2(_context4 = dotEdge.from.edges).call(_context4, function(subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
      forEach22(from2, to, function(from3, to2) {
        var subEdge = createEdge(graphData, from3.id, to2.id, dotEdge.type, dotEdge.attr);
        var graphEdge = convertEdge(subEdge);
        graphData.edges.push(graphEdge);
      });
      if (dotEdge.to instanceof Object && dotEdge.to.edges) {
        var _context5;
        forEach$2(_context5 = dotEdge.to.edges).call(_context5, function(subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
    });
  }
  if (dotData.attr) {
    graphData.options = dotData.attr;
  }
  return graphData;
}
function parseGephi(gephiJSON, optionsObj) {
  var _context;
  var options2 = {
    edges: {
      inheritColor: false
    },
    nodes: {
      fixed: false,
      parseColor: false
    }
  };
  if (optionsObj != null) {
    if (optionsObj.fixed != null) {
      options2.nodes.fixed = optionsObj.fixed;
    }
    if (optionsObj.parseColor != null) {
      options2.nodes.parseColor = optionsObj.parseColor;
    }
    if (optionsObj.inheritColor != null) {
      options2.edges.inheritColor = optionsObj.inheritColor;
    }
  }
  var gEdges = gephiJSON.edges;
  var vEdges = map$2(gEdges).call(gEdges, function(gEdge) {
    var vEdge = {
      from: gEdge.source,
      id: gEdge.id,
      to: gEdge.target
    };
    if (gEdge.attributes != null) {
      vEdge.attributes = gEdge.attributes;
    }
    if (gEdge.label != null) {
      vEdge.label = gEdge.label;
    }
    if (gEdge.attributes != null && gEdge.attributes.title != null) {
      vEdge.title = gEdge.attributes.title;
    }
    if (gEdge.type === "Directed") {
      vEdge.arrows = "to";
    }
    if (gEdge.color && options2.edges.inheritColor === false) {
      vEdge.color = gEdge.color;
    }
    return vEdge;
  });
  var vNodes = map$2(_context = gephiJSON.nodes).call(_context, function(gNode) {
    var vNode = {
      id: gNode.id,
      fixed: options2.nodes.fixed && gNode.x != null && gNode.y != null
    };
    if (gNode.attributes != null) {
      vNode.attributes = gNode.attributes;
    }
    if (gNode.label != null) {
      vNode.label = gNode.label;
    }
    if (gNode.size != null) {
      vNode.size = gNode.size;
    }
    if (gNode.attributes != null && gNode.attributes.title != null) {
      vNode.title = gNode.attributes.title;
    }
    if (gNode.title != null) {
      vNode.title = gNode.title;
    }
    if (gNode.x != null) {
      vNode.x = gNode.x;
    }
    if (gNode.y != null) {
      vNode.y = gNode.y;
    }
    if (gNode.color != null) {
      if (options2.nodes.parseColor === true) {
        vNode.color = gNode.color;
      } else {
        vNode.color = {
          background: gNode.color,
          border: gNode.color,
          highlight: {
            background: gNode.color,
            border: gNode.color
          },
          hover: {
            background: gNode.color,
            border: gNode.color
          }
        };
      }
    }
    return vNode;
  });
  return {
    nodes: vNodes,
    edges: vEdges
  };
}
function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function prefixed(obj, property) {
  var prefix;
  var prop;
  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;
  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop = prefix ? prefix + camelProp : property;
    if (prop in obj) {
      return prop;
    }
    i++;
  }
  return void 0;
}
function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }
  var touchMap = {};
  var cssSupports = win.CSS && win.CSS.supports;
  ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
    return touchMap[val] = cssSupports ? win.CSS.supports("touch-action", val) : true;
  });
  return touchMap;
}
function each(obj, iterator2, context) {
  var i;
  if (!obj) {
    return;
  }
  if (obj.forEach) {
    obj.forEach(iterator2, context);
  } else if (obj.length !== void 0) {
    i = 0;
    while (i < obj.length) {
      iterator2.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator2.call(context, obj[i], i, obj);
    }
  }
}
function boolOrFn(val, args) {
  if (typeof val === TYPE_FUNCTION) {
    return val.apply(args ? args[0] || void 0 : void 0, args);
  }
  return val;
}
function inStr(str, find) {
  return str.indexOf(find) > -1;
}
function cleanTouchActions(actions) {
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }
  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  }
  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  }
  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }
  return TOUCH_ACTION_AUTO;
}
function hasParent(node, parent) {
  while (node) {
    if (node === parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
function getCenter(pointers) {
  var pointersLength = pointers.length;
  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }
  var x = 0;
  var y = 0;
  var i = 0;
  while (i < pointersLength) {
    x += pointers[i].clientX;
    y += pointers[i].clientY;
    i++;
  }
  return {
    x: round(x / pointersLength),
    y: round(y / pointersLength)
  };
}
function simpleCloneInputData(input) {
  var pointers = [];
  var i = 0;
  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }
  return {
    timeStamp: now$3(),
    pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}
function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x * x + y * y);
}
function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.atan2(y, x) * 180 / Math.PI;
}
function getDirection(x, y) {
  if (x === y) {
    return DIRECTION_NONE;
  }
  if (abs(x) >= abs(y)) {
    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }
  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}
function computeDeltaXY(session, input) {
  var center = input.center;
  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};
  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }
  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}
function getVelocity(deltaTime, x, y) {
  return {
    x: x / deltaTime || 0,
    y: y / deltaTime || 0
  };
}
function getScale(start, end) {
  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}
function getRotation(start, end) {
  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}
function computeIntervalInputData(session, input) {
  var last = session.lastInterval || input;
  var deltaTime = input.timeStamp - last.timeStamp;
  var velocity;
  var velocityX;
  var velocityY;
  var direction;
  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {
    var deltaX = input.deltaX - last.deltaX;
    var deltaY = input.deltaY - last.deltaY;
    var v = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v.x;
    velocityY = v.y;
    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }
  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}
function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length;
  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  }
  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }
  var firstInput = session.firstInput, firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);
  input.timeStamp = now$3();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input);
  var target = manager.element;
  var srcEvent = input.srcEvent;
  var srcEventTarget;
  if (srcEvent.composedPath) {
    srcEventTarget = srcEvent.composedPath()[0];
  } else if (srcEvent.path) {
    srcEventTarget = srcEvent.path[0];
  } else {
    srcEventTarget = srcEvent.target;
  }
  if (hasParent(srcEventTarget, target)) {
    target = srcEventTarget;
  }
  input.target = target;
}
function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;
  if (isFirst) {
    manager.session = {};
  }
  input.eventType = eventType;
  computeInputData(manager, input);
  manager.emit("hammer.input", input);
  manager.recognize(input);
  manager.session.prevInput = input;
}
function splitStr(str) {
  return str.trim().split(/\s+/g);
}
function addEventListeners(target, types, handler) {
  each(splitStr(types), function(type) {
    target.addEventListener(type, handler, false);
  });
}
function removeEventListeners(target, types, handler) {
  each(splitStr(types), function(type) {
    target.removeEventListener(type, handler, false);
  });
}
function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}
function inArray(src, find, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find);
  } else {
    var i = 0;
    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
        return i;
      }
      i++;
    }
    return -1;
  }
}
function toArray(obj) {
  return Array.prototype.slice.call(obj, 0);
}
function uniqueArray(src, key, sort3) {
  var results = [];
  var values3 = [];
  var i = 0;
  while (i < src.length) {
    var val = key ? src[i][key] : src[i];
    if (inArray(values3, val) < 0) {
      results.push(src[i]);
    }
    values3[i] = val;
    i++;
  }
  if (sort3) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function(a, b) {
        return a[key] > b[key];
      });
    }
  }
  return results;
}
function getTouches(ev, type) {
  var allTouches = toArray(ev.touches);
  var targetIds = this.targetIds;
  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }
  var i;
  var targetTouches;
  var changedTouches = toArray(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target;
  targetTouches = allTouches.filter(function(touch) {
    return hasParent(touch.target, target);
  });
  if (type === INPUT_START) {
    i = 0;
    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  }
  i = 0;
  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    }
    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }
    i++;
  }
  if (!changedTargetTouches.length) {
    return;
  }
  return [
    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
    changedTargetTouches
  ];
}
function setLastTouch(eventData) {
  var _eventData$changedPoi = eventData.changedPointers, touch = _eventData$changedPoi[0];
  if (touch.identifier === this.primaryTouch) {
    var lastTouch = {
      x: touch.clientX,
      y: touch.clientY
    };
    var lts = this.lastTouches;
    this.lastTouches.push(lastTouch);
    var removeLastTouch = function removeLastTouch2() {
      var i = lts.indexOf(lastTouch);
      if (i > -1) {
        lts.splice(i, 1);
      }
    };
    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
  }
}
function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}
function isSyntheticEvent(eventData) {
  var x = eventData.srcEvent.clientX;
  var y = eventData.srcEvent.clientY;
  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x - t.x);
    var dy = Math.abs(y - t.y);
    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }
  return false;
}
function createInputInstance(manager) {
  var Type;
  var inputClass = manager.options.inputClass;
  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }
  return new Type(manager, inputHandler);
}
function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }
  return false;
}
function uniqueId() {
  return _uniqueId++;
}
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;
  if (manager) {
    return manager.get(otherRecognizer);
  }
  return otherRecognizer;
}
function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return "cancel";
  } else if (state & STATE_ENDED) {
    return "end";
  } else if (state & STATE_CHANGED) {
    return "move";
  } else if (state & STATE_BEGAN) {
    return "start";
  }
  return "";
}
function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return "down";
  } else if (direction === DIRECTION_UP) {
    return "up";
  } else if (direction === DIRECTION_LEFT) {
    return "left";
  } else if (direction === DIRECTION_RIGHT) {
    return "right";
  }
  return "";
}
function toggleCssProps(manager, add) {
  var element = manager.element;
  if (!element.style) {
    return;
  }
  var prop;
  each(manager.options.cssProps, function(value, name) {
    prop = prefixed(element.style, name);
    if (add) {
      manager.oldCssProps[prop] = element.style[prop];
      element.style[prop] = value;
    } else {
      element.style[prop] = manager.oldCssProps[prop] || "";
    }
  });
  if (!add) {
    manager.oldCssProps = {};
  }
}
function triggerDomEvent(event, data2) {
  var gestureEvent = document.createEvent("Event");
  gestureEvent.initEvent(event, true, true);
  gestureEvent.gesture = data2;
  data2.target.dispatchEvent(gestureEvent);
}
function normalizeSingleTouches(ev, type) {
  var all = toArray(ev.touches);
  var changed = toArray(ev.changedTouches);
  if (type & (INPUT_END | INPUT_CANCEL)) {
    all = uniqueArray(all.concat(changed), "identifier", true);
  }
  return [all, changed];
}
function deprecate(method, name, message) {
  var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
  return function() {
    var e = new Error("get-stack-trace");
    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
    var log = window.console && (window.console.warn || window.console.log);
    if (log) {
      log.call(window.console, deprecationMessage, stack);
    }
    return method.apply(this, arguments);
  };
}
function inherit(child, base, properties) {
  var baseP = base.prototype;
  var childP;
  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;
  if (properties) {
    assign$1$1(childP, properties);
  }
}
function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}
function Activator(container) {
  var _context, _this = this, _context2;
  this.active = false;
  this.dom = {
    container
  };
  this.dom.overlay = document.createElement("div");
  this.dom.overlay.className = "vis-overlay";
  this.dom.container.appendChild(this.dom.overlay);
  this.hammer = hammer(this.dom.overlay);
  this.hammer.on("tap", bind$2(_context = this._onTapOverlay).call(_context, this));
  var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];
  forEach$2(events).call(events, function(event) {
    _this.hammer.on(event, function(event2) {
      event2.srcEvent.stopPropagation();
    });
  });
  if (document && document.body) {
    this.onClick = function(event) {
      if (!_hasParent(event.target, container)) {
        _this.deactivate();
      }
    };
    document.body.addEventListener("click", this.onClick);
  }
  if (this.keycharm !== void 0) {
    this.keycharm.destroy();
  }
  this.keycharm = keycharm();
  this.escListener = bind$2(_context2 = this.deactivate).call(_context2, this);
}
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}
function normalizeLanguageCode(locales2, rawCode) {
  try {
    var _rawCode$split = rawCode.split(/[-_ \/]/, 2), _rawCode$split2 = slicedToArray(_rawCode$split, 2), rawLanguage = _rawCode$split2[0], rawCountry = _rawCode$split2[1];
    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;
    var country = rawCountry != null ? rawCountry.toUpperCase() : null;
    if (language && country) {
      var code = language + "-" + country;
      if (Object.prototype.hasOwnProperty.call(locales2, code)) {
        return code;
      } else {
        var _context;
        console.warn(concat$2(_context = "Unknown variant ".concat(country, " of language ")).call(_context, language, "."));
      }
    }
    if (language) {
      var _code = language;
      if (Object.prototype.hasOwnProperty.call(locales2, _code)) {
        return _code;
      } else {
        console.warn("Unknown language ".concat(language));
      }
    }
    console.warn("Unknown locale ".concat(rawCode, ", falling back to English."));
    return "en";
  } catch (error) {
    console.error(error);
    console.warn("Unexpected error while normalizing locale ".concat(rawCode, ", falling back to English."));
    return "en";
  }
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    defineProperty$6(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = create$4(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf$3(subClass, superClass);
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return assertThisInitialized(self2);
}
function rng() {
  if (!getRandomValues) {
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  }
  return getRandomValues(rnds8);
}
function bytesToUuid(buf, offset_) {
  var offset = offset_ || 0;
  return (byteToHex[buf[offset + 0]] + byteToHex[buf[offset + 1]] + byteToHex[buf[offset + 2]] + byteToHex[buf[offset + 3]] + "-" + byteToHex[buf[offset + 4]] + byteToHex[buf[offset + 5]] + "-" + byteToHex[buf[offset + 6]] + byteToHex[buf[offset + 7]] + "-" + byteToHex[buf[offset + 8]] + byteToHex[buf[offset + 9]] + "-" + byteToHex[buf[offset + 10]] + byteToHex[buf[offset + 11]] + byteToHex[buf[offset + 12]] + byteToHex[buf[offset + 13]] + byteToHex[buf[offset + 14]] + byteToHex[buf[offset + 15]]).toLowerCase();
}
function v4(options2, buf, offset) {
  options2 = options2 || {};
  var rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return bytesToUuid(rnds);
}
function ownKeys$4(object2, enumerableOnly) {
  var keys4 = keys$3(object2);
  if (getOwnPropertySymbols$2) {
    var symbols = getOwnPropertySymbols$2(object2);
    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function(sym) {
      return getOwnPropertyDescriptor$3(object2, sym).enumerable;
    });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      var _context28;
      forEach$2(_context28 = ownKeys$4(Object(source), true)).call(_context28, function(key) {
        defineProperty$7(target, key, source[key]);
      });
    } else if (getOwnPropertyDescriptors$2) {
      defineProperties$1(target, getOwnPropertyDescriptors$2(source));
    } else {
      var _context29;
      forEach$2(_context29 = ownKeys$4(Object(source))).call(_context29, function(key) {
        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it2;
  if (typeof symbol$4 === "undefined" || getIteratorMethod$1(o) == null) {
    if (isArray$5(o) || (it2 = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it2) o = it2;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it2 = getIterator$1(o);
  }, n: function n() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null) it2.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$2(o, minLen) {
  var _context19;
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n = slice$5(_context19 = Object.prototype.toString.call(o)).call(_context19, 8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from_1$2(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function createNewDataPipeFrom(from2) {
  return new DataPipeUnderConstruction(from2);
}
function isMoment(value) {
  return moment.isMoment(value);
}
function convert(object2, type) {
  var match2;
  if (object2 === void 0) {
    return void 0;
  }
  if (object2 === null) {
    return null;
  }
  if (!type) {
    return object2;
  }
  if (!(typeof type === "string") && !(type instanceof String)) {
    throw new Error("Type must be a string");
  }
  switch (type) {
    case "boolean":
    case "Boolean":
      return Boolean(object2);
    case "number":
    case "Number":
      if (isString(object2) && !isNaN(Date.parse(object2))) {
        return moment(object2).valueOf();
      } else {
        return Number(object2.valueOf());
      }
    case "string":
    case "String":
      return String(object2);
    case "Date":
      if (isNumber(object2)) {
        return new Date(object2);
      }
      if (object2 instanceof Date) {
        return new Date(object2.valueOf());
      } else if (isMoment(object2)) {
        return new Date(object2.valueOf());
      }
      if (isString(object2)) {
        match2 = ASPDateRegex.exec(object2);
        if (match2) {
          return new Date(Number(match2[1]));
        } else {
          return moment(new Date(object2)).toDate();
        }
      } else {
        throw new Error("Cannot convert object of type " + getType(object2) + " to type Date");
      }
    case "Moment":
      if (isNumber(object2)) {
        return moment(object2);
      }
      if (object2 instanceof Date) {
        return moment(object2.valueOf());
      } else if (isMoment(object2)) {
        return moment(object2);
      }
      if (isString(object2)) {
        match2 = ASPDateRegex.exec(object2);
        if (match2) {
          return moment(Number(match2[1]));
        } else {
          return moment(object2);
        }
      } else {
        throw new Error("Cannot convert object of type " + getType(object2) + " to type Date");
      }
    case "ISODate":
      if (isNumber(object2)) {
        return new Date(object2);
      } else if (object2 instanceof Date) {
        return object2.toISOString();
      } else if (isMoment(object2)) {
        return object2.toDate().toISOString();
      } else if (isString(object2)) {
        match2 = ASPDateRegex.exec(object2);
        if (match2) {
          return new Date(Number(match2[1])).toISOString();
        } else {
          return moment(object2).format();
        }
      } else {
        throw new Error("Cannot convert object of type " + getType(object2) + " to type ISODate");
      }
    case "ASPDate":
      if (isNumber(object2)) {
        return "/Date(" + object2 + ")/";
      } else if (object2 instanceof Date || isMoment(object2)) {
        return "/Date(" + object2.valueOf() + ")/";
      } else if (isString(object2)) {
        match2 = ASPDateRegex.exec(object2);
        var value;
        if (match2) {
          value = new Date(Number(match2[1])).valueOf();
        } else {
          value = new Date(object2).valueOf();
        }
        return "/Date(" + value + ")/";
      } else {
        throw new Error("Cannot convert object of type " + getType(object2) + " to type ASPDate");
      }
    default:
      var never = type;
      throw new Error("Unknown type ".concat(never));
  }
}
function isId(value) {
  return typeof value === "string" || typeof value === "number";
}
function choosify(subOption, pile) {
  var allowed = ["node", "edge", "label"];
  var value = true;
  var chosen = topMost(pile, "chosen");
  if (typeof chosen === "boolean") {
    value = chosen;
  } else if (_typeof_1(chosen) === "object") {
    if (indexOf$3(allowed).call(allowed, subOption) === -1) {
      throw new Error("choosify: subOption '" + subOption + "' should be one of '" + allowed.join("', '") + "'");
    }
    var chosenEdge = topMost(pile, ["chosen", subOption]);
    if (typeof chosenEdge === "boolean" || typeof chosenEdge === "function") {
      value = chosenEdge;
    }
  }
  return value;
}
function pointInRect(rect, point, rotationPoint) {
  if (rect.width <= 0 || rect.height <= 0) {
    return false;
  }
  if (rotationPoint !== void 0) {
    var tmp = {
      x: point.x - rotationPoint.x,
      y: point.y - rotationPoint.y
    };
    if (rotationPoint.angle !== 0) {
      var angle = -rotationPoint.angle;
      var tmp2 = {
        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
      };
      point = tmp2;
    } else {
      point = tmp;
    }
  }
  var right = rect.x + rect.width;
  var bottom = rect.y + rect.width;
  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
}
function isValidLabel(text) {
  return typeof text === "string" && text !== "";
}
function getSelfRefCoordinates(ctx, angle, radius, node) {
  var x = node.x;
  var y = node.y;
  if (typeof node.distanceToBorder === "function") {
    var toBorderDist = node.distanceToBorder(ctx, angle);
    var yFromNodeCenter = Math.sin(angle) * toBorderDist;
    var xFromNodeCenter = Math.cos(angle) * toBorderDist;
    if (xFromNodeCenter === toBorderDist) {
      x += toBorderDist;
      y = node.y;
    } else if (yFromNodeCenter === toBorderDist) {
      x = node.x;
      y -= toBorderDist;
    } else {
      x += xFromNodeCenter;
      y -= yFromNodeCenter;
    }
  } else if (node.shape.width > node.shape.height) {
    x = node.x + node.shape.width * 0.5;
    y = node.y - radius;
  } else {
    x = node.x + radius;
    y = node.y - node.shape.height * 0.5;
  }
  return {
    x,
    y
  };
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function ownKeys$5(object2, enumerableOnly) {
  var keys4 = keys$3(object2);
  if (getOwnPropertySymbols$2) {
    var symbols = getOwnPropertySymbols$2(object2);
    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function(sym) {
      return getOwnPropertyDescriptor$3(object2, sym).enumerable;
    });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      var _context;
      forEach$2(_context = ownKeys$5(Object(source), true)).call(_context, function(key) {
        defineProperty$7(target, key, source[key]);
      });
    } else if (getOwnPropertyDescriptors$2) {
      defineProperties$1(target, getOwnPropertyDescriptors$2(source));
    } else {
      var _context2;
      forEach$2(_context2 = ownKeys$5(Object(source))).call(_context2, function(key) {
        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));
      });
    }
  }
  return target;
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function ownKeys$6(object2, enumerableOnly) {
  var keys4 = keys$3(object2);
  if (getOwnPropertySymbols$2) {
    var symbols = getOwnPropertySymbols$2(object2);
    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function(sym) {
      return getOwnPropertyDescriptor$3(object2, sym).enumerable;
    });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      var _context5;
      forEach$2(_context5 = ownKeys$6(Object(source), true)).call(_context5, function(key) {
        defineProperty$7(target, key, source[key]);
      });
    } else if (getOwnPropertyDescriptors$2) {
      defineProperties$1(target, getOwnPropertyDescriptors$2(source));
    } else {
      var _context6;
      forEach$2(_context6 = ownKeys$6(Object(source))).call(_context6, function(key) {
        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));
      });
    }
  }
  return target;
}
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it2;
  if (typeof symbol$4 === "undefined" || getIteratorMethod$1(o) == null) {
    if (isArray$5(o) || (it2 = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it2) o = it2;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it2 = getIterator$1(o);
  }, n: function n() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null) it2.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$3(o, minLen) {
  var _context4;
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n = slice$5(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from_1$2(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function get$1(target, propertyKey) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, "value") ? descriptor.value : descriptor.get === void 0 ? void 0 : descriptor.get.call(receiver);
  if (isObject(prototype = objectGetPrototypeOf(target))) return get$1(prototype, propertyKey, receiver);
}
function _superPropBase(object2, property) {
  while (!Object.prototype.hasOwnProperty.call(object2, property)) {
    object2 = getPrototypeOf$5(object2);
    if (object2 === null) break;
  }
  return object2;
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function ownKeys$7(object2, enumerableOnly) {
  var keys4 = keys$3(object2);
  if (getOwnPropertySymbols$2) {
    var symbols = getOwnPropertySymbols$2(object2);
    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function(sym) {
      return getOwnPropertyDescriptor$3(object2, sym).enumerable;
    });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      var _context2;
      forEach$2(_context2 = ownKeys$7(Object(source), true)).call(_context2, function(key) {
        defineProperty$7(target, key, source[key]);
      });
    } else if (getOwnPropertyDescriptors$2) {
      defineProperties$1(target, getOwnPropertyDescriptors$2(source));
    } else {
      var _context3;
      forEach$2(_context3 = ownKeys$7(Object(source))).call(_context3, function(key) {
        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));
      });
    }
  }
  return target;
}
function ownKeys$8(object2, enumerableOnly) {
  var keys4 = keys$3(object2);
  if (getOwnPropertySymbols$2) {
    var symbols = getOwnPropertySymbols$2(object2);
    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function(sym) {
      return getOwnPropertyDescriptor$3(object2, sym).enumerable;
    });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      var _context;
      forEach$2(_context = ownKeys$8(Object(source), true)).call(_context, function(key) {
        defineProperty$7(target, key, source[key]);
      });
    } else if (getOwnPropertyDescriptors$2) {
      defineProperties$1(target, getOwnPropertyDescriptors$2(source));
    } else {
      var _context2;
      forEach$2(_context2 = ownKeys$8(Object(source))).call(_context2, function(key) {
        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));
      });
    }
  }
  return target;
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _initRequestAnimationFrame() {
  var func;
  if (window !== void 0) {
    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }
  if (func === void 0) {
    window.requestAnimationFrame = function(callback) {
      callback();
    };
  } else {
    window.requestAnimationFrame = func;
  }
}
function onTouch(hammer2, callback) {
  callback.inputHandler = function(event) {
    if (event.isFirst) {
      callback(event);
    }
  };
  hammer2.on("hammer.input", callback.inputHandler);
}
function onRelease(hammer2, callback) {
  callback.inputHandler = function(event) {
    if (event.isFinal) {
      callback(event);
    }
  };
  return hammer2.on("hammer.input", callback.inputHandler);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf$5(this).constructor;
      result = construct$3(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !construct$3) return false;
  if (construct$3.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(construct$3(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it2;
  if (typeof symbol$4 === "undefined" || getIteratorMethod$1(o) == null) {
    if (isArray$5(o) || (it2 = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it2) o = it2;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it2 = getIterator$1(o);
  }, n: function n() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null) it2.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$4(o, minLen) {
  var _context8;
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n = slice$5(_context8 = Object.prototype.toString.call(o)).call(_context8, 8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from_1$2(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function fillLevelsByDirectionCyclic(nodes, levels) {
  var edges = new set$3();
  forEach$2(nodes).call(nodes, function(node) {
    var _context;
    forEach$2(_context = node.edges).call(_context, function(edge) {
      if (edge.connected) {
        edges.add(edge);
      }
    });
  });
  forEach$2(edges).call(edges, function(edge) {
    var fromId = edge.from.id;
    var toId = edge.to.id;
    if (levels[fromId] == null) {
      levels[fromId] = 0;
    }
    if (levels[toId] == null || levels[fromId] >= levels[toId]) {
      levels[toId] = levels[fromId] + 1;
    }
  });
  return levels;
}
function fillLevelsByDirectionLeaves(nodes) {
  var levels = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : create$2(null);
  return fillLevelsByDirection(
    // Pick only leaves (nodes without children).
    function(node) {
      var _context2, _context3;
      return every$2(
        _context2 = filter$2(
          _context3 = node.edges
          // Take only visible nodes into account.
        ).call(_context3, function(edge) {
          return nodes.has(edge.toId);
        })
        // Check that all edges lead to this node (leaf).
      ).call(_context2, function(edge) {
        return edge.to === node;
      });
    },
    // Use the lowest level.
    function(newLevel, oldLevel) {
      return oldLevel > newLevel;
    },
    // Go against the direction of the edges.
    "from",
    nodes,
    levels
  );
}
function fillLevelsByDirectionRoots(nodes) {
  var levels = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : create$2(null);
  return fillLevelsByDirection(
    // Pick only roots (nodes without parents).
    function(node) {
      var _context4, _context5;
      return every$2(
        _context4 = filter$2(
          _context5 = node.edges
          // Take only visible nodes into account.
        ).call(_context5, function(edge) {
          return nodes.has(edge.toId);
        })
        // Check that all edges lead from this node (root).
      ).call(_context4, function(edge) {
        return edge.from === node;
      });
    },
    // Use the highest level.
    function(newLevel, oldLevel) {
      return oldLevel < newLevel;
    },
    // Go in the direction of the edges.
    "to",
    nodes,
    levels
  );
}
function fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes, levels) {
  var limit = nodes.size;
  var edgeIdProp = direction + "Id";
  var newLevelDiff = direction === "to" ? 1 : -1;
  var _iterator = _createForOfIteratorHelper$3(nodes), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = slicedToArray(_step.value, 2), entryNodeId = _step$value[0], entryNode = _step$value[1];
      if (
        // Skip if the node is not visible.
        !nodes.has(entryNodeId) || // Skip if the node is not an entry node.
        !isEntryNode(entryNode)
      ) {
        return "continue";
      }
      levels[entryNodeId] = 0;
      var stack = [entryNode];
      var done = 0;
      var node = void 0;
      var _loop22 = function _loop23() {
        var _context6, _context7;
        if (!nodes.has(entryNodeId)) {
          return "continue";
        }
        var newLevel = levels[node.id] + newLevelDiff;
        forEach$2(_context6 = filter$2(_context7 = node.edges).call(_context7, function(edge) {
          return (
            // Ignore disconnected edges.
            edge.connected && // Ignore circular edges.
            edge.to !== edge.from && // Ignore edges leading to the node that's currently being processed.
            edge[direction] !== node && // Ignore edges connecting to an invisible node.
            nodes.has(edge.toId) && // Ignore edges connecting from an invisible node.
            nodes.has(edge.fromId)
          );
        })).call(_context6, function(edge) {
          var targetNodeId = edge[edgeIdProp];
          var oldLevel = levels[targetNodeId];
          if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {
            levels[targetNodeId] = newLevel;
            stack.push(edge[direction]);
          }
        });
        if (done > limit) {
          return {
            v: {
              v: fillLevelsByDirectionCyclic(nodes, levels)
            }
          };
        } else {
          ++done;
        }
      };
      while (node = stack.pop()) {
        var _ret2 = _loop22();
        switch (_ret2) {
          case "continue":
            continue;
          default:
            if (_typeof_1(_ret2) === "object") return _ret2.v;
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      switch (_ret) {
        case "continue":
          continue;
        default:
          if (_typeof_1(_ret) === "object") return _ret.v;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return levels;
}
function Network(container, data2, options2) {
  var _context, _context2, _context3, _context4, _this = this;
  if (!(this instanceof Network)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.options = {};
  this.defaultOptions = {
    locale: "en",
    locales,
    clickToUse: false
  };
  assign$2(this.options, this.defaultOptions);
  this.body = {
    container,
    // See comment above for following fields
    nodes: {},
    nodeIndices: [],
    edges: {},
    edgeIndices: [],
    emitter: {
      on: bind$2(_context = this.on).call(_context, this),
      off: bind$2(_context2 = this.off).call(_context2, this),
      emit: bind$2(_context3 = this.emit).call(_context3, this),
      once: bind$2(_context4 = this.once).call(_context4, this)
    },
    eventListeners: {
      onTap: function onTap() {
      },
      onTouch: function onTouch2() {
      },
      onDoubleTap: function onDoubleTap() {
      },
      onHold: function onHold() {
      },
      onDragStart: function onDragStart() {
      },
      onDrag: function onDrag() {
      },
      onDragEnd: function onDragEnd() {
      },
      onMouseWheel: function onMouseWheel() {
      },
      onPinch: function onPinch() {
      },
      onMouseMove: function onMouseMove() {
      },
      onRelease: function onRelease2() {
      },
      onContext: function onContext() {
      }
    },
    data: {
      nodes: null,
      // A DataSet or DataView
      edges: null
      // A DataSet or DataView
    },
    functions: {
      createNode: function createNode() {
      },
      createEdge: function createEdge2() {
      },
      getPointer: function getPointer() {
      }
    },
    modules: {},
    view: {
      scale: 1,
      translation: {
        x: 0,
        y: 0
      }
    },
    selectionBox: {
      show: false,
      position: {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        }
      }
    }
  };
  this.bindEventListeners();
  this.images = new Images(function() {
    return _this.body.emitter.emit("_requestRedraw");
  });
  this.groups = new Groups();
  this.canvas = new Canvas(this.body);
  this.selectionHandler = new SelectionHandler(this.body, this.canvas);
  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler);
  this.view = new View(this.body, this.canvas);
  this.renderer = new CanvasRenderer(this.body, this.canvas);
  this.physics = new PhysicsEngine(this.body);
  this.layoutEngine = new LayoutEngine(this.body);
  this.clustering = new ClusterEngine(this.body);
  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler);
  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine);
  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups);
  this.body.modules["kamadaKawai"] = new KamadaKawai(this.body, 150, 0.05);
  this.body.modules["clustering"] = this.clustering;
  this.canvas._create();
  this.setOptions(options2);
  this.setData(data2);
}
var commonjsGlobal, check, global_1, fails, descriptors, nativePropertyIsEnumerable, getOwnPropertyDescriptor, NASHORN_BUG, f, objectPropertyIsEnumerable, createPropertyDescriptor, toString, classofRaw, split, indexedObject, requireObjectCoercible, toIndexedObject, isObject, toPrimitive, hasOwnProperty, has, document$1, EXISTS, documentCreateElement, ie8DomDefine, nativeGetOwnPropertyDescriptor, f$1, objectGetOwnPropertyDescriptor, replacement, isForced, normalize, data, NATIVE, POLYFILL, isForced_1, path, aFunction, functionBindContext, anObject, nativeDefineProperty, f$2, objectDefineProperty, createNonEnumerableProperty, getOwnPropertyDescriptor$1, wrapConstructor, _export, slice, factories, construct, functionBind, entryVirtual, bind2, FunctionPrototype, bind_1, bind$1, bind$2, ceil, floor, toInteger, min, toLength, max, min$1, toAbsoluteIndex, createMethod, arrayIncludes, hiddenKeys, indexOf, objectKeysInternal, enumBugKeys, objectKeys, f$3, objectGetOwnPropertySymbols, toObject, nativeAssign, defineProperty2, objectAssign, assign2, assign$1, assign$2, shapeMap, componentEmitter, defineProperty_1, defineProperty$1, defineProperty$2, objectDefineProperties, defineProperties_1, defineProperties2, defineProperties$1, aFunction$1, getBuiltIn, hiddenKeys$1, f$4, objectGetOwnPropertyNames, ownKeys, createProperty, getOwnPropertyDescriptors2, getOwnPropertyDescriptors$1, getOwnPropertyDescriptors$2, nativeGetOwnPropertyDescriptor$1, FAILS_ON_PRIMITIVES, FORCED, getOwnPropertyDescriptor_1, getOwnPropertyDescriptor$2, getOwnPropertyDescriptor$3, nativeSymbol, useSymbolAsUid, isArray, html, setGlobal, SHARED, store, sharedStore, shared, id, postfix, uid, keys2, sharedKey, GT, LT, PROTOTYPE, SCRIPT, IE_PROTO, EmptyConstructor, scriptTag, NullProtoObjectViaActiveX, NullProtoObjectViaIFrame, activeXDocument, NullProtoObject, objectCreate, nativeGetOwnPropertyNames, toString$1, windowNames, getWindowNames, f$5, objectGetOwnPropertyNamesExternal, redefine, WellKnownSymbolsStore, Symbol$1, createWellKnownSymbol, wellKnownSymbol, f$6, wellKnownSymbolWrapped, defineProperty$3, defineWellKnownSymbol, TO_STRING_TAG, test, toStringTagSupport, TO_STRING_TAG$1, CORRECT_ARGUMENTS, tryGet, classof, objectToString, defineProperty$4, TO_STRING_TAG$2, setToStringTag, functionToString, inspectSource, WeakMap, nativeWeakMap, WeakMap$1, set, get, has$1, enforce, getterFor, store$1, wmget, wmhas, wmset, STATE, internalState, SPECIES, arraySpeciesCreate, push, createMethod$1, arrayIteration, $forEach, HIDDEN, SYMBOL, PROTOTYPE$1, TO_PRIMITIVE, setInternalState, getInternalState, ObjectPrototype, $Symbol, $stringify, nativeGetOwnPropertyDescriptor$2, nativeDefineProperty$1, nativeGetOwnPropertyNames$1, nativePropertyIsEnumerable$1, AllSymbols, ObjectPrototypeSymbols, StringToSymbolRegistry, SymbolToStringRegistry, WellKnownSymbolsStore$1, QObject, USE_SETTER, setSymbolDescriptor, wrap, isSymbol, $defineProperty, $defineProperties, $create, $propertyIsEnumerable, $getOwnPropertyDescriptor, $getOwnPropertyNames, $getOwnPropertySymbols, FORCED_JSON_STRINGIFY, getOwnPropertySymbols3, getOwnPropertySymbols$1, getOwnPropertySymbols$2, iterators, correctPrototypeGetter, IE_PROTO$1, ObjectPrototype$1, objectGetPrototypeOf, ITERATOR, BUGGY_SAFARI_ITERATORS, IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator, iteratorsCore, IteratorPrototype$1, returnThis, createIteratorConstructor, aPossiblePrototype, objectSetPrototypeOf, IteratorPrototype$2, BUGGY_SAFARI_ITERATORS$1, ITERATOR$1, KEYS, VALUES, ENTRIES, returnThis$1, defineIterator, ARRAY_ITERATOR, setInternalState$1, getInternalState$1, es_array_iterator, domIterables, TO_STRING_TAG$3, Collection, CollectionPrototype, COLLECTION_NAME, createMethod$2, stringMultibyte, charAt, STRING_ITERATOR, setInternalState$2, getInternalState$2, ITERATOR$2, getIteratorMethod, getIterator, getIterator_1, getIterator$1, getIteratorMethod_1, getIteratorMethod$1, callWithSafeIterationClosing, ITERATOR$3, ArrayPrototype, isArrayIteratorMethod, arrayFrom, ITERATOR$4, SAFE_CLOSING, called, iteratorWithReturn, checkCorrectnessOfIteration, INCORRECT_ITERATION, from_1, from_1$1, from_1$2, Object$1, create3, create$1, create$2, defineProperty$5, defineProperty$6, defineProperty$7, whitespaces, whitespace, ltrim, rtrim, createMethod$3, stringTrim, non, stringTrimForced, $trim, trim2, arrayMethodIsStrict, defineProperty$8, cache, thrower, arrayMethodUsesToLength, $forEach$1, STRICT_METHOD, USES_TO_LENGTH, arrayForEach, forEach2, forEach$1, ArrayPrototype$1, DOMIterables, forEach_1, forEach$2, trim$1, $parseInt, hex, FORCED$1, numberParseInt, _parseInt, _parseInt$1, _parseInt$2, propertyIsEnumerable3, createMethod$4, objectToArray, $values, values2, engineUserAgent, process2, versions, v8, match, version, engineV8Version, SPECIES$1, arrayMethodHasSpeciesSupport, $filter, HAS_SPECIES_SUPPORT, USES_TO_LENGTH$1, filter2, ArrayPrototype$2, filter_1, filter$1, filter$2, FAILS_ON_PRIMITIVES$1, getPrototypeOf2, getPrototypeOf$1, getPrototypeOf$2, $indexOf, nativeIndexOf, NEGATIVE_ZERO, STRICT_METHOD$1, USES_TO_LENGTH$2, indexOf$1, ArrayPrototype$3, indexOf_1, indexOf$2, indexOf$3, isArray$1, isArray$2, isArray$3, arrayWithHoles, ITERATOR$5, isIterable, isIterable_1, isIterable$1, IS_CONCAT_SPREADABLE, MAX_SAFE_INTEGER, MAXIMUM_ALLOWED_INDEX_EXCEEDED, IS_CONCAT_SPREADABLE_SUPPORT, SPECIES_SUPPORT, isConcatSpreadable, FORCED$2, symbol, symbol$1, symbol$2, iterableToArrayLimit, from_1$3, from_1$4, HAS_SPECIES_SUPPORT$1, USES_TO_LENGTH$3, SPECIES$2, nativeSlice, max$1, slice$1, ArrayPrototype$4, slice_1, slice$2, slice$3, arrayLikeToArray, unsupportedIterableToArray, nonIterableRest, slicedToArray, now2, now$1, now$2, FAILS_ON_PRIMITIVES$2, keys$1, keys$2, keys$3, $map, HAS_SPECIES_SUPPORT$2, USES_TO_LENGTH$4, map2, ArrayPrototype$5, map_1, map$1, map$2, isArray$4, isArray$5, iterator, iterator$1, iterator$2, _typeof_1, ownKeys$1, ownKeys$2, ownKeys$3, slice$4, slice$5, arrayWithoutHoles, iterableToArray, nonIterableSpread, toConsumableArray, concat2, ArrayPrototype$6, concat_1, concat$1, concat$2, symbol$3, symbol$4, DELETE, fullHexRE, shortHexRE, rgbRE, rgbaRE, easingFunctions, HAS_SPECIES_SUPPORT$3, USES_TO_LENGTH$5, max$2, min$2, MAX_SAFE_INTEGER$1, MAXIMUM_ALLOWED_LENGTH_EXCEEDED, splice2, ArrayPrototype$7, splice_1, splice$1, splice$2, $includes, USES_TO_LENGTH$6, includes2, MATCH, isRegexp, notARegexp, MATCH$1, correctIsRegexpLogic, includes$1, ArrayPrototype$8, StringPrototype, includes$2, includes$3, includes$4, NODE_ATTR_MAPPING, EDGE_ATTR_MAPPING, TOKENTYPE, DELIMITERS, dot, index, c, token, tokenType, regexAlphaNumeric, dotparser, gephiParser, css_248z, keycharm, assign$3, assign$1$1, VENDOR_PREFIXES, TEST_ELEMENT, TYPE_FUNCTION, round, abs, now$3, win, PREFIXED_TOUCH_ACTION, NATIVE_TOUCH_ACTION, TOUCH_ACTION_COMPUTE, TOUCH_ACTION_AUTO, TOUCH_ACTION_MANIPULATION, TOUCH_ACTION_NONE, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, TOUCH_ACTION_MAP, MOBILE_REGEX, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS, SUPPORT_ONLY_TOUCH, INPUT_TYPE_TOUCH, INPUT_TYPE_PEN, INPUT_TYPE_MOUSE, INPUT_TYPE_KINECT, COMPUTE_INTERVAL, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, PROPS_XY, PROPS_CLIENT_XY, TouchAction, Input, POINTER_INPUT_MAP, IE10_POINTER_TYPE_ENUM, POINTER_ELEMENT_EVENTS, POINTER_WINDOW_EVENTS, PointerEventInput, TOUCH_INPUT_MAP, TOUCH_TARGET_EVENTS, TouchInput, MOUSE_INPUT_MAP, MOUSE_ELEMENT_EVENTS, MOUSE_WINDOW_EVENTS, MouseInput, DEDUP_TIMEOUT, DEDUP_DISTANCE, TouchMouseInput, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, _uniqueId, Recognizer, TapRecognizer, AttrRecognizer, PanRecognizer, SwipeRecognizer, PinchRecognizer, RotateRecognizer, PressRecognizer, defaults, preset, STOP, FORCED_STOP, Manager, SINGLE_TOUCH_INPUT_MAP, SINGLE_TOUCH_TARGET_EVENTS, SINGLE_TOUCH_WINDOW_EVENTS, SingleTouchInput, extend, merge$1, Hammer, hammer, en, de, es, it, nl, pt, ru, cn, uk, fr, cs, locales, classCallCheck, createClass, CachedImage, Images, Groups, slice$6, MSIE, wrap$1, setTimeout$1, setTimeout$2, $some, STRICT_METHOD$2, USES_TO_LENGTH$7, some2, ArrayPrototype$9, some_1, some$1, some$2, globalIsFinite, numberIsFinite, _isFinite, _isFinite$1, _isFinite$2, isNan, isNan$1, isNan$2, assertThisInitialized, nativeConstruct, NEW_TARGET_BUG, ARGS_BUG, FORCED$3, construct$1, construct$2, construct$3, entries, entries$1, ArrayPrototype$a, DOMIterables$1, entries_1, entries$2, $stringify$1, re, low, hi, fix, FORCED$4, stringify, stringify$1, stringify$2, values$1, values$2, ArrayPrototype$b, DOMIterables$2, values_1, values$3, keys$4, keys$5, ArrayPrototype$c, DOMIterables$3, keys_1, keys$6, create$3, create$4, setPrototypeOf, setPrototypeOf$1, setPrototypeOf$2, setPrototypeOf$3, inherits, possibleConstructorReturn, getPrototypeOf$3, getPrototypeOf$4, getPrototypeOf$5, test$1, nativeSort, FAILS_ON_UNDEFINED, FAILS_ON_NULL, STRICT_METHOD$3, FORCED$5, sort2, ArrayPrototype$d, sort_1, sort$1, sort$2, freezing, internalMetadata, iterate_1, anInstance, defineProperty$9, forEach$4, setInternalState$3, internalStateGetterFor, collection, redefineAll, SPECIES$3, setSpecies, defineProperty$a, fastKey, setInternalState$4, internalStateGetterFor$1, collectionStrong, es_set, set$1, set$2, set$3, es_map, map$3, map$4, map$5, runtime_1, regenerator, iterator$3, iterator$4, flattenIntoArray, flattenIntoArray_1, flatMap2, ArrayPrototype$e, flatMap_1, flatMap$1, flatMap$2, createMethod$5, arrayReduce, $reduce, STRICT_METHOD$4, USES_TO_LENGTH$8, reduce2, ArrayPrototype$f, reduce_1, reduce$1, reduce$2, getRandomValues, rnds8, byteToHex, i, moment, SimpleDataPipe, DataPipeUnderConstruction, ASPDateRegex, Queue, DataSetPart, DataStream, warnTypeCorectionDeprecation, DataSet, DataView, index$1, nativeGetOwnPropertyNames$2, FAILS_ON_PRIMITIVES$3, Object$2, getOwnPropertyNames4, getOwnPropertyNames$1, getOwnPropertyNames$2, trim$2, $parseFloat, FORCED$6, numberParseFloat, _parseFloat, _parseFloat$1, _parseFloat$2, LabelAccumulator, tagPattern, MarkupAccumulator, LabelSplitter, multiFontStyle, Label, arrayFill, fill2, ArrayPrototype$g, fill_1, fill$1, fill$2, NodeBase, Box, CircleImageBase, Circle, CircularImage, ShapeBase, CustomShape, Database, Diamond, Dot, Ellipse, Icon, Image$1, Square, Hexagon, Star, Text, Triangle, TriangleDown, errorFound, allOptions, printStyle, Validator, Node, NodesHandler, getOwnPropertyDescriptor$4, getOwnPropertyDescriptor$5, get$2, get$3, get$4, superPropBase, get$5, $hypot, abs$1, sqrt, BUGGY, hypot2, hypot$1, hypot$2, EndPoint, Image$2, Arrow, Crow, Curve, InvertedCurve, Triangle$1, InvertedTriangle, Circle$1, Bar, Box$1, Diamond$1, Vee, EndPoints, EdgeBase, BezierEdgeBase, BezierEdgeDynamic, BezierEdgeStatic, CubicBezierEdgeBase, CubicBezierEdge, StraightEdge, Edge, EdgesHandler, BarnesHutSolver, RepulsionSolver, HierarchicalRepulsionSolver, SpringSolver, HierarchicalSpringSolver, CentralGravitySolver, ForceAtlas2BasedRepulsionSolver, ForceAtlas2BasedCentralGravitySolver, PhysicsEngine, nativeReverse, test$2, reverse2, ArrayPrototype$h, reverse_1, reverse$1, reverse$2, NetworkUtil, Cluster, ClusterEngine, CanvasRenderer, setInterval, setInterval$1, Canvas, View, css_248z$1, NavigationHandler, css_248z$2, Popup, InteractionHandler, SelectionHandler, timsort, timsort$1, DirectionInterface, VerticalStrategy, HorizontalStrategy, $every, STRICT_METHOD$5, USES_TO_LENGTH$9, every2, ArrayPrototype$i, every_1, every$1, every$2, HierarchicalStatus, LayoutEngine, css_248z$3, ManipulationSystem, css_248z$4, css_248z$5, htmlColors, ColorPicker, Configurator, string, bool, number, array, object, dom, any, endPoints, allOptions$1, configureOptions, options, FloydWarshall, KamadaKawai, parseDOTNetwork;
var init_vis_network = __esm({
  "node_modules/react-vis-network-graph/node_modules/vis-network/standalone/esm/vis-network.js"() {
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    check = function(it2) {
      return it2 && it2.Math == Math && it2;
    };
    global_1 = // eslint-disable-next-line no-undef
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func
    Function("return this")();
    fails = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
    descriptors = !fails(function() {
      return Object.defineProperty({}, 1, {
        get: function() {
          return 7;
        }
      })[1] != 7;
    });
    nativePropertyIsEnumerable = {}.propertyIsEnumerable;
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
      1: 2
    }, 1);
    f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : nativePropertyIsEnumerable;
    objectPropertyIsEnumerable = {
      f
    };
    createPropertyDescriptor = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    toString = {}.toString;
    classofRaw = function(it2) {
      return toString.call(it2).slice(8, -1);
    };
    split = "".split;
    indexedObject = fails(function() {
      return !Object("z").propertyIsEnumerable(0);
    }) ? function(it2) {
      return classofRaw(it2) == "String" ? split.call(it2, "") : Object(it2);
    } : Object;
    requireObjectCoercible = function(it2) {
      if (it2 == void 0) throw TypeError("Can't call method on " + it2);
      return it2;
    };
    toIndexedObject = function(it2) {
      return indexedObject(requireObjectCoercible(it2));
    };
    isObject = function(it2) {
      return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
    };
    toPrimitive = function(input, PREFERRED_STRING) {
      if (!isObject(input)) return input;
      var fn, val;
      if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input))) return val;
      if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input))) return val;
      if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
    hasOwnProperty = {}.hasOwnProperty;
    has = function(it2, key) {
      return hasOwnProperty.call(it2, key);
    };
    document$1 = global_1.document;
    EXISTS = isObject(document$1) && isObject(document$1.createElement);
    documentCreateElement = function(it2) {
      return EXISTS ? document$1.createElement(it2) : {};
    };
    ie8DomDefine = !descriptors && !fails(function() {
      return Object.defineProperty(documentCreateElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
    nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject(O);
      P = toPrimitive(P, true);
      if (ie8DomDefine) try {
        return nativeGetOwnPropertyDescriptor(O, P);
      } catch (error) {
      }
      if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
    };
    objectGetOwnPropertyDescriptor = {
      f: f$1
    };
    replacement = /#|\.prototype\./;
    isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
    };
    normalize = isForced.normalize = function(string2) {
      return String(string2).replace(replacement, ".").toLowerCase();
    };
    data = isForced.data = {};
    NATIVE = isForced.NATIVE = "N";
    POLYFILL = isForced.POLYFILL = "P";
    isForced_1 = isForced;
    path = {};
    aFunction = function(it2) {
      if (typeof it2 != "function") {
        throw TypeError(String(it2) + " is not a function");
      }
      return it2;
    };
    functionBindContext = function(fn, that, length2) {
      aFunction(fn);
      if (that === void 0) return fn;
      switch (length2) {
        case 0:
          return function() {
            return fn.call(that);
          };
        case 1:
          return function(a) {
            return fn.call(that, a);
          };
        case 2:
          return function(a, b) {
            return fn.call(that, a, b);
          };
        case 3:
          return function(a, b, c2) {
            return fn.call(that, a, b, c2);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
    anObject = function(it2) {
      if (!isObject(it2)) {
        throw TypeError(String(it2) + " is not an object");
      }
      return it2;
    };
    nativeDefineProperty = Object.defineProperty;
    f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (ie8DomDefine) try {
        return nativeDefineProperty(O, P, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
    objectDefineProperty = {
      f: f$2
    };
    createNonEnumerableProperty = descriptors ? function(object2, key, value) {
      return objectDefineProperty.f(object2, key, createPropertyDescriptor(1, value));
    } : function(object2, key, value) {
      object2[key] = value;
      return object2;
    };
    getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
    wrapConstructor = function(NativeConstructor) {
      var Wrapper = function(a, b, c2) {
        if (this instanceof NativeConstructor) {
          switch (arguments.length) {
            case 0:
              return new NativeConstructor();
            case 1:
              return new NativeConstructor(a);
            case 2:
              return new NativeConstructor(a, b);
          }
          return new NativeConstructor(a, b, c2);
        }
        return NativeConstructor.apply(this, arguments);
      };
      Wrapper.prototype = NativeConstructor.prototype;
      return Wrapper;
    };
    _export = function(options2, source) {
      var TARGET = options2.target;
      var GLOBAL = options2.global;
      var STATIC = options2.stat;
      var PROTO = options2.proto;
      var nativeSource = GLOBAL ? global_1 : STATIC ? global_1[TARGET] : (global_1[TARGET] || {}).prototype;
      var target = GLOBAL ? path : path[TARGET] || (path[TARGET] = {});
      var targetPrototype = target.prototype;
      var FORCED2, USE_NATIVE, VIRTUAL_PROTOTYPE;
      var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
      for (key in source) {
        FORCED2 = isForced_1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
        USE_NATIVE = !FORCED2 && nativeSource && has(nativeSource, key);
        targetProperty = target[key];
        if (USE_NATIVE) if (options2.noTargetGet) {
          descriptor = getOwnPropertyDescriptor$1(nativeSource, key);
          nativeProperty = descriptor && descriptor.value;
        } else nativeProperty = nativeSource[key];
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
        if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue;
        if (options2.bind && USE_NATIVE) resultProperty = functionBindContext(sourceProperty, global_1);
        else if (options2.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && typeof sourceProperty == "function") resultProperty = functionBindContext(Function.call, sourceProperty);
        else resultProperty = sourceProperty;
        if (options2.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(resultProperty, "sham", true);
        }
        target[key] = resultProperty;
        if (PROTO) {
          VIRTUAL_PROTOTYPE = TARGET + "Prototype";
          if (!has(path, VIRTUAL_PROTOTYPE)) {
            createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
          }
          path[VIRTUAL_PROTOTYPE][key] = sourceProperty;
          if (options2.real && targetPrototype && !targetPrototype[key]) {
            createNonEnumerableProperty(targetPrototype, key, sourceProperty);
          }
        }
      }
    };
    slice = [].slice;
    factories = {};
    construct = function(C, argsLength, args) {
      if (!(argsLength in factories)) {
        for (var list = [], i = 0; i < argsLength; i++) list[i] = "a[" + i + "]";
        factories[argsLength] = Function("C,a", "return new C(" + list.join(",") + ")");
      }
      return factories[argsLength](C, args);
    };
    functionBind = Function.bind || function bind(that) {
      var fn = aFunction(this);
      var partArgs = slice.call(arguments, 1);
      var boundFunction = function bound() {
        var args = partArgs.concat(slice.call(arguments));
        return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
      };
      if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
      return boundFunction;
    };
    _export({
      target: "Function",
      proto: true
    }, {
      bind: functionBind
    });
    entryVirtual = function(CONSTRUCTOR) {
      return path[CONSTRUCTOR + "Prototype"];
    };
    bind2 = entryVirtual("Function").bind;
    FunctionPrototype = Function.prototype;
    bind_1 = function(it2) {
      var own = it2.bind;
      return it2 === FunctionPrototype || it2 instanceof Function && own === FunctionPrototype.bind ? bind2 : own;
    };
    bind$1 = bind_1;
    bind$2 = bind$1;
    ceil = Math.ceil;
    floor = Math.floor;
    toInteger = function(argument) {
      return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
    };
    min = Math.min;
    toLength = function(argument) {
      return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
    };
    max = Math.max;
    min$1 = Math.min;
    toAbsoluteIndex = function(index2, length2) {
      var integer = toInteger(index2);
      return integer < 0 ? max(integer + length2, 0) : min$1(integer, length2);
    };
    createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length2 = toLength(O.length);
        var index2 = toAbsoluteIndex(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el != el) while (length2 > index2) {
          value = O[index2++];
          if (value != value) return true;
        }
        else for (; length2 > index2; index2++) {
          if ((IS_INCLUDES || index2 in O) && O[index2] === el) return IS_INCLUDES || index2 || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    arrayIncludes = {
      // `Array.prototype.includes` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
    hiddenKeys = {};
    indexOf = arrayIncludes.indexOf;
    objectKeysInternal = function(object2, names) {
      var O = toIndexedObject(object2);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
      while (names.length > i) if (has(O, key = names[i++])) {
        ~indexOf(result, key) || result.push(key);
      }
      return result;
    };
    enumBugKeys = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    objectKeys = Object.keys || function keys(O) {
      return objectKeysInternal(O, enumBugKeys);
    };
    f$3 = Object.getOwnPropertySymbols;
    objectGetOwnPropertySymbols = {
      f: f$3
    };
    toObject = function(argument) {
      return Object(requireObjectCoercible(argument));
    };
    nativeAssign = Object.assign;
    defineProperty2 = Object.defineProperty;
    objectAssign = !nativeAssign || fails(function() {
      if (descriptors && nativeAssign({
        b: 1
      }, nativeAssign(defineProperty2({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty2(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), {
        b: 2
      })).b !== 1) return true;
      var A = {};
      var B = {};
      var symbol2 = Symbol();
      var alphabet = "abcdefghijklmnopqrst";
      A[symbol2] = 7;
      alphabet.split("").forEach(function(chr) {
        B[chr] = chr;
      });
      return nativeAssign({}, A)[symbol2] != 7 || objectKeys(nativeAssign({}, B)).join("") != alphabet;
    }) ? function assign(target, source) {
      var T = toObject(target);
      var argumentsLength = arguments.length;
      var index2 = 1;
      var getOwnPropertySymbols4 = objectGetOwnPropertySymbols.f;
      var propertyIsEnumerable4 = objectPropertyIsEnumerable.f;
      while (argumentsLength > index2) {
        var S = indexedObject(arguments[index2++]);
        var keys4 = getOwnPropertySymbols4 ? objectKeys(S).concat(getOwnPropertySymbols4(S)) : objectKeys(S);
        var length2 = keys4.length;
        var j = 0;
        var key;
        while (length2 > j) {
          key = keys4[j++];
          if (!descriptors || propertyIsEnumerable4.call(S, key)) T[key] = S[key];
        }
      }
      return T;
    } : nativeAssign;
    _export({
      target: "Object",
      stat: true,
      forced: Object.assign !== objectAssign
    }, {
      assign: objectAssign
    });
    assign2 = path.Object.assign;
    assign$1 = assign2;
    assign$2 = assign$1;
    shapeMap = {
      circle: drawCircle,
      dashedLine: drawDashedLine,
      database: drawDatabase,
      diamond: drawDiamond,
      ellipse: drawEllipse,
      ellipse_vis: drawEllipse,
      hexagon: drawHexagon,
      roundRect: drawRoundRect,
      square: drawSquare,
      star: drawStar,
      triangle: drawTriangle,
      triangleDown: drawTriangleDown
    };
    componentEmitter = createCommonjsModule(function(module) {
      {
        module.exports = Emitter;
      }
      function Emitter(obj) {
        if (obj) return mixin(obj);
      }
      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event, fn) {
        function on() {
          this.off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks["$" + event];
        if (!callbacks) return this;
        if (1 == arguments.length) {
          delete this._callbacks["$" + event];
          return this;
        }
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        if (callbacks.length === 0) {
          delete this._callbacks["$" + event];
        }
        return this;
      };
      Emitter.prototype.emit = function(event) {
        this._callbacks = this._callbacks || {};
        var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.listeners = function(event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks["$" + event] || [];
      };
      Emitter.prototype.hasListeners = function(event) {
        return !!this.listeners(event).length;
      };
    });
    _export({
      target: "Object",
      stat: true,
      forced: !descriptors,
      sham: !descriptors
    }, {
      defineProperty: objectDefineProperty.f
    });
    defineProperty_1 = createCommonjsModule(function(module) {
      var Object2 = path.Object;
      var defineProperty4 = module.exports = function defineProperty5(it2, key, desc) {
        return Object2.defineProperty(it2, key, desc);
      };
      if (Object2.defineProperty.sham) defineProperty4.sham = true;
    });
    defineProperty$1 = defineProperty_1;
    defineProperty$2 = defineProperty$1;
    objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys4 = objectKeys(Properties);
      var length2 = keys4.length;
      var index2 = 0;
      var key;
      while (length2 > index2) objectDefineProperty.f(O, key = keys4[index2++], Properties[key]);
      return O;
    };
    _export({
      target: "Object",
      stat: true,
      forced: !descriptors,
      sham: !descriptors
    }, {
      defineProperties: objectDefineProperties
    });
    defineProperties_1 = createCommonjsModule(function(module) {
      var Object2 = path.Object;
      var defineProperties4 = module.exports = function defineProperties5(T, D) {
        return Object2.defineProperties(T, D);
      };
      if (Object2.defineProperties.sham) defineProperties4.sham = true;
    });
    defineProperties2 = defineProperties_1;
    defineProperties$1 = defineProperties2;
    aFunction$1 = function(variable) {
      return typeof variable == "function" ? variable : void 0;
    };
    getBuiltIn = function(namespace, method) {
      return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
    };
    hiddenKeys$1 = enumBugKeys.concat("length", "prototype");
    f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return objectKeysInternal(O, hiddenKeys$1);
    };
    objectGetOwnPropertyNames = {
      f: f$4
    };
    ownKeys = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it2) {
      var keys4 = objectGetOwnPropertyNames.f(anObject(it2));
      var getOwnPropertySymbols4 = objectGetOwnPropertySymbols.f;
      return getOwnPropertySymbols4 ? keys4.concat(getOwnPropertySymbols4(it2)) : keys4;
    };
    createProperty = function(object2, key, value) {
      var propertyKey = toPrimitive(key);
      if (propertyKey in object2) objectDefineProperty.f(object2, propertyKey, createPropertyDescriptor(0, value));
      else object2[propertyKey] = value;
    };
    _export({
      target: "Object",
      stat: true,
      sham: !descriptors
    }, {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object2) {
        var O = toIndexedObject(object2);
        var getOwnPropertyDescriptor5 = objectGetOwnPropertyDescriptor.f;
        var keys4 = ownKeys(O);
        var result = {};
        var index2 = 0;
        var key, descriptor;
        while (keys4.length > index2) {
          descriptor = getOwnPropertyDescriptor5(O, key = keys4[index2++]);
          if (descriptor !== void 0) createProperty(result, key, descriptor);
        }
        return result;
      }
    });
    getOwnPropertyDescriptors2 = path.Object.getOwnPropertyDescriptors;
    getOwnPropertyDescriptors$1 = getOwnPropertyDescriptors2;
    getOwnPropertyDescriptors$2 = getOwnPropertyDescriptors$1;
    nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
    FAILS_ON_PRIMITIVES = fails(function() {
      nativeGetOwnPropertyDescriptor$1(1);
    });
    FORCED = !descriptors || FAILS_ON_PRIMITIVES;
    _export({
      target: "Object",
      stat: true,
      forced: FORCED,
      sham: !descriptors
    }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(it2, key) {
        return nativeGetOwnPropertyDescriptor$1(toIndexedObject(it2), key);
      }
    });
    getOwnPropertyDescriptor_1 = createCommonjsModule(function(module) {
      var Object2 = path.Object;
      var getOwnPropertyDescriptor5 = module.exports = function getOwnPropertyDescriptor6(it2, key) {
        return Object2.getOwnPropertyDescriptor(it2, key);
      };
      if (Object2.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor5.sham = true;
    });
    getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor_1;
    getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$2;
    nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function() {
      return !String(Symbol());
    });
    useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == "symbol";
    isArray = Array.isArray || function isArray2(arg) {
      return classofRaw(arg) == "Array";
    };
    html = getBuiltIn("document", "documentElement");
    setGlobal = function(key, value) {
      try {
        createNonEnumerableProperty(global_1, key, value);
      } catch (error) {
        global_1[key] = value;
      }
      return value;
    };
    SHARED = "__core-js_shared__";
    store = global_1[SHARED] || setGlobal(SHARED, {});
    sharedStore = store;
    shared = createCommonjsModule(function(module) {
      (module.exports = function(key, value) {
        return sharedStore[key] || (sharedStore[key] = value !== void 0 ? value : {});
      })("versions", []).push({
        version: "3.6.4",
        mode: "pure",
        copyright: " 2020 Denis Pushkarev (zloirock.ru)"
      });
    });
    id = 0;
    postfix = Math.random();
    uid = function(key) {
      return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
    };
    keys2 = shared("keys");
    sharedKey = function(key) {
      return keys2[key] || (keys2[key] = uid(key));
    };
    GT = ">";
    LT = "<";
    PROTOTYPE = "prototype";
    SCRIPT = "script";
    IE_PROTO = sharedKey("IE_PROTO");
    EmptyConstructor = function() {
    };
    scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    NullProtoObject = function() {
      try {
        activeXDocument = document.domain && new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
      var length2 = enumBugKeys.length;
      while (length2--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    objectCreate = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : objectDefineProperties(result, Properties);
    };
    nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;
    toString$1 = {}.toString;
    windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    getWindowNames = function(it2) {
      try {
        return nativeGetOwnPropertyNames(it2);
      } catch (error) {
        return windowNames.slice();
      }
    };
    f$5 = function getOwnPropertyNames2(it2) {
      return windowNames && toString$1.call(it2) == "[object Window]" ? getWindowNames(it2) : nativeGetOwnPropertyNames(toIndexedObject(it2));
    };
    objectGetOwnPropertyNamesExternal = {
      f: f$5
    };
    redefine = function(target, key, value, options2) {
      if (options2 && options2.enumerable) target[key] = value;
      else createNonEnumerableProperty(target, key, value);
    };
    WellKnownSymbolsStore = shared("wks");
    Symbol$1 = global_1.Symbol;
    createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;
    wellKnownSymbol = function(name) {
      if (!has(WellKnownSymbolsStore, name)) {
        if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
        else WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
    f$6 = wellKnownSymbol;
    wellKnownSymbolWrapped = {
      f: f$6
    };
    defineProperty$3 = objectDefineProperty.f;
    defineWellKnownSymbol = function(NAME) {
      var Symbol2 = path.Symbol || (path.Symbol = {});
      if (!has(Symbol2, NAME)) defineProperty$3(Symbol2, NAME, {
        value: wellKnownSymbolWrapped.f(NAME)
      });
    };
    TO_STRING_TAG = wellKnownSymbol("toStringTag");
    test = {};
    test[TO_STRING_TAG] = "z";
    toStringTagSupport = String(test) === "[object z]";
    TO_STRING_TAG$1 = wellKnownSymbol("toStringTag");
    CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments";
    tryGet = function(it2, key) {
      try {
        return it2[key];
      } catch (error) {
      }
    };
    classof = toStringTagSupport ? classofRaw : function(it2) {
      var O, tag, result;
      return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O = Object(it2), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
    };
    objectToString = toStringTagSupport ? {}.toString : function toString2() {
      return "[object " + classof(this) + "]";
    };
    defineProperty$4 = objectDefineProperty.f;
    TO_STRING_TAG$2 = wellKnownSymbol("toStringTag");
    setToStringTag = function(it2, TAG, STATIC, SET_METHOD) {
      if (it2) {
        var target = STATIC ? it2 : it2.prototype;
        if (!has(target, TO_STRING_TAG$2)) {
          defineProperty$4(target, TO_STRING_TAG$2, {
            configurable: true,
            value: TAG
          });
        }
        if (SET_METHOD && !toStringTagSupport) {
          createNonEnumerableProperty(target, "toString", objectToString);
        }
      }
    };
    functionToString = Function.toString;
    if (typeof sharedStore.inspectSource != "function") {
      sharedStore.inspectSource = function(it2) {
        return functionToString.call(it2);
      };
    }
    inspectSource = sharedStore.inspectSource;
    WeakMap = global_1.WeakMap;
    nativeWeakMap = typeof WeakMap === "function" && /native code/.test(inspectSource(WeakMap));
    WeakMap$1 = global_1.WeakMap;
    enforce = function(it2) {
      return has$1(it2) ? get(it2) : set(it2, {});
    };
    getterFor = function(TYPE) {
      return function(it2) {
        var state;
        if (!isObject(it2) || (state = get(it2)).type !== TYPE) {
          throw TypeError("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (nativeWeakMap) {
      store$1 = new WeakMap$1();
      wmget = store$1.get;
      wmhas = store$1.has;
      wmset = store$1.set;
      set = function(it2, metadata) {
        wmset.call(store$1, it2, metadata);
        return metadata;
      };
      get = function(it2) {
        return wmget.call(store$1, it2) || {};
      };
      has$1 = function(it2) {
        return wmhas.call(store$1, it2);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it2, metadata) {
        createNonEnumerableProperty(it2, STATE, metadata);
        return metadata;
      };
      get = function(it2) {
        return has(it2, STATE) ? it2[STATE] : {};
      };
      has$1 = function(it2) {
        return has(it2, STATE);
      };
    }
    internalState = {
      set,
      get,
      has: has$1,
      enforce,
      getterFor
    };
    SPECIES = wellKnownSymbol("species");
    arraySpeciesCreate = function(originalArray, length2) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null) C = void 0;
        }
      }
      return new (C === void 0 ? Array : C)(length2 === 0 ? 0 : length2);
    };
    push = [].push;
    createMethod$1 = function(TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self2 = indexedObject(O);
        var boundFunction = functionBindContext(callbackfn, that, 3);
        var length2 = toLength(self2.length);
        var index2 = 0;
        var create5 = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create5($this, length2) : IS_FILTER ? create5($this, 0) : void 0;
        var value, result;
        for (; length2 > index2; index2++) if (NO_HOLES || index2 in self2) {
          value = self2[index2];
          result = boundFunction(value, index2, O);
          if (TYPE) {
            if (IS_MAP) target[index2] = result;
            else if (result) switch (TYPE) {
              case 3:
                return true;
              // some
              case 5:
                return value;
              // find
              case 6:
                return index2;
              // findIndex
              case 2:
                push.call(target, value);
            }
            else if (IS_EVERY) return false;
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    arrayIteration = {
      // `Array.prototype.forEach` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
      forEach: createMethod$1(0),
      // `Array.prototype.map` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.map
      map: createMethod$1(1),
      // `Array.prototype.filter` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.filter
      filter: createMethod$1(2),
      // `Array.prototype.some` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.some
      some: createMethod$1(3),
      // `Array.prototype.every` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.every
      every: createMethod$1(4),
      // `Array.prototype.find` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.find
      find: createMethod$1(5),
      // `Array.prototype.findIndex` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod$1(6)
    };
    $forEach = arrayIteration.forEach;
    HIDDEN = sharedKey("hidden");
    SYMBOL = "Symbol";
    PROTOTYPE$1 = "prototype";
    TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    setInternalState = internalState.set;
    getInternalState = internalState.getterFor(SYMBOL);
    ObjectPrototype = Object[PROTOTYPE$1];
    $Symbol = global_1.Symbol;
    $stringify = getBuiltIn("JSON", "stringify");
    nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
    nativeDefineProperty$1 = objectDefineProperty.f;
    nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
    nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
    AllSymbols = shared("symbols");
    ObjectPrototypeSymbols = shared("op-symbols");
    StringToSymbolRegistry = shared("string-to-symbol-registry");
    SymbolToStringRegistry = shared("symbol-to-string-registry");
    WellKnownSymbolsStore$1 = shared("wks");
    QObject = global_1.QObject;
    USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;
    setSymbolDescriptor = descriptors && fails(function() {
      return objectCreate(nativeDefineProperty$1({}, "a", {
        get: function() {
          return nativeDefineProperty$1(this, "a", {
            value: 7
          }).a;
        }
      })).a != 7;
    }) ? function(O, P, Attributes) {
      var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$2(ObjectPrototype, P);
      if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
      nativeDefineProperty$1(O, P, Attributes);
      if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
        nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
      }
    } : nativeDefineProperty$1;
    wrap = function(tag, description) {
      var symbol2 = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
      setInternalState(symbol2, {
        type: SYMBOL,
        tag,
        description
      });
      if (!descriptors) symbol2.description = description;
      return symbol2;
    };
    isSymbol = useSymbolAsUid ? function(it2) {
      return typeof it2 == "symbol";
    } : function(it2) {
      return Object(it2) instanceof $Symbol;
    };
    $defineProperty = function defineProperty3(O, P, Attributes) {
      if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
      anObject(O);
      var key = toPrimitive(P, true);
      anObject(Attributes);
      if (has(AllSymbols, key)) {
        if (!Attributes.enumerable) {
          if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
          O[HIDDEN][key] = true;
        } else {
          if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
          Attributes = objectCreate(Attributes, {
            enumerable: createPropertyDescriptor(0, false)
          });
        }
        return setSymbolDescriptor(O, key, Attributes);
      }
      return nativeDefineProperty$1(O, key, Attributes);
    };
    $defineProperties = function defineProperties3(O, Properties) {
      anObject(O);
      var properties = toIndexedObject(Properties);
      var keys4 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
      $forEach(keys4, function(key) {
        if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
      });
      return O;
    };
    $create = function create2(O, Properties) {
      return Properties === void 0 ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
    };
    $propertyIsEnumerable = function propertyIsEnumerable2(V) {
      var P = toPrimitive(V, true);
      var enumerable = nativePropertyIsEnumerable$1.call(this, P);
      if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
      return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
    };
    $getOwnPropertyDescriptor = function getOwnPropertyDescriptor4(O, P) {
      var it2 = toIndexedObject(O);
      var key = toPrimitive(P, true);
      if (it2 === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
      var descriptor = nativeGetOwnPropertyDescriptor$2(it2, key);
      if (descriptor && has(AllSymbols, key) && !(has(it2, HIDDEN) && it2[HIDDEN][key])) {
        descriptor.enumerable = true;
      }
      return descriptor;
    };
    $getOwnPropertyNames = function getOwnPropertyNames3(O) {
      var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
      });
      return result;
    };
    $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
      var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
      var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
          result.push(AllSymbols[key]);
        }
      });
      return result;
    };
    if (!nativeSymbol) {
      $Symbol = function Symbol2() {
        if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor");
        var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
        var tag = uid(description);
        var setter = function(value) {
          if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
          if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
          setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
        };
        if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
          configurable: true,
          set: setter
        });
        return wrap(tag, description);
      };
      redefine($Symbol[PROTOTYPE$1], "toString", function toString3() {
        return getInternalState(this).tag;
      });
      redefine($Symbol, "withoutSetter", function(description) {
        return wrap(uid(description), description);
      });
      objectPropertyIsEnumerable.f = $propertyIsEnumerable;
      objectDefineProperty.f = $defineProperty;
      objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
      objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
      objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;
      wellKnownSymbolWrapped.f = function(name) {
        return wrap(wellKnownSymbol(name), name);
      };
      if (descriptors) {
        nativeDefineProperty$1($Symbol[PROTOTYPE$1], "description", {
          configurable: true,
          get: function description() {
            return getInternalState(this).description;
          }
        });
      }
    }
    _export({
      global: true,
      wrap: true,
      forced: !nativeSymbol,
      sham: !nativeSymbol
    }, {
      Symbol: $Symbol
    });
    $forEach(objectKeys(WellKnownSymbolsStore$1), function(name) {
      defineWellKnownSymbol(name);
    });
    _export({
      target: SYMBOL,
      stat: true,
      forced: !nativeSymbol
    }, {
      // `Symbol.for` method
      // https://tc39.github.io/ecma262/#sec-symbol.for
      "for": function(key) {
        var string2 = String(key);
        if (has(StringToSymbolRegistry, string2)) return StringToSymbolRegistry[string2];
        var symbol2 = $Symbol(string2);
        StringToSymbolRegistry[string2] = symbol2;
        SymbolToStringRegistry[symbol2] = string2;
        return symbol2;
      },
      // `Symbol.keyFor` method
      // https://tc39.github.io/ecma262/#sec-symbol.keyfor
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol");
        if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
      },
      useSetter: function() {
        USE_SETTER = true;
      },
      useSimple: function() {
        USE_SETTER = false;
      }
    });
    _export({
      target: "Object",
      stat: true,
      forced: !nativeSymbol,
      sham: !descriptors
    }, {
      // `Object.create` method
      // https://tc39.github.io/ecma262/#sec-object.create
      create: $create,
      // `Object.defineProperty` method
      // https://tc39.github.io/ecma262/#sec-object.defineproperty
      defineProperty: $defineProperty,
      // `Object.defineProperties` method
      // https://tc39.github.io/ecma262/#sec-object.defineproperties
      defineProperties: $defineProperties,
      // `Object.getOwnPropertyDescriptor` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });
    _export({
      target: "Object",
      stat: true,
      forced: !nativeSymbol
    }, {
      // `Object.getOwnPropertyNames` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
      getOwnPropertyNames: $getOwnPropertyNames,
      // `Object.getOwnPropertySymbols` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
      getOwnPropertySymbols: $getOwnPropertySymbols
    });
    _export({
      target: "Object",
      stat: true,
      forced: fails(function() {
        objectGetOwnPropertySymbols.f(1);
      })
    }, {
      getOwnPropertySymbols: function getOwnPropertySymbols2(it2) {
        return objectGetOwnPropertySymbols.f(toObject(it2));
      }
    });
    if ($stringify) {
      FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function() {
        var symbol2 = $Symbol();
        return $stringify([symbol2]) != "[null]" || $stringify({
          a: symbol2
        }) != "{}" || $stringify(Object(symbol2)) != "{}";
      });
      _export({
        target: "JSON",
        stat: true,
        forced: FORCED_JSON_STRINGIFY
      }, {
        // eslint-disable-next-line no-unused-vars
        stringify: function stringify3(it2, replacer, space) {
          var args = [it2];
          var index2 = 1;
          var $replacer;
          while (arguments.length > index2) args.push(arguments[index2++]);
          $replacer = replacer;
          if (!isObject(replacer) && it2 === void 0 || isSymbol(it2)) return;
          if (!isArray(replacer)) replacer = function(key, value) {
            if (typeof $replacer == "function") value = $replacer.call(this, key, value);
            if (!isSymbol(value)) return value;
          };
          args[1] = replacer;
          return $stringify.apply(null, args);
        }
      });
    }
    if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
      createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
    }
    setToStringTag($Symbol, SYMBOL);
    hiddenKeys[HIDDEN] = true;
    getOwnPropertySymbols3 = path.Object.getOwnPropertySymbols;
    getOwnPropertySymbols$1 = getOwnPropertySymbols3;
    getOwnPropertySymbols$2 = getOwnPropertySymbols$1;
    iterators = {};
    correctPrototypeGetter = !fails(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    IE_PROTO$1 = sharedKey("IE_PROTO");
    ObjectPrototype$1 = Object.prototype;
    objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function(O) {
      O = toObject(O);
      if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
      if (typeof O.constructor == "function" && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectPrototype$1 : null;
    };
    ITERATOR = wellKnownSymbol("iterator");
    BUGGY_SAFARI_ITERATORS = false;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    if (IteratorPrototype == void 0) IteratorPrototype = {};
    iteratorsCore = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
    IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
    returnThis = function() {
      return this;
    };
    createIteratorConstructor = function(IteratorConstructor, NAME, next3) {
      var TO_STRING_TAG2 = NAME + " Iterator";
      IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
        next: createPropertyDescriptor(1, next3)
      });
      setToStringTag(IteratorConstructor, TO_STRING_TAG2, false, true);
      iterators[TO_STRING_TAG2] = returnThis;
      return IteratorConstructor;
    };
    aPossiblePrototype = function(it2) {
      if (!isObject(it2) && it2 !== null) {
        throw TypeError("Can't set " + String(it2) + " as a prototype");
      }
      return it2;
    };
    objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test2 = {};
      var setter;
      try {
        setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
        setter.call(test2, []);
        CORRECT_SETTER = test2 instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf2(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter.call(O, proto);
        else O.__proto__ = proto;
        return O;
      };
    }() : void 0);
    IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
    BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
    ITERATOR$1 = wellKnownSymbol("iterator");
    KEYS = "keys";
    VALUES = "values";
    ENTRIES = "entries";
    returnThis$1 = function() {
      return this;
    };
    defineIterator = function(Iterable, NAME, IteratorConstructor, next3, DEFAULT, IS_SET, FORCED2) {
      createIteratorConstructor(IteratorConstructor, NAME, next3);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys4() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values3() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries2() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG2 = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true, true);
          iterators[TO_STRING_TAG2] = returnThis$1;
        }
      }
      if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values3() {
          return nativeIterator.call(this);
        };
      }
      if (FORCED2 && IterablePrototype[ITERATOR$1] !== defaultIterator) {
        createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
      }
      iterators[NAME] = defaultIterator;
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED2) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            redefine(IterablePrototype, KEY, methods[KEY]);
          }
        }
        else _export({
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
        }, methods);
      }
      return methods;
    };
    ARRAY_ITERATOR = "Array Iterator";
    setInternalState$1 = internalState.set;
    getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);
    es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState$1(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState$1(this);
      var target = state.target;
      var kind = state.kind;
      var index2 = state.index++;
      if (!target || index2 >= target.length) {
        state.target = void 0;
        return {
          value: void 0,
          done: true
        };
      }
      if (kind == "keys") return {
        value: index2,
        done: false
      };
      if (kind == "values") return {
        value: target[index2],
        done: false
      };
      return {
        value: [index2, target[index2]],
        done: false
      };
    }, "values");
    iterators.Arguments = iterators.Array;
    domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    TO_STRING_TAG$3 = wellKnownSymbol("toStringTag");
    for (COLLECTION_NAME in domIterables) {
      Collection = global_1[COLLECTION_NAME];
      CollectionPrototype = Collection && Collection.prototype;
      if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG$3) {
        createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
      }
      iterators[COLLECTION_NAME] = iterators.Array;
    }
    createMethod$2 = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = String(requireObjectCoercible($this));
        var position = toInteger(pos);
        var size = S.length;
        var first2, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
        first2 = S.charCodeAt(position);
        return first2 < 55296 || first2 > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first2 : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    stringMultibyte = {
      // `String.prototype.codePointAt` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod$2(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod$2(true)
    };
    charAt = stringMultibyte.charAt;
    STRING_ITERATOR = "String Iterator";
    setInternalState$2 = internalState.set;
    getInternalState$2 = internalState.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState$2(this, {
        type: STRING_ITERATOR,
        string: String(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState$2(this);
      var string2 = state.string;
      var index2 = state.index;
      var point;
      if (index2 >= string2.length) return {
        value: void 0,
        done: true
      };
      point = charAt(string2, index2);
      state.index += point.length;
      return {
        value: point,
        done: false
      };
    });
    ITERATOR$2 = wellKnownSymbol("iterator");
    getIteratorMethod = function(it2) {
      if (it2 != void 0) return it2[ITERATOR$2] || it2["@@iterator"] || iterators[classof(it2)];
    };
    getIterator = function(it2) {
      var iteratorMethod = getIteratorMethod(it2);
      if (typeof iteratorMethod != "function") {
        throw TypeError(String(it2) + " is not iterable");
      }
      return anObject(iteratorMethod.call(it2));
    };
    getIterator_1 = getIterator;
    getIterator$1 = getIterator_1;
    getIteratorMethod_1 = getIteratorMethod;
    getIteratorMethod$1 = getIteratorMethod_1;
    callWithSafeIterationClosing = function(iterator2, fn, value, ENTRIES2) {
      try {
        return ENTRIES2 ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (error) {
        var returnMethod = iterator2["return"];
        if (returnMethod !== void 0) anObject(returnMethod.call(iterator2));
        throw error;
      }
    };
    ITERATOR$3 = wellKnownSymbol("iterator");
    ArrayPrototype = Array.prototype;
    isArrayIteratorMethod = function(it2) {
      return it2 !== void 0 && (iterators.Array === it2 || ArrayPrototype[ITERATOR$3] === it2);
    };
    arrayFrom = function from(arrayLike) {
      var O = toObject(arrayLike);
      var C = typeof this == "function" ? this : Array;
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      var iteratorMethod = getIteratorMethod(O);
      var index2 = 0;
      var length2, result, step, iterator2, next3, value;
      if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
      if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
        iterator2 = iteratorMethod.call(O);
        next3 = iterator2.next;
        result = new C();
        for (; !(step = next3.call(iterator2)).done; index2++) {
          value = mapping ? callWithSafeIterationClosing(iterator2, mapfn, [step.value, index2], true) : step.value;
          createProperty(result, index2, value);
        }
      } else {
        length2 = toLength(O.length);
        result = new C(length2);
        for (; length2 > index2; index2++) {
          value = mapping ? mapfn(O[index2], index2) : O[index2];
          createProperty(result, index2, value);
        }
      }
      result.length = index2;
      return result;
    };
    ITERATOR$4 = wellKnownSymbol("iterator");
    SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return {
            done: !!called++
          };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR$4] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    checkCorrectnessOfIteration = function(exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      var ITERATION_SUPPORT = false;
      try {
        var object2 = {};
        object2[ITERATOR$4] = function() {
          return {
            next: function() {
              return {
                done: ITERATION_SUPPORT = true
              };
            }
          };
        };
        exec(object2);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
    INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
      Array.from(iterable);
    });
    _export({
      target: "Array",
      stat: true,
      forced: INCORRECT_ITERATION
    }, {
      from: arrayFrom
    });
    from_1 = path.Array.from;
    from_1$1 = from_1;
    from_1$2 = from_1$1;
    _export({
      target: "Object",
      stat: true,
      sham: !descriptors
    }, {
      create: objectCreate
    });
    Object$1 = path.Object;
    create3 = function create4(P, D) {
      return Object$1.create(P, D);
    };
    create$1 = create3;
    create$2 = create$1;
    defineProperty$5 = defineProperty_1;
    defineProperty$6 = defineProperty$5;
    defineProperty$7 = _defineProperty;
    whitespaces = "	\n\v\f\r \u2028\u2029\uFEFF";
    whitespace = "[" + whitespaces + "]";
    ltrim = RegExp("^" + whitespace + whitespace + "*");
    rtrim = RegExp(whitespace + whitespace + "*$");
    createMethod$3 = function(TYPE) {
      return function($this) {
        var string2 = String(requireObjectCoercible($this));
        if (TYPE & 1) string2 = string2.replace(ltrim, "");
        if (TYPE & 2) string2 = string2.replace(rtrim, "");
        return string2;
      };
    };
    stringTrim = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
      start: createMethod$3(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
      end: createMethod$3(2),
      // `String.prototype.trim` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.trim
      trim: createMethod$3(3)
    };
    non = "";
    stringTrimForced = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
    $trim = stringTrim.trim;
    _export({
      target: "String",
      proto: true,
      forced: stringTrimForced("trim")
    }, {
      trim: function trim() {
        return $trim(this);
      }
    });
    trim2 = entryVirtual("String").trim;
    arrayMethodIsStrict = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          throw 1;
        }, 1);
      });
    };
    defineProperty$8 = Object.defineProperty;
    cache = {};
    thrower = function(it2) {
      throw it2;
    };
    arrayMethodUsesToLength = function(METHOD_NAME, options2) {
      if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
      if (!options2) options2 = {};
      var method = [][METHOD_NAME];
      var ACCESSORS = has(options2, "ACCESSORS") ? options2.ACCESSORS : false;
      var argument0 = has(options2, 0) ? options2[0] : thrower;
      var argument1 = has(options2, 1) ? options2[1] : void 0;
      return cache[METHOD_NAME] = !!method && !fails(function() {
        if (ACCESSORS && !descriptors) return true;
        var O = {
          length: -1
        };
        if (ACCESSORS) defineProperty$8(O, 1, {
          enumerable: true,
          get: thrower
        });
        else O[1] = 1;
        method.call(O, argument0, argument1);
      });
    };
    $forEach$1 = arrayIteration.forEach;
    STRICT_METHOD = arrayMethodIsStrict("forEach");
    USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
    arrayForEach = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn) {
      return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
    _export({
      target: "Array",
      proto: true,
      forced: [].forEach != arrayForEach
    }, {
      forEach: arrayForEach
    });
    forEach2 = entryVirtual("Array").forEach;
    forEach$1 = forEach2;
    ArrayPrototype$1 = Array.prototype;
    DOMIterables = {
      DOMTokenList: true,
      NodeList: true
    };
    forEach_1 = function(it2) {
      var own = it2.forEach;
      return it2 === ArrayPrototype$1 || it2 instanceof Array && own === ArrayPrototype$1.forEach || DOMIterables.hasOwnProperty(classof(it2)) ? forEach$1 : own;
    };
    forEach$2 = forEach_1;
    trim$1 = stringTrim.trim;
    $parseInt = global_1.parseInt;
    hex = /^[+-]?0[Xx]/;
    FORCED$1 = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22;
    numberParseInt = FORCED$1 ? function parseInt2(string2, radix) {
      var S = trim$1(String(string2));
      return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
    } : $parseInt;
    _export({
      global: true,
      forced: parseInt != numberParseInt
    }, {
      parseInt: numberParseInt
    });
    _parseInt = path.parseInt;
    _parseInt$1 = _parseInt;
    _parseInt$2 = _parseInt$1;
    propertyIsEnumerable3 = objectPropertyIsEnumerable.f;
    createMethod$4 = function(TO_ENTRIES) {
      return function(it2) {
        var O = toIndexedObject(it2);
        var keys4 = objectKeys(O);
        var length2 = keys4.length;
        var i = 0;
        var result = [];
        var key;
        while (length2 > i) {
          key = keys4[i++];
          if (!descriptors || propertyIsEnumerable3.call(O, key)) {
            result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
          }
        }
        return result;
      };
    };
    objectToArray = {
      // `Object.entries` method
      // https://tc39.github.io/ecma262/#sec-object.entries
      entries: createMethod$4(true),
      // `Object.values` method
      // https://tc39.github.io/ecma262/#sec-object.values
      values: createMethod$4(false)
    };
    $values = objectToArray.values;
    _export({
      target: "Object",
      stat: true
    }, {
      values: function values(O) {
        return $values(O);
      }
    });
    values2 = path.Object.values;
    engineUserAgent = getBuiltIn("navigator", "userAgent") || "";
    process2 = global_1.process;
    versions = process2 && process2.versions;
    v8 = versions && versions.v8;
    if (v8) {
      match = v8.split(".");
      version = match[0] + match[1];
    } else if (engineUserAgent) {
      match = engineUserAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = engineUserAgent.match(/Chrome\/(\d+)/);
        if (match) version = match[1];
      }
    }
    engineV8Version = version && +version;
    SPECIES$1 = wellKnownSymbol("species");
    arrayMethodHasSpeciesSupport = function(METHOD_NAME) {
      return engineV8Version >= 51 || !fails(function() {
        var array2 = [];
        var constructor = array2.constructor = {};
        constructor[SPECIES$1] = function() {
          return {
            foo: 1
          };
        };
        return array2[METHOD_NAME](Boolean).foo !== 1;
      });
    };
    $filter = arrayIteration.filter;
    HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
    USES_TO_LENGTH$1 = arrayMethodUsesToLength("filter");
    _export({
      target: "Array",
      proto: true,
      forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$1
    }, {
      filter: function filter(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    filter2 = entryVirtual("Array").filter;
    ArrayPrototype$2 = Array.prototype;
    filter_1 = function(it2) {
      var own = it2.filter;
      return it2 === ArrayPrototype$2 || it2 instanceof Array && own === ArrayPrototype$2.filter ? filter2 : own;
    };
    filter$1 = filter_1;
    filter$2 = filter$1;
    FAILS_ON_PRIMITIVES$1 = fails(function() {
      objectGetPrototypeOf(1);
    });
    _export({
      target: "Object",
      stat: true,
      forced: FAILS_ON_PRIMITIVES$1,
      sham: !correctPrototypeGetter
    }, {
      getPrototypeOf: function getPrototypeOf(it2) {
        return objectGetPrototypeOf(toObject(it2));
      }
    });
    getPrototypeOf2 = path.Object.getPrototypeOf;
    getPrototypeOf$1 = getPrototypeOf2;
    getPrototypeOf$2 = getPrototypeOf$1;
    $indexOf = arrayIncludes.indexOf;
    nativeIndexOf = [].indexOf;
    NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
    STRICT_METHOD$1 = arrayMethodIsStrict("indexOf");
    USES_TO_LENGTH$2 = arrayMethodUsesToLength("indexOf", {
      ACCESSORS: true,
      1: 0
    });
    _export({
      target: "Array",
      proto: true,
      forced: NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$2
    }, {
      indexOf: function indexOf2(searchElement) {
        return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    indexOf$1 = entryVirtual("Array").indexOf;
    ArrayPrototype$3 = Array.prototype;
    indexOf_1 = function(it2) {
      var own = it2.indexOf;
      return it2 === ArrayPrototype$3 || it2 instanceof Array && own === ArrayPrototype$3.indexOf ? indexOf$1 : own;
    };
    indexOf$2 = indexOf_1;
    indexOf$3 = indexOf$2;
    _export({
      target: "Array",
      stat: true
    }, {
      isArray
    });
    isArray$1 = path.Array.isArray;
    isArray$2 = isArray$1;
    isArray$3 = isArray$2;
    arrayWithHoles = _arrayWithHoles;
    ITERATOR$5 = wellKnownSymbol("iterator");
    isIterable = function(it2) {
      var O = Object(it2);
      return O[ITERATOR$5] !== void 0 || "@@iterator" in O || iterators.hasOwnProperty(classof(O));
    };
    isIterable_1 = isIterable;
    isIterable$1 = isIterable_1;
    IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    MAX_SAFE_INTEGER = 9007199254740991;
    MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
    IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function() {
      var array2 = [];
      array2[IS_CONCAT_SPREADABLE] = false;
      return array2.concat()[0] !== array2;
    });
    SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
    isConcatSpreadable = function(O) {
      if (!isObject(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray(O);
    };
    FORCED$2 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
    _export({
      target: "Array",
      proto: true,
      forced: FORCED$2
    }, {
      concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length2, len, E;
        for (i = -1, length2 = arguments.length; i < length2; i++) {
          E = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E)) {
            len = toLength(E.length);
            if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
          } else {
            if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });
    defineWellKnownSymbol("asyncIterator");
    defineWellKnownSymbol("hasInstance");
    defineWellKnownSymbol("isConcatSpreadable");
    defineWellKnownSymbol("iterator");
    defineWellKnownSymbol("match");
    defineWellKnownSymbol("matchAll");
    defineWellKnownSymbol("replace");
    defineWellKnownSymbol("search");
    defineWellKnownSymbol("species");
    defineWellKnownSymbol("split");
    defineWellKnownSymbol("toPrimitive");
    defineWellKnownSymbol("toStringTag");
    defineWellKnownSymbol("unscopables");
    setToStringTag(Math, "Math", true);
    setToStringTag(global_1.JSON, "JSON", true);
    symbol = path.Symbol;
    defineWellKnownSymbol("asyncDispose");
    defineWellKnownSymbol("dispose");
    defineWellKnownSymbol("observable");
    defineWellKnownSymbol("patternMatch");
    defineWellKnownSymbol("replaceAll");
    symbol$1 = symbol;
    symbol$2 = symbol$1;
    iterableToArrayLimit = _iterableToArrayLimit;
    from_1$3 = from_1;
    from_1$4 = from_1$3;
    HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport("slice");
    USES_TO_LENGTH$3 = arrayMethodUsesToLength("slice", {
      ACCESSORS: true,
      0: 0,
      1: 2
    });
    SPECIES$2 = wellKnownSymbol("species");
    nativeSlice = [].slice;
    max$1 = Math.max;
    _export({
      target: "Array",
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$3
    }, {
      slice: function slice2(start, end) {
        var O = toIndexedObject(this);
        var length2 = toLength(O.length);
        var k = toAbsoluteIndex(start, length2);
        var fin = toAbsoluteIndex(end === void 0 ? length2 : end, length2);
        var Constructor, result, n;
        if (isArray(O)) {
          Constructor = O.constructor;
          if (typeof Constructor == "function" && (Constructor === Array || isArray(Constructor.prototype))) {
            Constructor = void 0;
          } else if (isObject(Constructor)) {
            Constructor = Constructor[SPECIES$2];
            if (Constructor === null) Constructor = void 0;
          }
          if (Constructor === Array || Constructor === void 0) {
            return nativeSlice.call(O, k, fin);
          }
        }
        result = new (Constructor === void 0 ? Array : Constructor)(max$1(fin - k, 0));
        for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
        result.length = n;
        return result;
      }
    });
    slice$1 = entryVirtual("Array").slice;
    ArrayPrototype$4 = Array.prototype;
    slice_1 = function(it2) {
      var own = it2.slice;
      return it2 === ArrayPrototype$4 || it2 instanceof Array && own === ArrayPrototype$4.slice ? slice$1 : own;
    };
    slice$2 = slice_1;
    slice$3 = slice$2;
    arrayLikeToArray = _arrayLikeToArray;
    unsupportedIterableToArray = _unsupportedIterableToArray;
    nonIterableRest = _nonIterableRest;
    slicedToArray = _slicedToArray;
    _export({
      target: "Date",
      stat: true
    }, {
      now: function now() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
    });
    now2 = path.Date.now;
    now$1 = now2;
    now$2 = now$1;
    FAILS_ON_PRIMITIVES$2 = fails(function() {
      objectKeys(1);
    });
    _export({
      target: "Object",
      stat: true,
      forced: FAILS_ON_PRIMITIVES$2
    }, {
      keys: function keys3(it2) {
        return objectKeys(toObject(it2));
      }
    });
    keys$1 = path.Object.keys;
    keys$2 = keys$1;
    keys$3 = keys$2;
    $map = arrayIteration.map;
    HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport("map");
    USES_TO_LENGTH$4 = arrayMethodUsesToLength("map");
    _export({
      target: "Array",
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$4
    }, {
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    map2 = entryVirtual("Array").map;
    ArrayPrototype$5 = Array.prototype;
    map_1 = function(it2) {
      var own = it2.map;
      return it2 === ArrayPrototype$5 || it2 instanceof Array && own === ArrayPrototype$5.map ? map2 : own;
    };
    map$1 = map_1;
    map$2 = map$1;
    isArray$4 = isArray$1;
    isArray$5 = isArray$4;
    iterator = wellKnownSymbolWrapped.f("iterator");
    iterator$1 = iterator;
    iterator$2 = iterator$1;
    _typeof_1 = createCommonjsModule(function(module) {
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof symbol$2 === "function" && typeof iterator$2 === "symbol") {
          module.exports = _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          module.exports = _typeof = function _typeof2(obj2) {
            return obj2 && typeof symbol$2 === "function" && obj2.constructor === symbol$2 && obj2 !== symbol$2.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      module.exports = _typeof;
    });
    _export({
      target: "Reflect",
      stat: true
    }, {
      ownKeys
    });
    ownKeys$1 = path.Reflect.ownKeys;
    ownKeys$2 = ownKeys$1;
    ownKeys$3 = ownKeys$2;
    slice$4 = slice_1;
    slice$5 = slice$4;
    arrayWithoutHoles = _arrayWithoutHoles;
    iterableToArray = _iterableToArray;
    nonIterableSpread = _nonIterableSpread;
    toConsumableArray = _toConsumableArray;
    concat2 = entryVirtual("Array").concat;
    ArrayPrototype$6 = Array.prototype;
    concat_1 = function(it2) {
      var own = it2.concat;
      return it2 === ArrayPrototype$6 || it2 instanceof Array && own === ArrayPrototype$6.concat ? concat2 : own;
    };
    concat$1 = concat_1;
    concat$2 = concat$1;
    symbol$3 = symbol;
    symbol$4 = symbol$3;
    DELETE = symbol$4("DELETE");
    fullHexRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    shortHexRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    rgbRE = /^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i;
    rgbaRE = /^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;
    easingFunctions = {
      /**
       * Provides no easing and no acceleration.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      linear: function linear(t) {
        return t;
      },
      /**
       * Accelerate from zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInQuad: function easeInQuad(t) {
        return t * t;
      },
      /**
       * Decelerate to zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeOutQuad: function easeOutQuad(t) {
        return t * (2 - t);
      },
      /**
       * Accelerate until halfway, then decelerate.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInOutQuad: function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      },
      /**
       * Accelerate from zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInCubic: function easeInCubic(t) {
        return t * t * t;
      },
      /**
       * Decelerate to zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeOutCubic: function easeOutCubic(t) {
        return --t * t * t + 1;
      },
      /**
       * Accelerate until halfway, then decelerate.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInOutCubic: function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
      },
      /**
       * Accelerate from zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInQuart: function easeInQuart(t) {
        return t * t * t * t;
      },
      /**
       * Decelerate to zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeOutQuart: function easeOutQuart(t) {
        return 1 - --t * t * t * t;
      },
      /**
       * Accelerate until halfway, then decelerate.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInOutQuart: function easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
      },
      /**
       * Accelerate from zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInQuint: function easeInQuint(t) {
        return t * t * t * t * t;
      },
      /**
       * Decelerate to zero velocity.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeOutQuint: function easeOutQuint(t) {
        return 1 + --t * t * t * t * t;
      },
      /**
       * Accelerate until halfway, then decelerate.
       *
       * @param t - Time.
       *
       * @returns Value at time t.
       */
      easeInOutQuint: function easeInOutQuint(t) {
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
      }
    };
    HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport("splice");
    USES_TO_LENGTH$5 = arrayMethodUsesToLength("splice", {
      ACCESSORS: true,
      0: 0,
      1: 2
    });
    max$2 = Math.max;
    min$2 = Math.min;
    MAX_SAFE_INTEGER$1 = 9007199254740991;
    MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
    _export({
      target: "Array",
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$5
    }, {
      splice: function splice(start, deleteCount) {
        var O = toObject(this);
        var len = toLength(O.length);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from2, to;
        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min$2(max$2(toInteger(deleteCount), 0), len - actualStart);
        }
        if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
          throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
        }
        A = arraySpeciesCreate(O, actualDeleteCount);
        for (k = 0; k < actualDeleteCount; k++) {
          from2 = actualStart + k;
          if (from2 in O) createProperty(A, k, O[from2]);
        }
        A.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
          for (k = actualStart; k < len - actualDeleteCount; k++) {
            from2 = k + actualDeleteCount;
            to = k + insertCount;
            if (from2 in O) O[to] = O[from2];
            else delete O[to];
          }
          for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
        } else if (insertCount > actualDeleteCount) {
          for (k = len - actualDeleteCount; k > actualStart; k--) {
            from2 = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from2 in O) O[to] = O[from2];
            else delete O[to];
          }
        }
        for (k = 0; k < insertCount; k++) {
          O[k + actualStart] = arguments[k + 2];
        }
        O.length = len - actualDeleteCount + insertCount;
        return A;
      }
    });
    splice2 = entryVirtual("Array").splice;
    ArrayPrototype$7 = Array.prototype;
    splice_1 = function(it2) {
      var own = it2.splice;
      return it2 === ArrayPrototype$7 || it2 instanceof Array && own === ArrayPrototype$7.splice ? splice2 : own;
    };
    splice$1 = splice_1;
    splice$2 = splice$1;
    $includes = arrayIncludes.includes;
    USES_TO_LENGTH$6 = arrayMethodUsesToLength("indexOf", {
      ACCESSORS: true,
      1: 0
    });
    _export({
      target: "Array",
      proto: true,
      forced: !USES_TO_LENGTH$6
    }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    includes2 = entryVirtual("Array").includes;
    MATCH = wellKnownSymbol("match");
    isRegexp = function(it2) {
      var isRegExp;
      return isObject(it2) && ((isRegExp = it2[MATCH]) !== void 0 ? !!isRegExp : classofRaw(it2) == "RegExp");
    };
    notARegexp = function(it2) {
      if (isRegexp(it2)) {
        throw TypeError("The method doesn't accept regular expressions");
      }
      return it2;
    };
    MATCH$1 = wellKnownSymbol("match");
    correctIsRegexpLogic = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (e) {
        try {
          regexp[MATCH$1] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (f2) {
        }
      }
      return false;
    };
    _export({
      target: "String",
      proto: true,
      forced: !correctIsRegexpLogic("includes")
    }, {
      includes: function includes3(searchString) {
        return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    includes$1 = entryVirtual("String").includes;
    ArrayPrototype$8 = Array.prototype;
    StringPrototype = String.prototype;
    includes$2 = function(it2) {
      var own = it2.includes;
      if (it2 === ArrayPrototype$8 || it2 instanceof Array && own === ArrayPrototype$8.includes) return includes2;
      if (typeof it2 === "string" || it2 === StringPrototype || it2 instanceof String && own === StringPrototype.includes) {
        return includes$1;
      }
      return own;
    };
    includes$3 = includes$2;
    includes$4 = includes$3;
    NODE_ATTR_MAPPING = {
      "fontsize": "font.size",
      "fontcolor": "font.color",
      "labelfontcolor": "font.color",
      "fontname": "font.face",
      "color": ["color.border", "color.background"],
      "fillcolor": "color.background",
      "tooltip": "title",
      "labeltooltip": "title"
    };
    EDGE_ATTR_MAPPING = create$2(NODE_ATTR_MAPPING);
    EDGE_ATTR_MAPPING.color = "color.color";
    EDGE_ATTR_MAPPING.style = "dashes";
    TOKENTYPE = {
      NULL: 0,
      DELIMITER: 1,
      IDENTIFIER: 2,
      UNKNOWN: 3
    };
    DELIMITERS = {
      "{": true,
      "}": true,
      "[": true,
      "]": true,
      ";": true,
      "=": true,
      ",": true,
      "->": true,
      "--": true
    };
    dot = "";
    index = 0;
    c = "";
    token = "";
    tokenType = TOKENTYPE.NULL;
    regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;
    dotparser = Object.freeze({
      __proto__: null,
      parseDOT,
      DOTToGraph
    });
    gephiParser = Object.freeze({
      __proto__: null,
      parseGephi
    });
    css_248z = ".vis-overlay {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n\n  /* Must be displayed above for example selected Timeline items */\n  z-index: 10;\n}\n\n.vis-active {\n  box-shadow: 0 0 10px #86d5f8;\n}\n";
    styleInject(css_248z);
    keycharm = createCommonjsModule(function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory();
        }
      })(commonjsGlobal, function() {
        function keycharm2(options2) {
          var preventDefault = options2 && options2.preventDefault || false;
          var container = options2 && options2.container || window;
          var _exportFunctions = {};
          var _bound = {
            keydown: {},
            keyup: {}
          };
          var _keys = {};
          var i;
          for (i = 97; i <= 122; i++) {
            _keys[String.fromCharCode(i)] = {
              code: 65 + (i - 97),
              shift: false
            };
          }
          for (i = 65; i <= 90; i++) {
            _keys[String.fromCharCode(i)] = {
              code: i,
              shift: true
            };
          }
          for (i = 0; i <= 9; i++) {
            _keys["" + i] = {
              code: 48 + i,
              shift: false
            };
          }
          for (i = 1; i <= 12; i++) {
            _keys["F" + i] = {
              code: 111 + i,
              shift: false
            };
          }
          for (i = 0; i <= 9; i++) {
            _keys["num" + i] = {
              code: 96 + i,
              shift: false
            };
          }
          _keys["num*"] = {
            code: 106,
            shift: false
          };
          _keys["num+"] = {
            code: 107,
            shift: false
          };
          _keys["num-"] = {
            code: 109,
            shift: false
          };
          _keys["num/"] = {
            code: 111,
            shift: false
          };
          _keys["num."] = {
            code: 110,
            shift: false
          };
          _keys["left"] = {
            code: 37,
            shift: false
          };
          _keys["up"] = {
            code: 38,
            shift: false
          };
          _keys["right"] = {
            code: 39,
            shift: false
          };
          _keys["down"] = {
            code: 40,
            shift: false
          };
          _keys["space"] = {
            code: 32,
            shift: false
          };
          _keys["enter"] = {
            code: 13,
            shift: false
          };
          _keys["shift"] = {
            code: 16,
            shift: void 0
          };
          _keys["esc"] = {
            code: 27,
            shift: false
          };
          _keys["backspace"] = {
            code: 8,
            shift: false
          };
          _keys["tab"] = {
            code: 9,
            shift: false
          };
          _keys["ctrl"] = {
            code: 17,
            shift: false
          };
          _keys["alt"] = {
            code: 18,
            shift: false
          };
          _keys["delete"] = {
            code: 46,
            shift: false
          };
          _keys["pageup"] = {
            code: 33,
            shift: false
          };
          _keys["pagedown"] = {
            code: 34,
            shift: false
          };
          _keys["="] = {
            code: 187,
            shift: false
          };
          _keys["-"] = {
            code: 189,
            shift: false
          };
          _keys["]"] = {
            code: 221,
            shift: false
          };
          _keys["["] = {
            code: 219,
            shift: false
          };
          var down = function(event) {
            handleEvent(event, "keydown");
          };
          var up = function(event) {
            handleEvent(event, "keyup");
          };
          var handleEvent = function(event, type) {
            if (_bound[type][event.keyCode] !== void 0) {
              var bound = _bound[type][event.keyCode];
              for (var i2 = 0; i2 < bound.length; i2++) {
                if (bound[i2].shift === void 0) {
                  bound[i2].fn(event);
                } else if (bound[i2].shift == true && event.shiftKey == true) {
                  bound[i2].fn(event);
                } else if (bound[i2].shift == false && event.shiftKey == false) {
                  bound[i2].fn(event);
                }
              }
              if (preventDefault == true) {
                event.preventDefault();
              }
            }
          };
          _exportFunctions.bind = function(key, callback, type) {
            if (type === void 0) {
              type = "keydown";
            }
            if (_keys[key] === void 0) {
              throw new Error("unsupported key: " + key);
            }
            if (_bound[type][_keys[key].code] === void 0) {
              _bound[type][_keys[key].code] = [];
            }
            _bound[type][_keys[key].code].push({
              fn: callback,
              shift: _keys[key].shift
            });
          };
          _exportFunctions.bindAll = function(callback, type) {
            if (type === void 0) {
              type = "keydown";
            }
            for (var key in _keys) {
              if (_keys.hasOwnProperty(key)) {
                _exportFunctions.bind(key, callback, type);
              }
            }
          };
          _exportFunctions.getKey = function(event) {
            for (var key in _keys) {
              if (_keys.hasOwnProperty(key)) {
                if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
                  return key;
                } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
                  return key;
                } else if (event.keyCode == _keys[key].code && key == "shift") {
                  return key;
                }
              }
            }
            return "unknown key, currently not supported";
          };
          _exportFunctions.unbind = function(key, callback, type) {
            if (type === void 0) {
              type = "keydown";
            }
            if (_keys[key] === void 0) {
              throw new Error("unsupported key: " + key);
            }
            if (callback !== void 0) {
              var newBindings = [];
              var bound = _bound[type][_keys[key].code];
              if (bound !== void 0) {
                for (var i2 = 0; i2 < bound.length; i2++) {
                  if (!(bound[i2].fn == callback && bound[i2].shift == _keys[key].shift)) {
                    newBindings.push(_bound[type][_keys[key].code][i2]);
                  }
                }
              }
              _bound[type][_keys[key].code] = newBindings;
            } else {
              _bound[type][_keys[key].code] = [];
            }
          };
          _exportFunctions.reset = function() {
            _bound = {
              keydown: {},
              keyup: {}
            };
          };
          _exportFunctions.destroy = function() {
            _bound = {
              keydown: {},
              keyup: {}
            };
            container.removeEventListener("keydown", down, true);
            container.removeEventListener("keyup", up, true);
          };
          container.addEventListener("keydown", down, true);
          container.addEventListener("keyup", up, true);
          return _exportFunctions;
        }
        return keycharm2;
      });
    });
    if (typeof Object.assign !== "function") {
      assign$3 = function assign3(target) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        for (var index2 = 1; index2 < arguments.length; index2++) {
          var source = arguments[index2];
          if (source !== void 0 && source !== null) {
            for (var nextKey in source) {
              if (source.hasOwnProperty(nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }
        return output;
      };
    } else {
      assign$3 = Object.assign;
    }
    assign$1$1 = assign$3;
    VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
    TEST_ELEMENT = typeof document === "undefined" ? {
      style: {}
    } : document.createElement("div");
    TYPE_FUNCTION = "function";
    round = Math.round;
    abs = Math.abs;
    now$3 = Date.now;
    if (typeof window === "undefined") {
      win = {};
    } else {
      win = window;
    }
    PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== void 0;
    TOUCH_ACTION_COMPUTE = "compute";
    TOUCH_ACTION_AUTO = "auto";
    TOUCH_ACTION_MANIPULATION = "manipulation";
    TOUCH_ACTION_NONE = "none";
    TOUCH_ACTION_PAN_X = "pan-x";
    TOUCH_ACTION_PAN_Y = "pan-y";
    TOUCH_ACTION_MAP = getTouchActionProps();
    MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    SUPPORT_TOUCH = "ontouchstart" in win;
    SUPPORT_POINTER_EVENTS = prefixed(win, "PointerEvent") !== void 0;
    SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    INPUT_TYPE_TOUCH = "touch";
    INPUT_TYPE_PEN = "pen";
    INPUT_TYPE_MOUSE = "mouse";
    INPUT_TYPE_KINECT = "kinect";
    COMPUTE_INTERVAL = 25;
    INPUT_START = 1;
    INPUT_MOVE = 2;
    INPUT_END = 4;
    INPUT_CANCEL = 8;
    DIRECTION_NONE = 1;
    DIRECTION_LEFT = 2;
    DIRECTION_RIGHT = 4;
    DIRECTION_UP = 8;
    DIRECTION_DOWN = 16;
    DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    PROPS_XY = ["x", "y"];
    PROPS_CLIENT_XY = ["clientX", "clientY"];
    TouchAction = function() {
      function TouchAction2(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      var _proto = TouchAction2.prototype;
      _proto.set = function set2(value) {
        if (value === TOUCH_ACTION_COMPUTE) {
          value = this.compute();
        }
        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
          this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
      };
      _proto.update = function update() {
        this.set(this.manager.options.touchAction);
      };
      _proto.compute = function compute() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
          if (boolOrFn(recognizer.options.enable, [recognizer])) {
            actions = actions.concat(recognizer.getTouchAction());
          }
        });
        return cleanTouchActions(actions.join(" "));
      };
      _proto.preventDefaults = function preventDefaults(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;
        if (this.manager.session.prevented) {
          srcEvent.preventDefault();
          return;
        }
        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
        if (hasNone) {
          var isTapPointer = input.pointers.length === 1;
          var isTapMovement = input.distance < 2;
          var isTapTouchTime = input.deltaTime < 250;
          if (isTapPointer && isTapMovement && isTapTouchTime) {
            return;
          }
        }
        if (hasPanX && hasPanY) {
          return;
        }
        if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
          return this.preventSrc(srcEvent);
        }
      };
      _proto.preventSrc = function preventSrc(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
      };
      return TouchAction2;
    }();
    Input = function() {
      function Input2(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      var _proto = Input2.prototype;
      _proto.handler = function handler() {
      };
      _proto.init = function init() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      };
      _proto.destroy = function destroy() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      };
      return Input2;
    }();
    POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
    };
    IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT
      // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    POINTER_ELEMENT_EVENTS = "pointerdown";
    POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    if (win.MSPointerEvent && !win.PointerEvent) {
      POINTER_ELEMENT_EVENTS = "MSPointerDown";
      POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    PointerEventInput = function(_Input) {
      _inheritsLoose(PointerEventInput2, _Input);
      function PointerEventInput2() {
        var _this;
        var proto = PointerEventInput2.prototype;
        proto.evEl = POINTER_ELEMENT_EVENTS;
        proto.evWin = POINTER_WINDOW_EVENTS;
        _this = _Input.apply(this, arguments) || this;
        _this.store = _this.manager.session.pointerEvents = [];
        return _this;
      }
      var _proto = PointerEventInput2.prototype;
      _proto.handler = function handler(ev) {
        var store2 = this.store;
        var removePointer = false;
        var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
        var isTouch = pointerType === INPUT_TYPE_TOUCH;
        var storeIndex = inArray(store2, ev.pointerId, "pointerId");
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
          if (storeIndex < 0) {
            store2.push(ev);
            storeIndex = store2.length - 1;
          }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          removePointer = true;
        }
        if (storeIndex < 0) {
          return;
        }
        store2[storeIndex] = ev;
        this.callback(this.manager, eventType, {
          pointers: store2,
          changedPointers: [ev],
          pointerType,
          srcEvent: ev
        });
        if (removePointer) {
          store2.splice(storeIndex, 1);
        }
      };
      return PointerEventInput2;
    }(Input);
    TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
    };
    TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    TouchInput = function(_Input) {
      _inheritsLoose(TouchInput2, _Input);
      function TouchInput2() {
        var _this;
        TouchInput2.prototype.evTarget = TOUCH_TARGET_EVENTS;
        _this = _Input.apply(this, arguments) || this;
        _this.targetIds = {};
        return _this;
      }
      var _proto = TouchInput2.prototype;
      _proto.handler = function handler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
          return;
        }
        this.callback(this.manager, type, {
          pointers: touches[0],
          changedPointers: touches[1],
          pointerType: INPUT_TYPE_TOUCH,
          srcEvent: ev
        });
      };
      return TouchInput2;
    }(Input);
    MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
    };
    MOUSE_ELEMENT_EVENTS = "mousedown";
    MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    MouseInput = function(_Input) {
      _inheritsLoose(MouseInput2, _Input);
      function MouseInput2() {
        var _this;
        var proto = MouseInput2.prototype;
        proto.evEl = MOUSE_ELEMENT_EVENTS;
        proto.evWin = MOUSE_WINDOW_EVENTS;
        _this = _Input.apply(this, arguments) || this;
        _this.pressed = false;
        return _this;
      }
      var _proto = MouseInput2.prototype;
      _proto.handler = function handler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];
        if (eventType & INPUT_START && ev.button === 0) {
          this.pressed = true;
        }
        if (eventType & INPUT_MOVE && ev.which !== 1) {
          eventType = INPUT_END;
        }
        if (!this.pressed) {
          return;
        }
        if (eventType & INPUT_END) {
          this.pressed = false;
        }
        this.callback(this.manager, eventType, {
          pointers: [ev],
          changedPointers: [ev],
          pointerType: INPUT_TYPE_MOUSE,
          srcEvent: ev
        });
      };
      return MouseInput2;
    }(Input);
    DEDUP_TIMEOUT = 2500;
    DEDUP_DISTANCE = 25;
    TouchMouseInput = function() {
      var TouchMouseInput2 = function(_Input) {
        _inheritsLoose(TouchMouseInput3, _Input);
        function TouchMouseInput3(_manager, callback) {
          var _this;
          _this = _Input.call(this, _manager, callback) || this;
          _this.handler = function(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
            var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {
              return;
            }
            _this.callback(manager, inputEvent, inputData);
          };
          _this.touch = new TouchInput(_this.manager, _this.handler);
          _this.mouse = new MouseInput(_this.manager, _this.handler);
          _this.primaryTouch = null;
          _this.lastTouches = [];
          return _this;
        }
        var _proto = TouchMouseInput3.prototype;
        _proto.destroy = function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        };
        return TouchMouseInput3;
      }(Input);
      return TouchMouseInput2;
    }();
    STATE_POSSIBLE = 1;
    STATE_BEGAN = 2;
    STATE_CHANGED = 4;
    STATE_ENDED = 8;
    STATE_RECOGNIZED = STATE_ENDED;
    STATE_CANCELLED = 16;
    STATE_FAILED = 32;
    _uniqueId = 1;
    Recognizer = function() {
      function Recognizer2(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        this.options = _extends({
          enable: true
        }, options2);
        this.id = uniqueId();
        this.manager = null;
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      var _proto = Recognizer2.prototype;
      _proto.set = function set2(options2) {
        assign$1$1(this.options, options2);
        this.manager && this.manager.touchAction.update();
        return this;
      };
      _proto.recognizeWith = function recognizeWith(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
          return this;
        }
        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
          simultaneous[otherRecognizer.id] = otherRecognizer;
          otherRecognizer.recognizeWith(this);
        }
        return this;
      };
      _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
          return this;
        }
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
      };
      _proto.requireFailure = function requireFailure(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
          return this;
        }
        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
          requireFail.push(otherRecognizer);
          otherRecognizer.requireFailure(this);
        }
        return this;
      };
      _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
          return this;
        }
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index2 = inArray(this.requireFail, otherRecognizer);
        if (index2 > -1) {
          this.requireFail.splice(index2, 1);
        }
        return this;
      };
      _proto.hasRequireFailures = function hasRequireFailures() {
        return this.requireFail.length > 0;
      };
      _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
      };
      _proto.emit = function emit(input) {
        var self2 = this;
        var state = this.state;
        function emit2(event) {
          self2.manager.emit(event, input);
        }
        if (state < STATE_ENDED) {
          emit2(self2.options.event + stateStr(state));
        }
        emit2(self2.options.event);
        if (input.additionalEvent) {
          emit2(input.additionalEvent);
        }
        if (state >= STATE_ENDED) {
          emit2(self2.options.event + stateStr(state));
        }
      };
      _proto.tryEmit = function tryEmit(input) {
        if (this.canEmit()) {
          return this.emit(input);
        }
        this.state = STATE_FAILED;
      };
      _proto.canEmit = function canEmit() {
        var i = 0;
        while (i < this.requireFail.length) {
          if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
            return false;
          }
          i++;
        }
        return true;
      };
      _proto.recognize = function recognize(inputData) {
        var inputDataClone = assign$1$1({}, inputData);
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
          this.reset();
          this.state = STATE_FAILED;
          return;
        }
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
          this.state = STATE_POSSIBLE;
        }
        this.state = this.process(inputDataClone);
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
          this.tryEmit(inputDataClone);
        }
      };
      _proto.process = function process3(inputData) {
      };
      _proto.getTouchAction = function getTouchAction() {
      };
      _proto.reset = function reset() {
      };
      return Recognizer2;
    }();
    TapRecognizer = function(_Recognizer) {
      _inheritsLoose(TapRecognizer2, _Recognizer);
      function TapRecognizer2(options2) {
        var _this;
        if (options2 === void 0) {
          options2 = {};
        }
        _this = _Recognizer.call(this, _extends({
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
        }, options2)) || this;
        _this.pTime = false;
        _this.pCenter = false;
        _this._timer = null;
        _this._input = null;
        _this.count = 0;
        return _this;
      }
      var _proto = TapRecognizer2.prototype;
      _proto.getTouchAction = function getTouchAction() {
        return [TOUCH_ACTION_MANIPULATION];
      };
      _proto.process = function process3(input) {
        var _this2 = this;
        var options2 = this.options;
        var validPointers = input.pointers.length === options2.pointers;
        var validMovement = input.distance < options2.threshold;
        var validTouchTime = input.deltaTime < options2.time;
        this.reset();
        if (input.eventType & INPUT_START && this.count === 0) {
          return this.failTimeout();
        }
        if (validMovement && validTouchTime && validPointers) {
          if (input.eventType !== INPUT_END) {
            return this.failTimeout();
          }
          var validInterval = this.pTime ? input.timeStamp - this.pTime < options2.interval : true;
          var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options2.posThreshold;
          this.pTime = input.timeStamp;
          this.pCenter = input.center;
          if (!validMultiTap || !validInterval) {
            this.count = 1;
          } else {
            this.count += 1;
          }
          this._input = input;
          var tapCount = this.count % options2.taps;
          if (tapCount === 0) {
            if (!this.hasRequireFailures()) {
              return STATE_RECOGNIZED;
            } else {
              this._timer = setTimeout(function() {
                _this2.state = STATE_RECOGNIZED;
                _this2.tryEmit();
              }, options2.interval);
              return STATE_BEGAN;
            }
          }
        }
        return STATE_FAILED;
      };
      _proto.failTimeout = function failTimeout() {
        var _this3 = this;
        this._timer = setTimeout(function() {
          _this3.state = STATE_FAILED;
        }, this.options.interval);
        return STATE_FAILED;
      };
      _proto.reset = function reset() {
        clearTimeout(this._timer);
      };
      _proto.emit = function emit() {
        if (this.state === STATE_RECOGNIZED) {
          this._input.tapCount = this.count;
          this.manager.emit(this.options.event, this._input);
        }
      };
      return TapRecognizer2;
    }(Recognizer);
    AttrRecognizer = function(_Recognizer) {
      _inheritsLoose(AttrRecognizer2, _Recognizer);
      function AttrRecognizer2(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return _Recognizer.call(this, _extends({
          pointers: 1
        }, options2)) || this;
      }
      var _proto = AttrRecognizer2.prototype;
      _proto.attrTest = function attrTest(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
      };
      _proto.process = function process3(input) {
        var state = this.state;
        var eventType = input.eventType;
        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
          return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
          if (eventType & INPUT_END) {
            return state | STATE_ENDED;
          } else if (!(state & STATE_BEGAN)) {
            return STATE_BEGAN;
          }
          return state | STATE_CHANGED;
        }
        return STATE_FAILED;
      };
      return AttrRecognizer2;
    }(Recognizer);
    PanRecognizer = function(_AttrRecognizer) {
      _inheritsLoose(PanRecognizer2, _AttrRecognizer);
      function PanRecognizer2(options2) {
        var _this;
        if (options2 === void 0) {
          options2 = {};
        }
        _this = _AttrRecognizer.call(this, _extends({
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        }, options2)) || this;
        _this.pX = null;
        _this.pY = null;
        return _this;
      }
      var _proto = PanRecognizer2.prototype;
      _proto.getTouchAction = function getTouchAction() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
          actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
          actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
      };
      _proto.directionTest = function directionTest(input) {
        var options2 = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;
        if (!(direction & options2.direction)) {
          if (options2.direction & DIRECTION_HORIZONTAL) {
            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            hasMoved = x !== this.pX;
            distance = Math.abs(input.deltaX);
          } else {
            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
            hasMoved = y !== this.pY;
            distance = Math.abs(input.deltaY);
          }
        }
        input.direction = direction;
        return hasMoved && distance > options2.threshold && direction & options2.direction;
      };
      _proto.attrTest = function attrTest(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call
        (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
      };
      _proto.emit = function emit(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;
        var direction = directionStr(input.direction);
        if (direction) {
          input.additionalEvent = this.options.event + direction;
        }
        _AttrRecognizer.prototype.emit.call(this, input);
      };
      return PanRecognizer2;
    }(AttrRecognizer);
    SwipeRecognizer = function(_AttrRecognizer) {
      _inheritsLoose(SwipeRecognizer2, _AttrRecognizer);
      function SwipeRecognizer2(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return _AttrRecognizer.call(this, _extends({
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        }, options2)) || this;
      }
      var _proto = SwipeRecognizer2.prototype;
      _proto.getTouchAction = function getTouchAction() {
        return PanRecognizer.prototype.getTouchAction.call(this);
      };
      _proto.attrTest = function attrTest(input) {
        var direction = this.options.direction;
        var velocity;
        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
          velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
          velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
          velocity = input.overallVelocityY;
        }
        return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      };
      _proto.emit = function emit(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
          this.manager.emit(this.options.event + direction, input);
        }
        this.manager.emit(this.options.event, input);
      };
      return SwipeRecognizer2;
    }(AttrRecognizer);
    PinchRecognizer = function(_AttrRecognizer) {
      _inheritsLoose(PinchRecognizer2, _AttrRecognizer);
      function PinchRecognizer2(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return _AttrRecognizer.call(this, _extends({
          event: "pinch",
          threshold: 0,
          pointers: 2
        }, options2)) || this;
      }
      var _proto = PinchRecognizer2.prototype;
      _proto.getTouchAction = function getTouchAction() {
        return [TOUCH_ACTION_NONE];
      };
      _proto.attrTest = function attrTest(input) {
        return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      };
      _proto.emit = function emit(input) {
        if (input.scale !== 1) {
          var inOut = input.scale < 1 ? "in" : "out";
          input.additionalEvent = this.options.event + inOut;
        }
        _AttrRecognizer.prototype.emit.call(this, input);
      };
      return PinchRecognizer2;
    }(AttrRecognizer);
    RotateRecognizer = function(_AttrRecognizer) {
      _inheritsLoose(RotateRecognizer2, _AttrRecognizer);
      function RotateRecognizer2(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return _AttrRecognizer.call(this, _extends({
          event: "rotate",
          threshold: 0,
          pointers: 2
        }, options2)) || this;
      }
      var _proto = RotateRecognizer2.prototype;
      _proto.getTouchAction = function getTouchAction() {
        return [TOUCH_ACTION_NONE];
      };
      _proto.attrTest = function attrTest(input) {
        return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      };
      return RotateRecognizer2;
    }(AttrRecognizer);
    PressRecognizer = function(_Recognizer) {
      _inheritsLoose(PressRecognizer2, _Recognizer);
      function PressRecognizer2(options2) {
        var _this;
        if (options2 === void 0) {
          options2 = {};
        }
        _this = _Recognizer.call(this, _extends({
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
        }, options2)) || this;
        _this._timer = null;
        _this._input = null;
        return _this;
      }
      var _proto = PressRecognizer2.prototype;
      _proto.getTouchAction = function getTouchAction() {
        return [TOUCH_ACTION_AUTO];
      };
      _proto.process = function process3(input) {
        var _this2 = this;
        var options2 = this.options;
        var validPointers = input.pointers.length === options2.pointers;
        var validMovement = input.distance < options2.threshold;
        var validTime = input.deltaTime > options2.time;
        this._input = input;
        if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
          this.reset();
        } else if (input.eventType & INPUT_START) {
          this.reset();
          this._timer = setTimeout(function() {
            _this2.state = STATE_RECOGNIZED;
            _this2.tryEmit();
          }, options2.time);
        } else if (input.eventType & INPUT_END) {
          return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
      };
      _proto.reset = function reset() {
        clearTimeout(this._timer);
      };
      _proto.emit = function emit(input) {
        if (this.state !== STATE_RECOGNIZED) {
          return;
        }
        if (input && input.eventType & INPUT_END) {
          this.manager.emit(this.options.event + "up", input);
        } else {
          this._input.timeStamp = now$3();
          this.manager.emit(this.options.event, this._input);
        }
      };
      return PressRecognizer2;
    }(Recognizer);
    defaults = {
      /**
       * @private
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,
      /**
       * @private
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,
      /**
       * @private
       * @type {Boolean}
       * @default true
       */
      enable: true,
      /**
       * @private
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * @private
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * @private
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * @private
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * @private
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * @private
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * @private
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * @private
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * @private
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    preset = [[RotateRecognizer, {
      enable: false
    }], [PinchRecognizer, {
      enable: false
    }, ["rotate"]], [SwipeRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }], [PanRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }, ["swipe"]], [TapRecognizer], [TapRecognizer, {
      event: "doubletap",
      taps: 2
    }, ["tap"]], [PressRecognizer]];
    STOP = 1;
    FORCED_STOP = 2;
    Manager = function() {
      function Manager2(element, options2) {
        var _this = this;
        this.options = assign$1$1({}, defaults, options2 || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = _this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      var _proto = Manager2.prototype;
      _proto.set = function set2(options2) {
        assign$1$1(this.options, options2);
        if (options2.touchAction) {
          this.touchAction.update();
        }
        if (options2.inputTarget) {
          this.input.destroy();
          this.input.target = options2.inputTarget;
          this.input.init();
        }
        return this;
      };
      _proto.stop = function stop(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
      };
      _proto.recognize = function recognize(inputData) {
        var session = this.session;
        if (session.stopped) {
          return;
        }
        this.touchAction.preventDefaults(inputData);
        var recognizer;
        var recognizers = this.recognizers;
        var curRecognizer = session.curRecognizer;
        if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
          session.curRecognizer = null;
          curRecognizer = null;
        }
        var i = 0;
        while (i < recognizers.length) {
          recognizer = recognizers[i];
          if (session.stopped !== FORCED_STOP && // 1
          (!curRecognizer || recognizer === curRecognizer || // 2
          recognizer.canRecognizeWith(curRecognizer))) {
            recognizer.recognize(inputData);
          } else {
            recognizer.reset();
          }
          if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
            session.curRecognizer = recognizer;
            curRecognizer = recognizer;
          }
          i++;
        }
      };
      _proto.get = function get2(recognizer) {
        if (recognizer instanceof Recognizer) {
          return recognizer;
        }
        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
          if (recognizers[i].options.event === recognizer) {
            return recognizers[i];
          }
        }
        return null;
      };
      _proto.add = function add(recognizer) {
        if (invokeArrayArg(recognizer, "add", this)) {
          return this;
        }
        var existing = this.get(recognizer.options.event);
        if (existing) {
          this.remove(existing);
        }
        this.recognizers.push(recognizer);
        recognizer.manager = this;
        this.touchAction.update();
        return recognizer;
      };
      _proto.remove = function remove(recognizer) {
        if (invokeArrayArg(recognizer, "remove", this)) {
          return this;
        }
        var targetRecognizer = this.get(recognizer);
        if (recognizer) {
          var recognizers = this.recognizers;
          var index2 = inArray(recognizers, targetRecognizer);
          if (index2 !== -1) {
            recognizers.splice(index2, 1);
            this.touchAction.update();
          }
        }
        return this;
      };
      _proto.on = function on(events, handler) {
        if (events === void 0 || handler === void 0) {
          return this;
        }
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
          handlers[event] = handlers[event] || [];
          handlers[event].push(handler);
        });
        return this;
      };
      _proto.off = function off(events, handler) {
        if (events === void 0) {
          return this;
        }
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
          if (!handler) {
            delete handlers[event];
          } else {
            handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
          }
        });
        return this;
      };
      _proto.emit = function emit(event, data2) {
        if (this.options.domEvents) {
          triggerDomEvent(event, data2);
        }
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
          return;
        }
        data2.type = event;
        data2.preventDefault = function() {
          data2.srcEvent.preventDefault();
        };
        var i = 0;
        while (i < handlers.length) {
          handlers[i](data2);
          i++;
        }
      };
      _proto.destroy = function destroy() {
        this.element && toggleCssProps(this, false);
        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
      };
      return Manager2;
    }();
    SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
    };
    SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    SingleTouchInput = function(_Input) {
      _inheritsLoose(SingleTouchInput2, _Input);
      function SingleTouchInput2() {
        var _this;
        var proto = SingleTouchInput2.prototype;
        proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        _this = _Input.apply(this, arguments) || this;
        _this.started = false;
        return _this;
      }
      var _proto = SingleTouchInput2.prototype;
      _proto.handler = function handler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
        if (type === INPUT_START) {
          this.started = true;
        }
        if (!this.started) {
          return;
        }
        var touches = normalizeSingleTouches.call(this, ev, type);
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
          this.started = false;
        }
        this.callback(this.manager, type, {
          pointers: touches[0],
          changedPointers: touches[1],
          pointerType: INPUT_TYPE_TOUCH,
          srcEvent: ev
        });
      };
      return SingleTouchInput2;
    }(Input);
    extend = deprecate(function(dest, src, merge2) {
      var keys4 = Object.keys(src);
      var i = 0;
      while (i < keys4.length) {
        if (!merge2 || merge2 && dest[keys4[i]] === void 0) {
          dest[keys4[i]] = src[keys4[i]];
        }
        i++;
      }
      return dest;
    }, "extend", "Use `assign`.");
    merge$1 = deprecate(function(dest, src) {
      return extend(dest, src, true);
    }, "merge", "Use `assign`.");
    Hammer = function() {
      var Hammer2 = (
        /**
          * @private
          * @const {string}
          */
        function Hammer3(element, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          return new Manager(element, _extends({
            recognizers: preset.concat()
          }, options2));
        }
      );
      Hammer2.VERSION = "2.0.17-rc";
      Hammer2.DIRECTION_ALL = DIRECTION_ALL;
      Hammer2.DIRECTION_DOWN = DIRECTION_DOWN;
      Hammer2.DIRECTION_LEFT = DIRECTION_LEFT;
      Hammer2.DIRECTION_RIGHT = DIRECTION_RIGHT;
      Hammer2.DIRECTION_UP = DIRECTION_UP;
      Hammer2.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
      Hammer2.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
      Hammer2.DIRECTION_NONE = DIRECTION_NONE;
      Hammer2.DIRECTION_DOWN = DIRECTION_DOWN;
      Hammer2.INPUT_START = INPUT_START;
      Hammer2.INPUT_MOVE = INPUT_MOVE;
      Hammer2.INPUT_END = INPUT_END;
      Hammer2.INPUT_CANCEL = INPUT_CANCEL;
      Hammer2.STATE_POSSIBLE = STATE_POSSIBLE;
      Hammer2.STATE_BEGAN = STATE_BEGAN;
      Hammer2.STATE_CHANGED = STATE_CHANGED;
      Hammer2.STATE_ENDED = STATE_ENDED;
      Hammer2.STATE_RECOGNIZED = STATE_RECOGNIZED;
      Hammer2.STATE_CANCELLED = STATE_CANCELLED;
      Hammer2.STATE_FAILED = STATE_FAILED;
      Hammer2.Manager = Manager;
      Hammer2.Input = Input;
      Hammer2.TouchAction = TouchAction;
      Hammer2.TouchInput = TouchInput;
      Hammer2.MouseInput = MouseInput;
      Hammer2.PointerEventInput = PointerEventInput;
      Hammer2.TouchMouseInput = TouchMouseInput;
      Hammer2.SingleTouchInput = SingleTouchInput;
      Hammer2.Recognizer = Recognizer;
      Hammer2.AttrRecognizer = AttrRecognizer;
      Hammer2.Tap = TapRecognizer;
      Hammer2.Pan = PanRecognizer;
      Hammer2.Swipe = SwipeRecognizer;
      Hammer2.Pinch = PinchRecognizer;
      Hammer2.Rotate = RotateRecognizer;
      Hammer2.Press = PressRecognizer;
      Hammer2.on = addEventListeners;
      Hammer2.off = removeEventListeners;
      Hammer2.each = each;
      Hammer2.merge = merge$1;
      Hammer2.extend = extend;
      Hammer2.bindFn = bindFn;
      Hammer2.assign = assign$1$1;
      Hammer2.inherit = inherit;
      Hammer2.bindFn = bindFn;
      Hammer2.prefixed = prefixed;
      Hammer2.toArray = toArray;
      Hammer2.inArray = inArray;
      Hammer2.uniqueArray = uniqueArray;
      Hammer2.splitStr = splitStr;
      Hammer2.boolOrFn = boolOrFn;
      Hammer2.hasParent = hasParent;
      Hammer2.addEventListeners = addEventListeners;
      Hammer2.removeEventListeners = removeEventListeners;
      Hammer2.defaults = assign$1$1({}, defaults, {
        preset
      });
      return Hammer2;
    }();
    hammer = createCommonjsModule(function(module) {
      function hammerMock() {
        var noop = function noop2() {
        };
        return {
          on: noop,
          off: noop,
          destroy: noop,
          emit: noop,
          get: function get2(m) {
            return {
              set: noop
            };
          }
        };
      }
      if (typeof window !== "undefined") {
        var Hammer$1 = window["Hammer"] || Hammer;
        module.exports = Hammer$1;
      } else {
        module.exports = function() {
          return hammerMock();
        };
      }
    });
    componentEmitter(Activator.prototype);
    Activator.current = null;
    Activator.prototype.destroy = function() {
      this.deactivate();
      this.dom.overlay.parentNode.removeChild(this.dom.overlay);
      if (this.onClick) {
        document.body.removeEventListener("click", this.onClick);
      }
      if (this.keycharm !== void 0) {
        this.keycharm.destroy();
      }
      this.keycharm = null;
      this.hammer.destroy();
      this.hammer = null;
    };
    Activator.prototype.activate = function() {
      var _context3;
      if (Activator.current) {
        Activator.current.deactivate();
      }
      Activator.current = this;
      this.active = true;
      this.dom.overlay.style.display = "none";
      addClassName(this.dom.container, "vis-active");
      this.emit("change");
      this.emit("activate");
      bind$2(_context3 = this.keycharm).call(_context3, "esc", this.escListener);
    };
    Activator.prototype.deactivate = function() {
      this.active = false;
      this.dom.overlay.style.display = "block";
      removeClassName(this.dom.container, "vis-active");
      this.keycharm.unbind("esc", this.escListener);
      this.emit("change");
      this.emit("deactivate");
    };
    Activator.prototype._onTapOverlay = function(event) {
      this.activate();
      event.srcEvent.stopPropagation();
    };
    en = {
      addDescription: "Click in an empty space to place a new node.",
      addEdge: "Add Edge",
      addNode: "Add Node",
      back: "Back",
      createEdgeError: "Cannot link edges to a cluster.",
      del: "Delete selected",
      deleteClusterError: "Clusters cannot be deleted.",
      edgeDescription: "Click on a node and drag the edge to another node to connect them.",
      edit: "Edit",
      editClusterError: "Clusters cannot be edited.",
      editEdge: "Edit Edge",
      editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
      editNode: "Edit Node"
    };
    de = {
      addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
      addEdge: "Kante hinzufgen",
      addNode: "Knoten hinzufgen",
      back: "Zurck",
      createEdgeError: "Es ist nicht mglich, Kanten mit Clustern zu verbinden.",
      del: "Lsche Auswahl",
      deleteClusterError: "Cluster knnen nicht gelscht werden.",
      edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
      edit: "Editieren",
      editClusterError: "Cluster knnen nicht editiert werden.",
      editEdge: "Kante editieren",
      editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
      editNode: "Knoten editieren"
    };
    es = {
      addDescription: "Haga clic en un lugar vaco para colocar un nuevo nodo.",
      addEdge: "Aadir arista",
      addNode: "Aadir nodo",
      back: "Atrs",
      createEdgeError: "No se puede conectar una arista a un grupo.",
      del: "Eliminar seleccin",
      deleteClusterError: "No es posible eliminar grupos.",
      edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
      edit: "Editar",
      editClusterError: "No es posible editar grupos.",
      editEdge: "Editar arista",
      editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
      editNode: "Editar nodo"
    };
    it = {
      addDescription: "Clicca per aggiungere un nuovo nodo",
      addEdge: "Aggiungi un vertice",
      addNode: "Aggiungi un nodo",
      back: "Indietro",
      createEdgeError: "Non si possono collegare vertici ad un cluster",
      del: "Cancella la selezione",
      deleteClusterError: "I cluster non possono essere cancellati",
      edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
      edit: "Modifica",
      editClusterError: "I clusters non possono essere modificati.",
      editEdge: "Modifica il vertice",
      editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
      editNode: "Modifica il nodo"
    };
    nl = {
      addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
      addEdge: "Link toevoegen",
      addNode: "Node toevoegen",
      back: "Terug",
      createEdgeError: "Kan geen link maken naar een cluster.",
      del: "Selectie verwijderen",
      deleteClusterError: "Clusters kunnen niet worden verwijderd.",
      edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
      edit: "Wijzigen",
      editClusterError: "Clusters kunnen niet worden aangepast.",
      editEdge: "Link wijzigen",
      editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
      editNode: "Node wijzigen"
    };
    pt = {
      addDescription: "Clique em um espao em branco para adicionar um novo n",
      addEdge: "Adicionar aresta",
      addNode: "Adicionar n",
      back: "Voltar",
      createEdgeError: "No foi possvel linkar arestas a um cluster.",
      del: "Remover selecionado",
      deleteClusterError: "Clusters no puderam ser removidos.",
      edgeDescription: "Clique em um n e arraste a aresta at outro n para conect-los",
      edit: "Editar",
      editClusterError: "Clusters no puderam ser editados.",
      editEdge: "Editar aresta",
      editEdgeDescription: "Clique nos pontos de controle e os arraste para um n para conect-los",
      editNode: "Editar n"
    };
    ru = {
      addDescription: "   ,    .",
      addEdge: " ",
      addNode: " ",
      back: "",
      createEdgeError: "    .",
      del: " ",
      deleteClusterError: "    ",
      edgeDescription: "        ,   .",
      edit: "",
      editClusterError: "   .",
      editEdge: " ",
      editEdgeDescription: "        ,    .",
      editNode: " "
    };
    cn = {
      addDescription: "",
      addEdge: "",
      addNode: "",
      back: "",
      createEdgeError: "",
      del: "",
      deleteClusterError: "",
      edgeDescription: "",
      edit: "",
      editClusterError: "",
      editEdge: "",
      editEdgeDescription: "",
      editNode: ""
    };
    uk = {
      addDescription: "K   ,    .",
      addEdge: " ",
      addNode: " ",
      back: "",
      createEdgeError: "  '   .",
      del: " ",
      deleteClusterError: "    .",
      edgeDescription: "        ,   '.",
      edit: "",
      editClusterError: "   .",
      editEdge: " ",
      editEdgeDescription: "        ,    .",
      editNode: " "
    };
    fr = {
      addDescription: "Cliquez dans un endroit vide pour placer un nud.",
      addEdge: "Ajouter un lien",
      addNode: "Ajouter un nud",
      back: "Retour",
      createEdgeError: "Impossible de crer un lien vers un cluster.",
      del: "Effacer la slection",
      deleteClusterError: "Les clusters ne peuvent pas tre effacs.",
      edgeDescription: "Cliquez sur un nud et glissez le lien vers un autre nud pour les connecter.",
      edit: "diter",
      editClusterError: "Les clusters ne peuvent pas tre dits.",
      editEdge: "diter le lien",
      editEdgeDescription: "Cliquez sur les points de contrle et glissez-les pour connecter un nud.",
      editNode: "diter le nud"
    };
    cs = {
      addDescription: "Kluknutm do przdnho prostoru mete pidat nov vrchol.",
      addEdge: "Pidat hranu",
      addNode: "Pidat vrchol",
      back: "Zpt",
      createEdgeError: "Nelze pipojit hranu ke shluku.",
      del: "Smazat vbr",
      deleteClusterError: "Nelze mazat shluky.",
      edgeDescription: "Petaenm z jednoho vrcholu do druhho mete spojit tyto vrcholy novou hranou.",
      edit: "Upravit",
      editClusterError: "Nelze upravovat shluky.",
      editEdge: "Upravit hranu",
      editEdgeDescription: "Petaenm kontrolnho vrcholu hrany ji mete pipojit k jinmu vrcholu.",
      editNode: "Upravit vrchol"
    };
    locales = Object.freeze({
      __proto__: null,
      en,
      de,
      es,
      it,
      nl,
      pt,
      ru,
      cn,
      uk,
      fr,
      cs
    });
    classCallCheck = _classCallCheck;
    createClass = _createClass;
    CachedImage = function() {
      function CachedImage2() {
        classCallCheck(this, CachedImage2);
        this.NUM_ITERATIONS = 4;
        this.image = new Image();
        this.canvas = document.createElement("canvas");
      }
      createClass(CachedImage2, [{
        key: "init",
        value: function init() {
          if (this.initialized()) return;
          this.src = this.image.src;
          var w = this.image.width;
          var h = this.image.height;
          this.width = w;
          this.height = h;
          var h2 = Math.floor(h / 2);
          var h4 = Math.floor(h / 4);
          var h8 = Math.floor(h / 8);
          var h16 = Math.floor(h / 16);
          var w2 = Math.floor(w / 2);
          var w4 = Math.floor(w / 4);
          var w8 = Math.floor(w / 8);
          var w16 = Math.floor(w / 16);
          this.canvas.width = 3 * w4;
          this.canvas.height = h2;
          this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];
          this._fillMipMap();
        }
        /**
         * @return {Boolean} true if init() has been called, false otherwise.
         */
      }, {
        key: "initialized",
        value: function initialized() {
          return this.coordinates !== void 0;
        }
        /**
         * Redraw main image in various sizes to the context.
         *
         * The rationale behind this is to reduce artefacts due to interpolation
         * at differing zoom levels.
         *
         * Source: http://stackoverflow.com/q/18761404/1223531
         *
         * This methods takes the resizing out of the drawing loop, in order to
         * reduce performance overhead.
         *
         * TODO: The code assumes that a 2D context can always be gotten. This is
         *       not necessarily true! OTOH, if not true then usage of this class
         *       is senseless.
         *
         * @private
         */
      }, {
        key: "_fillMipMap",
        value: function _fillMipMap() {
          var ctx = this.canvas.getContext("2d");
          var to = this.coordinates[0];
          ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);
          for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
            var from2 = this.coordinates[iterations - 1];
            var _to = this.coordinates[iterations];
            ctx.drawImage(this.canvas, from2[0], from2[1], from2[2], from2[3], _to[0], _to[1], _to[2], _to[3]);
          }
        }
        /**
         * Draw the image, using the mipmap if necessary.
         *
         * MipMap is only used if param factor > 2; otherwise, original bitmap
         * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
         *
         * Credits to 'Alex de Mulder' for original implementation.
         *
         * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
         * @param {Float} factor scale factor at which to draw
         * @param {number} left
         * @param {number} top
         * @param {number} width
         * @param {number} height
         */
      }, {
        key: "drawImageAtPosition",
        value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
          if (!this.initialized()) return;
          if (factor > 2) {
            factor *= 0.5;
            var iterations = 0;
            while (factor > 2 && iterations < this.NUM_ITERATIONS) {
              factor *= 0.5;
              iterations += 1;
            }
            if (iterations >= this.NUM_ITERATIONS) {
              iterations = this.NUM_ITERATIONS - 1;
            }
            var from2 = this.coordinates[iterations];
            ctx.drawImage(this.canvas, from2[0], from2[1], from2[2], from2[3], left, top, width, height);
          } else {
            ctx.drawImage(this.image, left, top, width, height);
          }
        }
      }]);
      return CachedImage2;
    }();
    Images = function() {
      function Images2(callback) {
        classCallCheck(this, Images2);
        this.images = {};
        this.imageBroken = {};
        this.callback = callback;
      }
      createClass(Images2, [{
        key: "_tryloadBrokenUrl",
        value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
          if (url === void 0 || imageToLoadBrokenUrlOn === void 0) return;
          if (brokenUrl === void 0) {
            console.warn("No broken url image defined");
            return;
          }
          imageToLoadBrokenUrlOn.image.onerror = function() {
            console.error("Could not load brokenImage:", brokenUrl);
          };
          imageToLoadBrokenUrlOn.image.src = brokenUrl;
        }
        /**
         *
         * @param {vis.Image} imageToRedrawWith
         * @private
         */
      }, {
        key: "_redrawWithImage",
        value: function _redrawWithImage(imageToRedrawWith) {
          if (this.callback) {
            this.callback(imageToRedrawWith);
          }
        }
        /**
         * @param {string} url          Url of the image
         * @param {string} brokenUrl    Url of an image to use if the url image is not found
         * @return {Image} img          The image object
         */
      }, {
        key: "load",
        value: function load(url, brokenUrl) {
          var _this = this;
          var cachedImage = this.images[url];
          if (cachedImage) return cachedImage;
          var img = new CachedImage();
          this.images[url] = img;
          img.image.onload = function() {
            _this._fixImageCoordinates(img.image);
            img.init();
            _this._redrawWithImage(img);
          };
          img.image.onerror = function() {
            console.error("Could not load image:", url);
            _this._tryloadBrokenUrl(url, brokenUrl, img);
          };
          img.image.src = url;
          return img;
        }
        /**
         * IE11 fix -- thanks dponch!
         *
         * Local helper function
         * @param {vis.Image} imageToCache
         * @private
         */
      }, {
        key: "_fixImageCoordinates",
        value: function _fixImageCoordinates(imageToCache) {
          if (imageToCache.width === 0) {
            document.body.appendChild(imageToCache);
            imageToCache.width = imageToCache.offsetWidth;
            imageToCache.height = imageToCache.offsetHeight;
            document.body.removeChild(imageToCache);
          }
        }
      }]);
      return Images2;
    }();
    Groups = function() {
      function Groups2() {
        classCallCheck(this, Groups2);
        this.clear();
        this.defaultIndex = 0;
        this.groupsArray = [];
        this.groupIndex = 0;
        this.defaultGroups = [
          {
            border: "#2B7CE9",
            background: "#97C2FC",
            highlight: {
              border: "#2B7CE9",
              background: "#D2E5FF"
            },
            hover: {
              border: "#2B7CE9",
              background: "#D2E5FF"
            }
          },
          // 0: blue
          {
            border: "#FFA500",
            background: "#FFFF00",
            highlight: {
              border: "#FFA500",
              background: "#FFFFA3"
            },
            hover: {
              border: "#FFA500",
              background: "#FFFFA3"
            }
          },
          // 1: yellow
          {
            border: "#FA0A10",
            background: "#FB7E81",
            highlight: {
              border: "#FA0A10",
              background: "#FFAFB1"
            },
            hover: {
              border: "#FA0A10",
              background: "#FFAFB1"
            }
          },
          // 2: red
          {
            border: "#41A906",
            background: "#7BE141",
            highlight: {
              border: "#41A906",
              background: "#A1EC76"
            },
            hover: {
              border: "#41A906",
              background: "#A1EC76"
            }
          },
          // 3: green
          {
            border: "#E129F0",
            background: "#EB7DF4",
            highlight: {
              border: "#E129F0",
              background: "#F0B3F5"
            },
            hover: {
              border: "#E129F0",
              background: "#F0B3F5"
            }
          },
          // 4: magenta
          {
            border: "#7C29F0",
            background: "#AD85E4",
            highlight: {
              border: "#7C29F0",
              background: "#D3BDF0"
            },
            hover: {
              border: "#7C29F0",
              background: "#D3BDF0"
            }
          },
          // 5: purple
          {
            border: "#C37F00",
            background: "#FFA807",
            highlight: {
              border: "#C37F00",
              background: "#FFCA66"
            },
            hover: {
              border: "#C37F00",
              background: "#FFCA66"
            }
          },
          // 6: orange
          {
            border: "#4220FB",
            background: "#6E6EFD",
            highlight: {
              border: "#4220FB",
              background: "#9B9BFD"
            },
            hover: {
              border: "#4220FB",
              background: "#9B9BFD"
            }
          },
          // 7: darkblue
          {
            border: "#FD5A77",
            background: "#FFC0CB",
            highlight: {
              border: "#FD5A77",
              background: "#FFD1D9"
            },
            hover: {
              border: "#FD5A77",
              background: "#FFD1D9"
            }
          },
          // 8: pink
          {
            border: "#4AD63A",
            background: "#C2FABC",
            highlight: {
              border: "#4AD63A",
              background: "#E6FFE3"
            },
            hover: {
              border: "#4AD63A",
              background: "#E6FFE3"
            }
          },
          // 9: mint
          {
            border: "#990000",
            background: "#EE0000",
            highlight: {
              border: "#BB0000",
              background: "#FF3333"
            },
            hover: {
              border: "#BB0000",
              background: "#FF3333"
            }
          },
          // 10:bright red
          {
            border: "#FF6000",
            background: "#FF6000",
            highlight: {
              border: "#FF6000",
              background: "#FF6000"
            },
            hover: {
              border: "#FF6000",
              background: "#FF6000"
            }
          },
          // 12: real orange
          {
            border: "#97C2FC",
            background: "#2B7CE9",
            highlight: {
              border: "#D2E5FF",
              background: "#2B7CE9"
            },
            hover: {
              border: "#D2E5FF",
              background: "#2B7CE9"
            }
          },
          // 13: blue
          {
            border: "#399605",
            background: "#255C03",
            highlight: {
              border: "#399605",
              background: "#255C03"
            },
            hover: {
              border: "#399605",
              background: "#255C03"
            }
          },
          // 14: green
          {
            border: "#B70054",
            background: "#FF007E",
            highlight: {
              border: "#B70054",
              background: "#FF007E"
            },
            hover: {
              border: "#B70054",
              background: "#FF007E"
            }
          },
          // 15: magenta
          {
            border: "#AD85E4",
            background: "#7C29F0",
            highlight: {
              border: "#D3BDF0",
              background: "#7C29F0"
            },
            hover: {
              border: "#D3BDF0",
              background: "#7C29F0"
            }
          },
          // 16: purple
          {
            border: "#4557FA",
            background: "#000EA1",
            highlight: {
              border: "#6E6EFD",
              background: "#000EA1"
            },
            hover: {
              border: "#6E6EFD",
              background: "#000EA1"
            }
          },
          // 17: darkblue
          {
            border: "#FFC0CB",
            background: "#FD5A77",
            highlight: {
              border: "#FFD1D9",
              background: "#FD5A77"
            },
            hover: {
              border: "#FFD1D9",
              background: "#FD5A77"
            }
          },
          // 18: pink
          {
            border: "#C2FABC",
            background: "#74D66A",
            highlight: {
              border: "#E6FFE3",
              background: "#74D66A"
            },
            hover: {
              border: "#E6FFE3",
              background: "#74D66A"
            }
          },
          // 19: mint
          {
            border: "#EE0000",
            background: "#990000",
            highlight: {
              border: "#FF3333",
              background: "#BB0000"
            },
            hover: {
              border: "#FF3333",
              background: "#BB0000"
            }
          }
          // 20:bright red
        ];
        this.options = {};
        this.defaultOptions = {
          useDefaultGroups: true
        };
        assign$2(this.options, this.defaultOptions);
      }
      createClass(Groups2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          var optionFields = ["useDefaultGroups"];
          if (options2 !== void 0) {
            for (var groupName in options2) {
              if (Object.prototype.hasOwnProperty.call(options2, groupName)) {
                if (indexOf$3(optionFields).call(optionFields, groupName) === -1) {
                  var group = options2[groupName];
                  this.add(groupName, group);
                }
              }
            }
          }
        }
        /**
         * Clear all groups
         */
      }, {
        key: "clear",
        value: function clear() {
          this.groups = {};
          this.groupsArray = [];
        }
        /**
         * Get group options of a groupname.
         * If groupname is not found, a new group may be created.
         *
         * @param {*}       groupname     Can be a number, string, Date, etc.
         * @param {boolean} [shouldCreate=true] If true, create a new group
         * @return {Object} The found or created group
         */
      }, {
        key: "get",
        value: function get2(groupname) {
          var shouldCreate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var group = this.groups[groupname];
          if (group === void 0 && shouldCreate) {
            if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {
              var index2 = this.groupIndex % this.groupsArray.length;
              this.groupIndex++;
              group = {};
              group.color = this.groups[this.groupsArray[index2]];
              this.groups[groupname] = group;
            } else {
              var _index = this.defaultIndex % this.defaultGroups.length;
              this.defaultIndex++;
              group = {};
              group.color = this.defaultGroups[_index];
              this.groups[groupname] = group;
            }
          }
          return group;
        }
        /**
         * Add a custom group style
         * @param {string} groupName
         * @param {Object} style       An object containing borderColor,
         *                             backgroundColor, etc.
         * @return {Object} group      The created group object
         */
      }, {
        key: "add",
        value: function add(groupName, style) {
          this.groups[groupName] = style;
          this.groupsArray.push(groupName);
          return style;
        }
      }]);
      return Groups2;
    }();
    slice$6 = [].slice;
    MSIE = /MSIE .\./.test(engineUserAgent);
    wrap$1 = function(scheduler) {
      return function(handler, timeout) {
        var boundArgs = arguments.length > 2;
        var args = boundArgs ? slice$6.call(arguments, 2) : void 0;
        return scheduler(boundArgs ? function() {
          (typeof handler == "function" ? handler : Function(handler)).apply(this, args);
        } : handler, timeout);
      };
    };
    _export({
      global: true,
      bind: true,
      forced: MSIE
    }, {
      // `setTimeout` method
      // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
      setTimeout: wrap$1(global_1.setTimeout),
      // `setInterval` method
      // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
      setInterval: wrap$1(global_1.setInterval)
    });
    setTimeout$1 = path.setTimeout;
    setTimeout$2 = setTimeout$1;
    $some = arrayIteration.some;
    STRICT_METHOD$2 = arrayMethodIsStrict("some");
    USES_TO_LENGTH$7 = arrayMethodUsesToLength("some");
    _export({
      target: "Array",
      proto: true,
      forced: !STRICT_METHOD$2 || !USES_TO_LENGTH$7
    }, {
      some: function some(callbackfn) {
        return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    some2 = entryVirtual("Array").some;
    ArrayPrototype$9 = Array.prototype;
    some_1 = function(it2) {
      var own = it2.some;
      return it2 === ArrayPrototype$9 || it2 instanceof Array && own === ArrayPrototype$9.some ? some2 : own;
    };
    some$1 = some_1;
    some$2 = some$1;
    globalIsFinite = global_1.isFinite;
    numberIsFinite = Number.isFinite || function isFinite2(it2) {
      return typeof it2 == "number" && globalIsFinite(it2);
    };
    _export({
      target: "Number",
      stat: true
    }, {
      isFinite: numberIsFinite
    });
    _isFinite = path.Number.isFinite;
    _isFinite$1 = _isFinite;
    _isFinite$2 = _isFinite$1;
    _export({
      target: "Number",
      stat: true
    }, {
      isNaN: function isNaN2(number2) {
        return number2 != number2;
      }
    });
    isNan = path.Number.isNaN;
    isNan$1 = isNan;
    isNan$2 = isNan$1;
    assertThisInitialized = _assertThisInitialized$1;
    nativeConstruct = getBuiltIn("Reflect", "construct");
    NEW_TARGET_BUG = fails(function() {
      function F() {
      }
      return !(nativeConstruct(function() {
      }, [], F) instanceof F);
    });
    ARGS_BUG = !fails(function() {
      nativeConstruct(function() {
      });
    });
    FORCED$3 = NEW_TARGET_BUG || ARGS_BUG;
    _export({
      target: "Reflect",
      stat: true,
      forced: FORCED$3,
      sham: FORCED$3
    }, {
      construct: function construct2(Target, args) {
        aFunction(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
        if (Target == newTarget) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
          var $args = [null];
          $args.push.apply($args, args);
          return new (functionBind.apply(Target, $args))();
        }
        var proto = newTarget.prototype;
        var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
        var result = Function.apply.call(Target, instance, args);
        return isObject(result) ? result : instance;
      }
    });
    construct$1 = path.Reflect.construct;
    construct$2 = construct$1;
    construct$3 = construct$2;
    entries = entryVirtual("Array").entries;
    entries$1 = entries;
    ArrayPrototype$a = Array.prototype;
    DOMIterables$1 = {
      DOMTokenList: true,
      NodeList: true
    };
    entries_1 = function(it2) {
      var own = it2.entries;
      return it2 === ArrayPrototype$a || it2 instanceof Array && own === ArrayPrototype$a.entries || DOMIterables$1.hasOwnProperty(classof(it2)) ? entries$1 : own;
    };
    entries$2 = entries_1;
    $stringify$1 = getBuiltIn("JSON", "stringify");
    re = /[\uD800-\uDFFF]/g;
    low = /^[\uD800-\uDBFF]$/;
    hi = /^[\uDC00-\uDFFF]$/;
    fix = function(match2, offset, string2) {
      var prev = string2.charAt(offset - 1);
      var next3 = string2.charAt(offset + 1);
      if (low.test(match2) && !hi.test(next3) || hi.test(match2) && !low.test(prev)) {
        return "\\u" + match2.charCodeAt(0).toString(16);
      }
      return match2;
    };
    FORCED$4 = fails(function() {
      return $stringify$1("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify$1("\uDEAD") !== '"\\udead"';
    });
    if ($stringify$1) {
      _export({
        target: "JSON",
        stat: true,
        forced: FORCED$4
      }, {
        // eslint-disable-next-line no-unused-vars
        stringify: function stringify3(it2, replacer, space) {
          var result = $stringify$1.apply(null, arguments);
          return typeof result == "string" ? result.replace(re, fix) : result;
        }
      });
    }
    if (!path.JSON) path.JSON = {
      stringify: JSON.stringify
    };
    stringify = function stringify2(it2, replacer, space) {
      return path.JSON.stringify.apply(null, arguments);
    };
    stringify$1 = stringify;
    stringify$2 = stringify$1;
    values$1 = entryVirtual("Array").values;
    values$2 = values$1;
    ArrayPrototype$b = Array.prototype;
    DOMIterables$2 = {
      DOMTokenList: true,
      NodeList: true
    };
    values_1 = function(it2) {
      var own = it2.values;
      return it2 === ArrayPrototype$b || it2 instanceof Array && own === ArrayPrototype$b.values || DOMIterables$2.hasOwnProperty(classof(it2)) ? values$2 : own;
    };
    values$3 = values_1;
    keys$4 = entryVirtual("Array").keys;
    keys$5 = keys$4;
    ArrayPrototype$c = Array.prototype;
    DOMIterables$3 = {
      DOMTokenList: true,
      NodeList: true
    };
    keys_1 = function(it2) {
      var own = it2.keys;
      return it2 === ArrayPrototype$c || it2 instanceof Array && own === ArrayPrototype$c.keys || DOMIterables$3.hasOwnProperty(classof(it2)) ? keys$5 : own;
    };
    keys$6 = keys_1;
    create$3 = create3;
    create$4 = create$3;
    _export({
      target: "Object",
      stat: true
    }, {
      setPrototypeOf: objectSetPrototypeOf
    });
    setPrototypeOf = path.Object.setPrototypeOf;
    setPrototypeOf$1 = setPrototypeOf;
    setPrototypeOf$2 = setPrototypeOf$1;
    setPrototypeOf$3 = createCommonjsModule(function(module) {
      function _setPrototypeOf(o, p) {
        module.exports = _setPrototypeOf = setPrototypeOf$2 || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      module.exports = _setPrototypeOf;
    });
    inherits = _inherits;
    possibleConstructorReturn = _possibleConstructorReturn;
    getPrototypeOf$3 = getPrototypeOf2;
    getPrototypeOf$4 = getPrototypeOf$3;
    getPrototypeOf$5 = createCommonjsModule(function(module) {
      function _getPrototypeOf(o) {
        module.exports = _getPrototypeOf = setPrototypeOf$2 ? getPrototypeOf$4 : function _getPrototypeOf2(o2) {
          return o2.__proto__ || getPrototypeOf$4(o2);
        };
        return _getPrototypeOf(o);
      }
      module.exports = _getPrototypeOf;
    });
    test$1 = [];
    nativeSort = test$1.sort;
    FAILS_ON_UNDEFINED = fails(function() {
      test$1.sort(void 0);
    });
    FAILS_ON_NULL = fails(function() {
      test$1.sort(null);
    });
    STRICT_METHOD$3 = arrayMethodIsStrict("sort");
    FORCED$5 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$3;
    _export({
      target: "Array",
      proto: true,
      forced: FORCED$5
    }, {
      sort: function sort(comparefn) {
        return comparefn === void 0 ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction(comparefn));
      }
    });
    sort2 = entryVirtual("Array").sort;
    ArrayPrototype$d = Array.prototype;
    sort_1 = function(it2) {
      var own = it2.sort;
      return it2 === ArrayPrototype$d || it2 instanceof Array && own === ArrayPrototype$d.sort ? sort2 : own;
    };
    sort$1 = sort_1;
    sort$2 = sort$1;
    freezing = !fails(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
    internalMetadata = createCommonjsModule(function(module) {
      var defineProperty4 = objectDefineProperty.f;
      var METADATA = uid("meta");
      var id2 = 0;
      var isExtensible = Object.isExtensible || function() {
        return true;
      };
      var setMetadata = function(it2) {
        defineProperty4(it2, METADATA, {
          value: {
            objectID: "O" + ++id2,
            // object ID
            weakData: {}
            // weak collections IDs
          }
        });
      };
      var fastKey2 = function(it2, create5) {
        if (!isObject(it2)) return typeof it2 == "symbol" ? it2 : (typeof it2 == "string" ? "S" : "P") + it2;
        if (!has(it2, METADATA)) {
          if (!isExtensible(it2)) return "F";
          if (!create5) return "E";
          setMetadata(it2);
        }
        return it2[METADATA].objectID;
      };
      var getWeakData = function(it2, create5) {
        if (!has(it2, METADATA)) {
          if (!isExtensible(it2)) return true;
          if (!create5) return false;
          setMetadata(it2);
        }
        return it2[METADATA].weakData;
      };
      var onFreeze = function(it2) {
        if (freezing && meta.REQUIRED && isExtensible(it2) && !has(it2, METADATA)) setMetadata(it2);
        return it2;
      };
      var meta = module.exports = {
        REQUIRED: false,
        fastKey: fastKey2,
        getWeakData,
        onFreeze
      };
      hiddenKeys[METADATA] = true;
    });
    iterate_1 = createCommonjsModule(function(module) {
      var Result = function(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var iterate = module.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
        var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
        var iterator2, iterFn, index2, length2, result, next3, step;
        if (IS_ITERATOR) {
          iterator2 = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (typeof iterFn != "function") throw TypeError("Target is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index2 = 0, length2 = toLength(iterable.length); length2 > index2; index2++) {
              result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index2])[0], step[1]) : boundFunction(iterable[index2]);
              if (result && result instanceof Result) return result;
            }
            return new Result(false);
          }
          iterator2 = iterFn.call(iterable);
        }
        next3 = iterator2.next;
        while (!(step = next3.call(iterator2)).done) {
          result = callWithSafeIterationClosing(iterator2, boundFunction, step.value, AS_ENTRIES);
          if (typeof result == "object" && result && result instanceof Result) return result;
        }
        return new Result(false);
      };
      iterate.stop = function(result) {
        return new Result(true, result);
      };
    });
    anInstance = function(it2, Constructor, name) {
      if (!(it2 instanceof Constructor)) {
        throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
      }
      return it2;
    };
    defineProperty$9 = objectDefineProperty.f;
    forEach$4 = arrayIteration.forEach;
    setInternalState$3 = internalState.set;
    internalStateGetterFor = internalState.getterFor;
    collection = function(CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
      var ADDER = IS_MAP ? "set" : "add";
      var NativeConstructor = global_1[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var exported = {};
      var Constructor;
      if (!descriptors || typeof NativeConstructor != "function" || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
        new NativeConstructor().entries().next();
      }))) {
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        internalMetadata.REQUIRED = true;
      } else {
        Constructor = wrapper(function(target, iterable) {
          setInternalState$3(anInstance(target, Constructor, CONSTRUCTOR_NAME), {
            type: CONSTRUCTOR_NAME,
            collection: new NativeConstructor()
          });
          if (iterable != void 0) iterate_1(iterable, target[ADDER], target, IS_MAP);
        });
        var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
        forEach$4(["add", "clear", "delete", "forEach", "get", "has", "set", "keys", "values", "entries"], function(KEY) {
          var IS_ADDER = KEY == "add" || KEY == "set";
          if (KEY in NativePrototype && !(IS_WEAK && KEY == "clear")) {
            createNonEnumerableProperty(Constructor.prototype, KEY, function(a, b) {
              var collection2 = getInternalState2(this).collection;
              if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == "get" ? void 0 : false;
              var result = collection2[KEY](a === 0 ? 0 : a, b);
              return IS_ADDER ? this : result;
            });
          }
        });
        IS_WEAK || defineProperty$9(Constructor.prototype, "size", {
          configurable: true,
          get: function() {
            return getInternalState2(this).collection.size;
          }
        });
      }
      setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
      exported[CONSTRUCTOR_NAME] = Constructor;
      _export({
        global: true,
        forced: true
      }, exported);
      if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
    redefineAll = function(target, src, options2) {
      for (var key in src) {
        if (options2 && options2.unsafe && target[key]) target[key] = src[key];
        else redefine(target, key, src[key], options2);
      }
      return target;
    };
    SPECIES$3 = wellKnownSymbol("species");
    setSpecies = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      var defineProperty4 = objectDefineProperty.f;
      if (descriptors && Constructor && !Constructor[SPECIES$3]) {
        defineProperty4(Constructor, SPECIES$3, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
    defineProperty$a = objectDefineProperty.f;
    fastKey = internalMetadata.fastKey;
    setInternalState$4 = internalState.set;
    internalStateGetterFor$1 = internalState.getterFor;
    collectionStrong = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
          anInstance(that, C, CONSTRUCTOR_NAME);
          setInternalState$4(that, {
            type: CONSTRUCTOR_NAME,
            index: objectCreate(null),
            first: void 0,
            last: void 0,
            size: 0
          });
          if (!descriptors) that.size = 0;
          if (iterable != void 0) iterate_1(iterable, that[ADDER], that, IS_MAP);
        });
        var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
        var define = function(that, key, value) {
          var state = getInternalState2(that);
          var entry = getEntry(that, key);
          var previous, index2;
          if (entry) {
            entry.value = value;
          } else {
            state.last = entry = {
              index: index2 = fastKey(key, true),
              key,
              value,
              previous: previous = state.last,
              next: void 0,
              removed: false
            };
            if (!state.first) state.first = entry;
            if (previous) previous.next = entry;
            if (descriptors) state.size++;
            else that.size++;
            if (index2 !== "F") state.index[index2] = entry;
          }
          return that;
        };
        var getEntry = function(that, key) {
          var state = getInternalState2(that);
          var index2 = fastKey(key);
          var entry;
          if (index2 !== "F") return state.index[index2];
          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key == key) return entry;
          }
        };
        redefineAll(C.prototype, {
          // 23.1.3.1 Map.prototype.clear()
          // 23.2.3.2 Set.prototype.clear()
          clear: function clear() {
            var that = this;
            var state = getInternalState2(that);
            var data2 = state.index;
            var entry = state.first;
            while (entry) {
              entry.removed = true;
              if (entry.previous) entry.previous = entry.previous.next = void 0;
              delete data2[entry.index];
              entry = entry.next;
            }
            state.first = state.last = void 0;
            if (descriptors) state.size = 0;
            else that.size = 0;
          },
          // 23.1.3.3 Map.prototype.delete(key)
          // 23.2.3.4 Set.prototype.delete(value)
          "delete": function(key) {
            var that = this;
            var state = getInternalState2(that);
            var entry = getEntry(that, key);
            if (entry) {
              var next3 = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev) prev.next = next3;
              if (next3) next3.previous = prev;
              if (state.first == entry) state.first = next3;
              if (state.last == entry) state.last = prev;
              if (descriptors) state.size--;
              else that.size--;
            }
            return !!entry;
          },
          // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
          // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
          forEach: function forEach3(callbackfn) {
            var state = getInternalState2(this);
            var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
            var entry;
            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this);
              while (entry && entry.removed) entry = entry.previous;
            }
          },
          // 23.1.3.7 Map.prototype.has(key)
          // 23.2.3.7 Set.prototype.has(value)
          has: function has2(key) {
            return !!getEntry(this, key);
          }
        });
        redefineAll(C.prototype, IS_MAP ? {
          // 23.1.3.6 Map.prototype.get(key)
          get: function get2(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          // 23.1.3.9 Map.prototype.set(key, value)
          set: function set2(key, value) {
            return define(this, key === 0 ? 0 : key, value);
          }
        } : {
          // 23.2.3.1 Set.prototype.add(value)
          add: function add(value) {
            return define(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (descriptors) defineProperty$a(C.prototype, "size", {
          get: function() {
            return getInternalState2(this).size;
          }
        });
        return C;
      },
      setStrong: function(C, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
        var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);
        defineIterator(C, CONSTRUCTOR_NAME, function(iterated, kind) {
          setInternalState$4(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind,
            last: void 0
          });
        }, function() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last;
          while (entry && entry.removed) entry = entry.previous;
          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            state.target = void 0;
            return {
              value: void 0,
              done: true
            };
          }
          if (kind == "keys") return {
            value: entry.key,
            done: false
          };
          if (kind == "values") return {
            value: entry.value,
            done: false
          };
          return {
            value: [entry.key, entry.value],
            done: false
          };
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies(CONSTRUCTOR_NAME);
      }
    };
    es_set = collection("Set", function(init) {
      return function Set() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
    set$1 = path.Set;
    set$2 = set$1;
    set$3 = set$2;
    es_map = collection("Map", function(init) {
      return function Map() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
    map$3 = path.Map;
    map$4 = map$3;
    map$5 = map$4;
    runtime_1 = createCommonjsModule(function(module) {
      var runtime = function(exports) {
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined$1;
        var $Symbol2 = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol2.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol2.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol2.toStringTag || "@@toStringTag";
        function wrap2(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);
          generator._invoke = makeInvokeMethod(innerFn, self2, context);
          return generator;
        }
        exports.wrap = wrap2;
        function tryCatch(fn, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype2 = {};
        IteratorPrototype2[iteratorSymbol] = function() {
          return this;
        };
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values3([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype2 = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype2);
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            prototype[method] = function(arg) {
              return this._invoke(method, arg);
            };
          });
        }
        exports.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            if (!(toStringTagSymbol in genFun)) {
              genFun[toStringTagSymbol] = "GeneratorFunction";
            }
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports.awrap = function(arg) {
          return {
            __await: arg
          };
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(
              callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg
            ) : callInvokeWithMethodAndArg();
          }
          this._invoke = enqueue;
        }
        defineIteratorMethods(AsyncIterator.prototype);
        AsyncIterator.prototype[asyncIteratorSymbol] = function() {
          return this;
        };
        exports.AsyncIterator = AsyncIterator;
        exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0) PromiseImpl = Promise;
          var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return {
                  value: record.arg,
                  done: context.done
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];
          if (method === undefined$1) {
            context.delegate = null;
            if (context.method === "throw") {
              if (delegate.iterator["return"]) {
                context.method = "return";
                context.arg = undefined$1;
                maybeInvokeDelegate(delegate, context);
                if (context.method === "throw") {
                  return ContinueSentinel;
                }
              }
              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined$1;
            }
          } else {
            return info;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        Gp[toStringTagSymbol] = "Generator";
        Gp[iteratorSymbol] = function() {
          return this;
        };
        Gp.toString = function() {
          return "[object Generator]";
        };
        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports.keys = function(object2) {
          var keys4 = [];
          for (var key in object2) {
            keys4.push(key);
          }
          keys4.reverse();
          return function next3() {
            while (keys4.length) {
              var key2 = keys4.pop();
              if (key2 in object2) {
                next3.value = key2;
                next3.done = false;
                return next3;
              }
            }
            next3.done = true;
            return next3;
          };
        };
        function values3(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1, next3 = function next4() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next4.value = iterable[i];
                    next4.done = false;
                    return next4;
                  }
                }
                next4.value = undefined$1;
                next4.done = true;
                return next4;
              };
              return next3.next = next3;
            }
          }
          return {
            next: doneResult
          };
        }
        exports.values = values3;
        function doneResult() {
          return {
            value: undefined$1,
            done: true
          };
        }
        Context.prototype = {
          constructor: Context,
          reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined$1;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined$1;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name in this) {
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined$1;
                }
              }
            }
          },
          stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          },
          dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }
            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;
              if (caught) {
                context.method = "next";
                context.arg = undefined$1;
              }
              return !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          },
          complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          },
          finish: function(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values3(iterable),
              resultName,
              nextLoc
            };
            if (this.method === "next") {
              this.arg = undefined$1;
            }
            return ContinueSentinel;
          }
        };
        return exports;
      }(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        module.exports
      );
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    });
    regenerator = runtime_1;
    iterator$3 = iterator;
    iterator$4 = iterator$3;
    flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
      var targetIndex = start;
      var sourceIndex = 0;
      var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;
      var element;
      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
          if (depth > 0 && isArray(element)) {
            targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
          } else {
            if (targetIndex >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
            target[targetIndex] = element;
          }
          targetIndex++;
        }
        sourceIndex++;
      }
      return targetIndex;
    };
    flattenIntoArray_1 = flattenIntoArray;
    _export({
      target: "Array",
      proto: true
    }, {
      flatMap: function flatMap(callbackfn) {
        var O = toObject(this);
        var sourceLen = toLength(O.length);
        var A;
        aFunction(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return A;
      }
    });
    flatMap2 = entryVirtual("Array").flatMap;
    ArrayPrototype$e = Array.prototype;
    flatMap_1 = function(it2) {
      var own = it2.flatMap;
      return it2 === ArrayPrototype$e || it2 instanceof Array && own === ArrayPrototype$e.flatMap ? flatMap2 : own;
    };
    flatMap$1 = flatMap_1;
    flatMap$2 = flatMap$1;
    createMethod$5 = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        aFunction(callbackfn);
        var O = toObject(that);
        var self2 = indexedObject(O);
        var length2 = toLength(O.length);
        var index2 = IS_RIGHT ? length2 - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while (true) {
          if (index2 in self2) {
            memo = self2[index2];
            index2 += i;
            break;
          }
          index2 += i;
          if (IS_RIGHT ? index2 < 0 : length2 <= index2) {
            throw TypeError("Reduce of empty array with no initial value");
          }
        }
        for (; IS_RIGHT ? index2 >= 0 : length2 > index2; index2 += i) if (index2 in self2) {
          memo = callbackfn(memo, self2[index2], index2, O);
        }
        return memo;
      };
    };
    arrayReduce = {
      // `Array.prototype.reduce` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
      left: createMethod$5(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
      right: createMethod$5(true)
    };
    $reduce = arrayReduce.left;
    STRICT_METHOD$4 = arrayMethodIsStrict("reduce");
    USES_TO_LENGTH$8 = arrayMethodUsesToLength("reduce", {
      1: 0
    });
    _export({
      target: "Array",
      proto: true,
      forced: !STRICT_METHOD$4 || !USES_TO_LENGTH$8
    }, {
      reduce: function reduce(callbackfn) {
        return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    reduce2 = entryVirtual("Array").reduce;
    ArrayPrototype$f = Array.prototype;
    reduce_1 = function(it2) {
      var own = it2.reduce;
      return it2 === ArrayPrototype$f || it2 instanceof Array && own === ArrayPrototype$f.reduce ? reduce2 : own;
    };
    reduce$1 = reduce_1;
    reduce$2 = reduce$1;
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    rnds8 = new Uint8Array(16);
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    moment = createCommonjsModule(function(module, exports) {
      (function(global2, factory) {
        module.exports = factory();
      })(commonjsGlobal, function() {
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray3(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject2(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber2(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map3(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend2(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some3;
        if (Array.prototype.some) {
          some3 = Array.prototype.some;
        } else {
          some3 = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some3.call(flags.parsedDateParts, function(i) {
              return i != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend2(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from3) {
          var i, prop, val;
          if (!isUndefined(from3._isAMomentObject)) {
            to2._isAMomentObject = from3._isAMomentObject;
          }
          if (!isUndefined(from3._i)) {
            to2._i = from3._i;
          }
          if (!isUndefined(from3._f)) {
            to2._f = from3._f;
          }
          if (!isUndefined(from3._l)) {
            to2._l = from3._l;
          }
          if (!isUndefined(from3._strict)) {
            to2._strict = from3._strict;
          }
          if (!isUndefined(from3._tzm)) {
            to2._tzm = from3._tzm;
          }
          if (!isUndefined(from3._isUTC)) {
            to2._isUTC = from3._isUTC;
          }
          if (!isUndefined(from3._offset)) {
            to2._offset = from3._offset;
          }
          if (!isUndefined(from3._pf)) {
            to2._pf = getParsingFlags(from3);
          }
          if (!isUndefined(from3._locale)) {
            to2._locale = from3._locale;
          }
          if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
              prop = momentProperties[i];
              val = from3[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = /* @__PURE__ */ new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment2(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate2(msg, fn) {
          var firstTime = true;
          return extend2(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i, key;
              for (i = 0; i < arguments.length; i++) {
                arg = "";
                if (typeof arguments[i] === "object") {
                  arg += "\n[" + i + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set2(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend2({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
                res[prop] = {};
                extend2(res[prop], parentConfig[prop]);
                extend2(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
              res[prop] = extend2({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys4;
        if (Object.keys) {
          keys4 = Object.keys;
        } else {
          keys4 = function(obj) {
            var i, res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now4) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction(output) ? output.call(mom, now4) : output;
        }
        function zeroFill(number2, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token3, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token3) {
            formatTokenFunctions[token3] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(func.apply(this, arguments), token3);
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array2 = format2.match(formattingTokens), i, length2;
          for (i = 0, length2 = array2.length; i < length2; i++) {
            if (formatTokenFunctions[array2[i]]) {
              array2[i] = formatTokenFunctions[array2[i]];
            } else {
              array2[i] = removeFormattingTokens(array2[i]);
            }
          }
          return function(mom) {
            var output = "", i2;
            for (i2 = 0; i2 < length2; i2++) {
              output += isFunction(array2[i2]) ? array2[i2].call(mom, format2) : array2[i2];
            }
            return output;
          };
        }
        function formatMoment(m, format2) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m);
        }
        function expandFormat(format2, locale2) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number2) {
          return this._ordinal.replace("%d", number2);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number2, withoutSuffix, string2, isFuture) {
          var output = this._relativeTime[string2];
          return isFunction(output) ? output(number2, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number2);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({
                unit: u,
                priority: priorities[u]
              });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number2) {
          if (number2 < 0) {
            return Math.ceil(number2) || 0;
          } else {
            return Math.floor(number2);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$12(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get2(this, unit);
            }
          };
        }
        function get2(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$12(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i;
            for (i = 0; i < prioritized.length; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token3, regex, strictRegex) {
          regexes[token3] = isFunction(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token3, config) {
          if (!hasOwnProp(regexes, token3)) {
            return new RegExp(unescapeFormat(token3));
          }
          return regexes[token3](config._strict, config._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token3, callback) {
          var i, func = callback;
          if (typeof token3 === "string") {
            token3 = [token3];
          }
          if (isNumber2(callback)) {
            func = function(input, array2) {
              array2[callback] = toInt(input);
            };
          }
          for (i = 0; i < token3.length; i++) {
            tokens[token3[i]] = func;
          }
        }
        function addWeekParseToken(token3, callback) {
          addParseToken(token3, function(input, array2, config, token4) {
            config._w = config._w || {};
            callback(input, config._w, config, token4);
          });
        }
        function addTimeToArrayFromToken(token3, input, config) {
          if (input != null && hasOwnProp(tokens, token3)) {
            tokens[token3](input, config._a, config, token3);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf3;
        if (Array.prototype.indexOf) {
          indexOf3 = Array.prototype.indexOf;
        } else {
          indexOf3 = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array2) {
          array2[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array2, config, token3) {
          var month = config._locale.monthsParse(input, token3, config._strict);
          if (month != null) {
            array2[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format2) {
          if (!m) {
            return isArray3(this._months) ? this._months : this._months["standalone"];
          }
          return isArray3(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format2) {
          if (!m) {
            return isArray3(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray3(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2e3, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf3.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf3.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf3.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf3.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
              this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber2(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get2(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
          this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        }
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array2) {
          array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array2) {
          array2[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array2) {
          array2[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token3) {
          week[token3.substr(0, 1)] = toInt(input);
        });
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token3) {
          var weekday = config._locale.weekdaysParse(input, token3, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token3) {
          week[token3] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format2) {
          var weekdays = isArray3(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2e3, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf3.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf3.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf3.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf3.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf3.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf3.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf3.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
              this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
              this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
            }
            if (!this._weekdaysParse[i]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
          this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
          this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token3, lowercase) {
          addFormatToken(token3, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array2, config) {
          var kInput = toInt(input);
          array2[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array2, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array2, config) {
          array2[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array2, config) {
          var pos = input.length - 2;
          array2[HOUR] = toInt(input.substr(0, pos));
          array2[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array2, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array2[HOUR] = toInt(input.substr(0, pos1));
          array2[MINUTE] = toInt(input.substr(pos1, 2));
          array2[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array2, config) {
          var pos = input.length - 2;
          array2[HOUR] = toInt(input.substr(0, pos));
          array2[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array2, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array2[HOUR] = toInt(input.substr(0, pos1));
          array2[MINUTE] = toInt(input.substr(pos1, 2));
          array2[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales2 = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i, minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i = 0, j, next3, locale2, split2;
          while (i < names.length) {
            split2 = normalizeLocale(names[i]).split("-");
            j = split2.length;
            next3 = normalizeLocale(names[i + 1]);
            next3 = next3 ? next3.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split2.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next3 && next3.length >= j && commonPrefix(split2, next3) >= j - 1) {
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales2[name] === void 0 && true && module && module.exports) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = commonjsRequire;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales2[name] = null;
            }
          }
          return locales2[name];
        }
        function getSetGlobalLocale(key, values3) {
          var data2;
          if (key) {
            if (isUndefined(values3)) {
              data2 = getLocale(key);
            } else {
              data2 = defineLocale(key, values3);
            }
            if (data2) {
              globalLocale = data2;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn("Locale " + key + " not found. Did you forget to load it?");
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales2[name] != null) {
              deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
              parentConfig = locales2[name]._config;
            } else if (config.parentLocale != null) {
              if (locales2[config.parentLocale] != null) {
                parentConfig = locales2[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales2[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales2[name];
          } else {
            delete locales2[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales2[name] != null && locales2[name].parentLocale != null) {
              locales2[name].set(mergeConfigs(locales2[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales2[name];
              locales2[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales2[name] != null) {
              if (locales2[name].parentLocale != null) {
                locales2[name] = locales2[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales2[name] != null) {
                delete locales2[name];
              }
            }
          }
          return locales2[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray3(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys4(locales2);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, false], ["YYYY", /\d{4}/, false]], isoTimes = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i, l, string2 = config._i, match5 = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat;
          if (match5) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
              if (isoDates[i][1].exec(match5[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match5[3]) {
              for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match5[3])) {
                  timeFormat = (match5[2] || " ") + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match5[4]) {
              if (tzRegex.exec(match5[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match5 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match5) {
            parsedArray = extractFromRFC2822Strings(match5[4], match5[3], match5[2], match5[5], match5[6], match5[7]);
            if (!checkWeekday(match5[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = /* @__PURE__ */ new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate2("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        });
        function defaults2(a, b, c2) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c2;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults2(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults2(w.W, 1);
            weekday = defaults2(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults2(w.gg, config._a[YEAR], curWeek.year);
            week = defaults2(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string2 = "" + config._i, i, parsedInput, tokens2, token3, skipped, stringLength = string2.length, totalParsedInputLength = 0, era;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          for (i = 0; i < tokens2.length; i++) {
            token3 = tokens2[i];
            parsedInput = (string2.match(getParseRegexForToken(token3, config)) || [])[0];
            if (parsedInput) {
              skipped = string2.substr(0, string2.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string2 = string2.slice(string2.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token3]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token3);
              }
              addTimeToArrayFromToken(token3, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token3);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string2.length > 0) {
            getParsingFlags(config).unusedInput.push(string2);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
          if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = /* @__PURE__ */ new Date(NaN);
            return;
          }
          for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend2(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
          config._a = map3([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({
              nullInput: true
            });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment2(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray3(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray3(input)) {
            config._a = map3(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject2(input)) {
            configFromObject(config);
          } else if (isNumber2(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c2 = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject2(input) && isObjectEmpty(input) || isArray3(input) && input.length === 0) {
            input = void 0;
          }
          c2._isAMomentObject = true;
          c2._useUTC = c2._isUTC = isUTC;
          c2._l = locale2;
          c2._i = input;
          c2._f = format2;
          c2._strict = strict;
          return createFromConfig(c2);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate2("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }), prototypeMax = deprecate2("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        });
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray3(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }
        function min2() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max2() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now3 = function() {
          return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
        };
        var ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf3.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
          minutes2 * 6e4 + // 1000 * 60
          hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number2) {
          if (number2 < 0) {
            return Math.round(-1 * number2) * -1;
          } else {
            return Math.round(number2);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token3, separator) {
          addFormatToken(token3, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array2, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string2) {
          var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment2(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset2, "m"), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c2 = {}, other;
          copyConfig(c2, this);
          c2 = prepareConfig(c2);
          if (c2._a) {
            other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
            this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match5 = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber2(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match5 = aspNetRegex.exec(input)) {
            sign2 = match5[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match5[DATE]) * sign2,
              h: toInt(match5[HOUR]) * sign2,
              m: toInt(match5[MINUTE]) * sign2,
              s: toInt(match5[SECOND]) * sign2,
              ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
              // the millisecond decimal point is included in the match
            };
          } else if (match5 = isoRegex.exec(input)) {
            sign2 = match5[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match5[2], sign2),
              M: parseIso(match5[3], sign2),
              w: parseIso(match5[4], sign2),
              d: parseIso(match5[5], sign2),
              h: parseIso(match5[6], sign2),
              m: parseIso(match5[7], sign2),
              s: parseIso(match5[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return {
              milliseconds: 0,
              months: 0
            };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get2(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$12(mom, "Date", get2(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString2(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment2(input) || isDate(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray3(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber2(item) && isString2(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now4) {
          var diff2 = myMoment.diff(now4, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now4 = time || createLocal(), sod = cloneWithOffset(now4, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now4) : formats[format2]);
          return this.format(output || this.localeData().calendar(format2, this, createLocal(now4)));
        }
        function clone2() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment2(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment2(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from3, to2, units, inclusivity) {
          var localFrom = isMoment2(from3) ? from3 : createLocal(from3), localTo = isMoment2(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment2(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            // 1000
            case "minute":
              output = (this - that) / 6e4;
              break;
            // 1000 * 60
            case "hour":
              output = (this - that) / 36e5;
              break;
            // 1000 * 60 * 60
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            // 1000 * 60 * 60 * 24, negate dst
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString3() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
          }
          if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from2(time, withoutSuffix) {
          if (this.isValid() && (isMoment2(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              to: this,
              from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment2(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              from: this,
              to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate2("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
            case "isoWeek":
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case "isoWeek":
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray2() {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }
        function toObject2() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend2({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array2, config, token3) {
          var era = config._locale.erasParse(input, token3, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array2, config, token3) {
          var match5;
          if (config._locale._eraYearOrdinalRegex) {
            match5 = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array2[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
          } else {
            array2[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format2) {
          var i, l, date, eras = this._eras || getLocale("en")._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i, l, dir, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token3, getter) {
          addFormatToken(0, [token3, token3.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token3) {
          week[token3.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(["gg", "GG"], function(input, week, config, token3) {
          week[token3] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array2) {
          array2[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array2) {
          array2[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array2, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token2, getSetMillisecond;
        for (token2 = "SSSS"; token2.length <= 9; token2 += "S") {
          addRegexToken(token2, matchUnsigned);
        }
        function parseMs(input, array2) {
          array2[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token2 = "S"; token2.length <= 9; token2 += "S") {
          addParseToken(token2, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone2;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from2;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray2;
        proto.toObject = toObject2;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString3;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate2("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
        proto.months = deprecate2("months accessor is deprecated. Use month instead", getSetMonth);
        proto.years = deprecate2("years accessor is deprecated. Use year instead", getSetYear);
        proto.zone = deprecate2("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
        proto.isDSTShifted = deprecate2("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string2) {
          return string2;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set2;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$12(format2, index2, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index2);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index2, field) {
          if (isNumber2(format2)) {
            index2 = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index2 != null) {
            return get$12(format2, index2, field, "month");
          }
          var i, out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$12(format2, i, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index2, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber2(format2)) {
              index2 = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index2 = format2;
            localeSorted = false;
            if (isNumber2(format2)) {
              index2 = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
          if (index2 != null) {
            return get$12(format2, (index2 + shift) % 7, field, "day");
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$12(format2, (i + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index2) {
          return listMonthsImpl(format2, index2, "months");
        }
        function listMonthsShort(format2, index2) {
          return listMonthsImpl(format2, index2, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index2) {
          return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index2) {
          return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index2) {
          return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [{
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          }, {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number2) {
            var b = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number2 + output;
          }
        });
        hooks.lang = deprecate2("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
        hooks.langData = deprecate2("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
        var mathAbs = Math.abs;
        function abs2() {
          var data2 = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data2.milliseconds = mathAbs(data2.milliseconds);
          data2.seconds = mathAbs(data2.seconds);
          data2.minutes = mathAbs(data2.minutes);
          data2.hours = mathAbs(data2.hours);
          data2.months = mathAbs(data2.months);
          data2.years = mathAbs(data2.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number2) {
          if (number2 < 0) {
            return Math.floor(number2);
          } else {
            return Math.ceil(number2);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data2 = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data2.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data2.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data2.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data2.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data2.days = days2;
          data2.months = months2;
          data2.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              // Math.floor prevents floating point math errors here
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$1() {
          return createDuration(this);
        }
        function get$22(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round2 = Math.round, thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11
          // months to year
        };
        function substituteTimeAgo(string2, number2, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number2 || 1, !!withoutSuffix, string2, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round2;
          }
          if (typeof roundingFunction === "function") {
            round2 = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$12 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$12(this._milliseconds) / 1e3, days2 = abs$12(this._days), months2 = abs$12(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs2;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$22;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate2("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array2, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array2, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.27.0";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min2;
        hooks.max = max2;
        hooks.now = now3;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment2;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          // <input type="datetime-local" step="0.001" />
          DATE: "YYYY-MM-DD",
          // <input type="date" />
          TIME: "HH:mm",
          // <input type="time" />
          TIME_SECONDS: "HH:mm:ss",
          // <input type="time" step="1" />
          TIME_MS: "HH:mm:ss.SSS",
          // <input type="time" step="0.001" />
          WEEK: "GGGG-[W]WW",
          // <input type="week" />
          MONTH: "YYYY-MM"
          // <input type="month" />
        };
        return hooks;
      });
    });
    SimpleDataPipe = function() {
      function SimpleDataPipe2(_source, _transformers, _target) {
        var _context, _context2, _context3;
        classCallCheck(this, SimpleDataPipe2);
        this._source = _source;
        this._transformers = _transformers;
        this._target = _target;
        this._listeners = {
          add: bind$2(_context = this._add).call(_context, this),
          remove: bind$2(_context2 = this._remove).call(_context2, this),
          update: bind$2(_context3 = this._update).call(_context3, this)
        };
      }
      createClass(SimpleDataPipe2, [{
        key: "all",
        value: function all() {
          this._target.update(this._transformItems(this._source.get()));
          return this;
        }
        /** @inheritdoc */
      }, {
        key: "start",
        value: function start() {
          this._source.on("add", this._listeners.add);
          this._source.on("remove", this._listeners.remove);
          this._source.on("update", this._listeners.update);
          return this;
        }
        /** @inheritdoc */
      }, {
        key: "stop",
        value: function stop() {
          this._source.off("add", this._listeners.add);
          this._source.off("remove", this._listeners.remove);
          this._source.off("update", this._listeners.update);
          return this;
        }
        /**
         * Apply the transformers to the items.
         *
         * @param items - The items to be transformed.
         *
         * @returns The transformed items.
         */
      }, {
        key: "_transformItems",
        value: function _transformItems(items) {
          var _context4;
          return reduce$2(_context4 = this._transformers).call(_context4, function(items2, transform) {
            return transform(items2);
          }, items);
        }
        /**
         * Handle an add event.
         *
         * @param _name - Ignored.
         * @param payload - The payload containing the ids of the added items.
         */
      }, {
        key: "_add",
        value: function _add(_name, payload) {
          if (payload == null) {
            return;
          }
          this._target.add(this._transformItems(this._source.get(payload.items)));
        }
        /**
         * Handle an update event.
         *
         * @param _name - Ignored.
         * @param payload - The payload containing the ids of the updated items.
         */
      }, {
        key: "_update",
        value: function _update(_name, payload) {
          if (payload == null) {
            return;
          }
          this._target.update(this._transformItems(this._source.get(payload.items)));
        }
        /**
         * Handle a remove event.
         *
         * @param _name - Ignored.
         * @param payload - The payload containing the data of the removed items.
         */
      }, {
        key: "_remove",
        value: function _remove(_name, payload) {
          if (payload == null) {
            return;
          }
          this._target.remove(this._transformItems(payload.oldData));
        }
      }]);
      return SimpleDataPipe2;
    }();
    DataPipeUnderConstruction = function() {
      function DataPipeUnderConstruction2(_source) {
        classCallCheck(this, DataPipeUnderConstruction2);
        this._source = _source;
        this._transformers = [];
      }
      createClass(DataPipeUnderConstruction2, [{
        key: "filter",
        value: function filter3(callback) {
          this._transformers.push(function(input) {
            return filter$2(input).call(input, callback);
          });
          return this;
        }
        /**
         * Map each source item to a new type.
         *
         * @param callback - A mapping function that takes a source item and returns
         * corresponding mapped item.
         *
         * @typeparam TI - Target item type.
         * @typeparam TP - Target item type's id property name.
         *
         * @returns This factory for further configuration.
         */
      }, {
        key: "map",
        value: function map3(callback) {
          this._transformers.push(function(input) {
            return map$2(input).call(input, callback);
          });
          return this;
        }
        /**
         * Map each source item to zero or more items of a new type.
         *
         * @param callback - A mapping function that takes a source item and returns
         * an array of corresponding mapped items.
         *
         * @typeparam TI - Target item type.
         * @typeparam TP - Target item type's id property name.
         *
         * @returns This factory for further configuration.
         */
      }, {
        key: "flatMap",
        value: function flatMap3(callback) {
          this._transformers.push(function(input) {
            return flatMap$2(input).call(input, callback);
          });
          return this;
        }
        /**
         * Connect this pipe to given data set.
         *
         * @param target - The data set that will receive the items from this pipe.
         *
         * @returns The pipe connected between given data sets and performing
         * configured transformation on the processed items.
         */
      }, {
        key: "to",
        value: function to(target) {
          return new SimpleDataPipe(this._source, this._transformers, target);
        }
      }]);
      return DataPipeUnderConstruction2;
    }();
    ASPDateRegex = /^\/?Date\((-?\d+)/i;
    Queue = function() {
      function Queue2(options2) {
        classCallCheck(this, Queue2);
        this._queue = [];
        this._timeout = null;
        this._extended = null;
        this.delay = null;
        this.max = Infinity;
        this.setOptions(options2);
      }
      createClass(Queue2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 && typeof options2.delay !== "undefined") {
            this.delay = options2.delay;
          }
          if (options2 && typeof options2.max !== "undefined") {
            this.max = options2.max;
          }
          this._flushIfNeeded();
        }
        /**
         * Extend an object with queuing functionality.
         * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
         *
         * @param object - The object to be extended.
         * @param options - Additional options.
         *
         * @returns The created queue.
         */
      }, {
        key: "destroy",
        /**
         * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
         */
        value: function destroy() {
          this.flush();
          if (this._extended) {
            var object2 = this._extended.object;
            var methods = this._extended.methods;
            for (var i = 0; i < methods.length; i++) {
              var method = methods[i];
              if (method.original) {
                object2[method.name] = method.original;
              } else {
                delete object2[method.name];
              }
            }
            this._extended = null;
          }
        }
        /**
         * Replace a method on an object with a queued version.
         *
         * @param object - Object having the method.
         * @param method - The method name.
         */
      }, {
        key: "replace",
        value: function replace(object2, method) {
          var me = this;
          var original = object2[method];
          if (!original) {
            throw new Error("Method " + method + " undefined");
          }
          object2[method] = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            me.queue({
              args,
              fn: original,
              context: this
            });
          };
        }
        /**
         * Queue a call.
         *
         * @param entry - The function or entry to be queued.
         */
      }, {
        key: "queue",
        value: function queue(entry) {
          if (typeof entry === "function") {
            this._queue.push({
              fn: entry
            });
          } else {
            this._queue.push(entry);
          }
          this._flushIfNeeded();
        }
        /**
         * Check whether the queue needs to be flushed.
         */
      }, {
        key: "_flushIfNeeded",
        value: function _flushIfNeeded() {
          var _this = this;
          if (this._queue.length > this.max) {
            this.flush();
          }
          if (this._timeout != null) {
            clearTimeout(this._timeout);
            this._timeout = null;
          }
          if (this.queue.length > 0 && typeof this.delay === "number") {
            this._timeout = setTimeout$2(function() {
              _this.flush();
            }, this.delay);
          }
        }
        /**
         * Flush all queued calls
         */
      }, {
        key: "flush",
        value: function flush() {
          var _context5, _context6;
          forEach$2(_context5 = splice$2(_context6 = this._queue).call(_context6, 0)).call(_context5, function(entry) {
            entry.fn.apply(entry.context || entry.fn, entry.args || []);
          });
        }
      }], [{
        key: "extend",
        value: function extend2(object2, options2) {
          var queue = new Queue2(options2);
          if (object2.flush !== void 0) {
            throw new Error("Target object already has a property flush");
          }
          object2.flush = function() {
            queue.flush();
          };
          var methods = [{
            name: "flush",
            original: void 0
          }];
          if (options2 && options2.replace) {
            for (var i = 0; i < options2.replace.length; i++) {
              var name = options2.replace[i];
              methods.push({
                name,
                // @TODO: better solution?
                original: object2[name]
              });
              queue.replace(object2, name);
            }
          }
          queue._extended = {
            object: object2,
            methods
          };
          return queue;
        }
      }]);
      return Queue2;
    }();
    DataSetPart = function() {
      function DataSetPart2() {
        classCallCheck(this, DataSetPart2);
        this._subscribers = {
          "*": [],
          add: [],
          remove: [],
          update: []
        };
        this.subscribe = DataSetPart2.prototype.on;
        this.unsubscribe = DataSetPart2.prototype.off;
      }
      createClass(DataSetPart2, [{
        key: "_trigger",
        value: function _trigger(event, payload, senderId) {
          var _context7, _context8;
          if (event === "*") {
            throw new Error("Cannot trigger event *");
          }
          forEach$2(_context7 = concat$2(_context8 = []).call(_context8, toConsumableArray(this._subscribers[event]), toConsumableArray(this._subscribers["*"]))).call(_context7, function(subscriber) {
            subscriber(event, payload, senderId != null ? senderId : null);
          });
        }
        /**
         * Subscribe to an event, add an event listener.
         *
         * @remarks Non-function callbacks are ignored.
         *
         * @param event - Event name.
         * @param callback - Callback method.
         */
      }, {
        key: "on",
        value: function on(event, callback) {
          if (typeof callback === "function") {
            this._subscribers[event].push(callback);
          }
        }
        /**
         * Unsubscribe from an event, remove an event listener.
         *
         * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
         *
         * @param event - Event name.
         * @param callback - Callback method.
         */
      }, {
        key: "off",
        value: function off(event, callback) {
          var _context9;
          this._subscribers[event] = filter$2(_context9 = this._subscribers[event]).call(_context9, function(subscriber) {
            return subscriber !== callback;
          });
        }
      }]);
      return DataSetPart2;
    }();
    DataStream = function() {
      function DataStream2(_pairs) {
        classCallCheck(this, DataStream2);
        this._pairs = _pairs;
      }
      createClass(DataStream2, [{
        key: iterator$4,
        value: regenerator.mark(function value() {
          var _iterator, _step, _step$value, id2, item;
          return regenerator.wrap(function value$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _iterator = _createForOfIteratorHelper$1(this._pairs);
                  _context10.prev = 1;
                  _iterator.s();
                case 3:
                  if ((_step = _iterator.n()).done) {
                    _context10.next = 9;
                    break;
                  }
                  _step$value = slicedToArray(_step.value, 2), id2 = _step$value[0], item = _step$value[1];
                  _context10.next = 7;
                  return [id2, item];
                case 7:
                  _context10.next = 3;
                  break;
                case 9:
                  _context10.next = 14;
                  break;
                case 11:
                  _context10.prev = 11;
                  _context10.t0 = _context10["catch"](1);
                  _iterator.e(_context10.t0);
                case 14:
                  _context10.prev = 14;
                  _iterator.f();
                  return _context10.finish(14);
                case 17:
                case "end":
                  return _context10.stop();
              }
            }
          }, value, this, [[1, 11, 14, 17]]);
        })
        /**
         * Return an iterable of key, value pairs for every entry in the stream.
         */
      }, {
        key: "entries",
        value: regenerator.mark(function entries2() {
          var _iterator2, _step2, _step2$value, id2, item;
          return regenerator.wrap(function entries$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  _iterator2 = _createForOfIteratorHelper$1(this._pairs);
                  _context11.prev = 1;
                  _iterator2.s();
                case 3:
                  if ((_step2 = _iterator2.n()).done) {
                    _context11.next = 9;
                    break;
                  }
                  _step2$value = slicedToArray(_step2.value, 2), id2 = _step2$value[0], item = _step2$value[1];
                  _context11.next = 7;
                  return [id2, item];
                case 7:
                  _context11.next = 3;
                  break;
                case 9:
                  _context11.next = 14;
                  break;
                case 11:
                  _context11.prev = 11;
                  _context11.t0 = _context11["catch"](1);
                  _iterator2.e(_context11.t0);
                case 14:
                  _context11.prev = 14;
                  _iterator2.f();
                  return _context11.finish(14);
                case 17:
                case "end":
                  return _context11.stop();
              }
            }
          }, entries2, this, [[1, 11, 14, 17]]);
        })
        /**
         * Return an iterable of keys in the stream.
         */
      }, {
        key: "keys",
        value: regenerator.mark(function keys4() {
          var _iterator3, _step3, _step3$value, id2;
          return regenerator.wrap(function keys$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  _iterator3 = _createForOfIteratorHelper$1(this._pairs);
                  _context12.prev = 1;
                  _iterator3.s();
                case 3:
                  if ((_step3 = _iterator3.n()).done) {
                    _context12.next = 9;
                    break;
                  }
                  _step3$value = slicedToArray(_step3.value, 1), id2 = _step3$value[0];
                  _context12.next = 7;
                  return id2;
                case 7:
                  _context12.next = 3;
                  break;
                case 9:
                  _context12.next = 14;
                  break;
                case 11:
                  _context12.prev = 11;
                  _context12.t0 = _context12["catch"](1);
                  _iterator3.e(_context12.t0);
                case 14:
                  _context12.prev = 14;
                  _iterator3.f();
                  return _context12.finish(14);
                case 17:
                case "end":
                  return _context12.stop();
              }
            }
          }, keys4, this, [[1, 11, 14, 17]]);
        })
        /**
         * Return an iterable of values in the stream.
         */
      }, {
        key: "values",
        value: regenerator.mark(function values3() {
          var _iterator4, _step4, _step4$value, item;
          return regenerator.wrap(function values$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  _iterator4 = _createForOfIteratorHelper$1(this._pairs);
                  _context13.prev = 1;
                  _iterator4.s();
                case 3:
                  if ((_step4 = _iterator4.n()).done) {
                    _context13.next = 9;
                    break;
                  }
                  _step4$value = slicedToArray(_step4.value, 2), item = _step4$value[1];
                  _context13.next = 7;
                  return item;
                case 7:
                  _context13.next = 3;
                  break;
                case 9:
                  _context13.next = 14;
                  break;
                case 11:
                  _context13.prev = 11;
                  _context13.t0 = _context13["catch"](1);
                  _iterator4.e(_context13.t0);
                case 14:
                  _context13.prev = 14;
                  _iterator4.f();
                  return _context13.finish(14);
                case 17:
                case "end":
                  return _context13.stop();
              }
            }
          }, values3, this, [[1, 11, 14, 17]]);
        })
        /**
         * Return an array containing all the ids in this stream.
         *
         * @remarks
         * The array may contain duplicities.
         *
         * @returns The array with all ids from this stream.
         */
      }, {
        key: "toIdArray",
        value: function toIdArray() {
          var _context14;
          return map$2(_context14 = toConsumableArray(this._pairs)).call(_context14, function(pair) {
            return pair[0];
          });
        }
        /**
         * Return an array containing all the items in this stream.
         *
         * @remarks
         * The array may contain duplicities.
         *
         * @returns The array with all items from this stream.
         */
      }, {
        key: "toItemArray",
        value: function toItemArray() {
          var _context15;
          return map$2(_context15 = toConsumableArray(this._pairs)).call(_context15, function(pair) {
            return pair[1];
          });
        }
        /**
         * Return an array containing all the entries in this stream.
         *
         * @remarks
         * The array may contain duplicities.
         *
         * @returns The array with all entries from this stream.
         */
      }, {
        key: "toEntryArray",
        value: function toEntryArray() {
          return toConsumableArray(this._pairs);
        }
        /**
         * Return an object map containing all the items in this stream accessible by ids.
         *
         * @remarks
         * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
         *
         * @returns The object map of all id  item pairs from this stream.
         */
      }, {
        key: "toObjectMap",
        value: function toObjectMap() {
          var map3 = create$2(null);
          var _iterator5 = _createForOfIteratorHelper$1(this._pairs), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var _step5$value = slicedToArray(_step5.value, 2), id2 = _step5$value[0], item = _step5$value[1];
              map3[id2] = item;
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          return map3;
        }
        /**
         * Return a map containing all the items in this stream accessible by ids.
         *
         * @returns The map of all id  item pairs from this stream.
         */
      }, {
        key: "toMap",
        value: function toMap() {
          return new map$5(this._pairs);
        }
        /**
         * Return a set containing all the (unique) ids in this stream.
         *
         * @returns The set of all ids from this stream.
         */
      }, {
        key: "toIdSet",
        value: function toIdSet() {
          return new set$3(this.toIdArray());
        }
        /**
         * Return a set containing all the (unique) items in this stream.
         *
         * @returns The set of all items from this stream.
         */
      }, {
        key: "toItemSet",
        value: function toItemSet() {
          return new set$3(this.toItemArray());
        }
        /**
         * Cache the items from this stream.
         *
         * @remarks
         * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
         * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
         *
         * ## Example
         * ```javascript
         * const ds = new DataSet([])
         *
         * const cachedStream = ds.stream()
         *   .filter()
         *   .sort()
         *   .map()
         *   .cached() // Data are fetched, processed and cached here.
         *
         * ds.clear()
         * chachedStream // Still has all the items.
         * ```
         *
         * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
         */
      }, {
        key: "cache",
        value: function cache2() {
          return new DataStream2(toConsumableArray(this._pairs));
        }
        /**
         * Get the distinct values of given property.
         *
         * @param callback - The function that picks and possibly converts the property.
         *
         * @typeparam T - The type of the distinct value.
         *
         * @returns A set of all distinct properties.
         */
      }, {
        key: "distinct",
        value: function distinct(callback) {
          var set2 = new set$3();
          var _iterator6 = _createForOfIteratorHelper$1(this._pairs), _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
              var _step6$value = slicedToArray(_step6.value, 2), id2 = _step6$value[0], item = _step6$value[1];
              set2.add(callback(item, id2));
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          return set2;
        }
        /**
         * Filter the items of the stream.
         *
         * @param callback - The function that decides whether an item will be included.
         *
         * @returns A new data stream with the filtered items.
         */
      }, {
        key: "filter",
        value: function filter3(callback) {
          var pairs = this._pairs;
          return new DataStream2(defineProperty$7({}, iterator$4, regenerator.mark(function _callee() {
            var _iterator7, _step7, _step7$value, id2, item;
            return regenerator.wrap(function _callee$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    _iterator7 = _createForOfIteratorHelper$1(pairs);
                    _context16.prev = 1;
                    _iterator7.s();
                  case 3:
                    if ((_step7 = _iterator7.n()).done) {
                      _context16.next = 10;
                      break;
                    }
                    _step7$value = slicedToArray(_step7.value, 2), id2 = _step7$value[0], item = _step7$value[1];
                    if (!callback(item, id2)) {
                      _context16.next = 8;
                      break;
                    }
                    _context16.next = 8;
                    return [id2, item];
                  case 8:
                    _context16.next = 3;
                    break;
                  case 10:
                    _context16.next = 15;
                    break;
                  case 12:
                    _context16.prev = 12;
                    _context16.t0 = _context16["catch"](1);
                    _iterator7.e(_context16.t0);
                  case 15:
                    _context16.prev = 15;
                    _iterator7.f();
                    return _context16.finish(15);
                  case 18:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee, null, [[1, 12, 15, 18]]);
          })));
        }
        /**
         * Execute a callback for each item of the stream.
         *
         * @param callback - The function that will be invoked for each item.
         */
      }, {
        key: "forEach",
        value: function forEach3(callback) {
          var _iterator8 = _createForOfIteratorHelper$1(this._pairs), _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
              var _step8$value = slicedToArray(_step8.value, 2), id2 = _step8$value[0], item = _step8$value[1];
              callback(item, id2);
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
        /**
         * Map the items into a different type.
         *
         * @param callback - The function that does the conversion.
         *
         * @typeparam Mapped - The type of the item after mapping.
         *
         * @returns A new data stream with the mapped items.
         */
      }, {
        key: "map",
        value: function map3(callback) {
          var pairs = this._pairs;
          return new DataStream2(defineProperty$7({}, iterator$4, regenerator.mark(function _callee2() {
            var _iterator9, _step9, _step9$value, id2, item;
            return regenerator.wrap(function _callee2$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    _iterator9 = _createForOfIteratorHelper$1(pairs);
                    _context17.prev = 1;
                    _iterator9.s();
                  case 3:
                    if ((_step9 = _iterator9.n()).done) {
                      _context17.next = 9;
                      break;
                    }
                    _step9$value = slicedToArray(_step9.value, 2), id2 = _step9$value[0], item = _step9$value[1];
                    _context17.next = 7;
                    return [id2, callback(item, id2)];
                  case 7:
                    _context17.next = 3;
                    break;
                  case 9:
                    _context17.next = 14;
                    break;
                  case 11:
                    _context17.prev = 11;
                    _context17.t0 = _context17["catch"](1);
                    _iterator9.e(_context17.t0);
                  case 14:
                    _context17.prev = 14;
                    _iterator9.f();
                    return _context17.finish(14);
                  case 17:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee2, null, [[1, 11, 14, 17]]);
          })));
        }
        /**
         * Get the item with the maximum value of given property.
         *
         * @param callback - The function that picks and possibly converts the property.
         *
         * @returns The item with the maximum if found otherwise null.
         */
      }, {
        key: "max",
        value: function max2(callback) {
          var iter = getIterator$1(this._pairs);
          var curr = iter.next();
          if (curr.done) {
            return null;
          }
          var maxItem = curr.value[1];
          var maxValue = callback(curr.value[1], curr.value[0]);
          while (!(curr = iter.next()).done) {
            var _curr$value = slicedToArray(curr.value, 2), id2 = _curr$value[0], item = _curr$value[1];
            var _value = callback(item, id2);
            if (_value > maxValue) {
              maxValue = _value;
              maxItem = item;
            }
          }
          return maxItem;
        }
        /**
         * Get the item with the minimum value of given property.
         *
         * @param callback - The function that picks and possibly converts the property.
         *
         * @returns The item with the minimum if found otherwise null.
         */
      }, {
        key: "min",
        value: function min2(callback) {
          var iter = getIterator$1(this._pairs);
          var curr = iter.next();
          if (curr.done) {
            return null;
          }
          var minItem = curr.value[1];
          var minValue = callback(curr.value[1], curr.value[0]);
          while (!(curr = iter.next()).done) {
            var _curr$value2 = slicedToArray(curr.value, 2), id2 = _curr$value2[0], item = _curr$value2[1];
            var _value2 = callback(item, id2);
            if (_value2 < minValue) {
              minValue = _value2;
              minItem = item;
            }
          }
          return minItem;
        }
        /**
         * Reduce the items into a single value.
         *
         * @param callback - The function that does the reduction.
         * @param accumulator - The initial value of the accumulator.
         *
         * @typeparam T - The type of the accumulated value.
         *
         * @returns The reduced value.
         */
      }, {
        key: "reduce",
        value: function reduce3(callback, accumulator) {
          var _iterator10 = _createForOfIteratorHelper$1(this._pairs), _step10;
          try {
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
              var _step10$value = slicedToArray(_step10.value, 2), id2 = _step10$value[0], item = _step10$value[1];
              accumulator = callback(accumulator, item, id2);
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }
          return accumulator;
        }
        /**
         * Sort the items.
         *
         * @param callback - Item comparator.
         *
         * @returns A new stream with sorted items.
         */
      }, {
        key: "sort",
        value: function sort3(callback) {
          var _this2 = this;
          return new DataStream2(defineProperty$7({}, iterator$4, function() {
            var _context18;
            return getIterator$1(sort$2(_context18 = toConsumableArray(_this2._pairs)).call(_context18, function(_ref, _ref2) {
              var _ref3 = slicedToArray(_ref, 2), idA = _ref3[0], itemA = _ref3[1];
              var _ref4 = slicedToArray(_ref2, 2), idB = _ref4[0], itemB = _ref4[1];
              return callback(itemA, itemB, idA, idB);
            }));
          }));
        }
      }]);
      return DataStream2;
    }();
    warnTypeCorectionDeprecation = function warnTypeCorectionDeprecation2() {
      console.warn("Type coercion has been deprecated. Please, use data pipes instead. See https://visjs.github.io/vis-data/data/datapipe.html#TypeCoercion for more details with working migration example.");
    };
    DataSet = function(_DataSetPart) {
      inherits(DataSet2, _DataSetPart);
      var _super = _createSuper(DataSet2);
      function DataSet2(data2, options2) {
        var _this3;
        classCallCheck(this, DataSet2);
        _this3 = _super.call(this);
        if (data2 && !isArray$5(data2)) {
          options2 = data2;
          data2 = [];
        }
        _this3._options = options2 || {};
        _this3._data = new map$5();
        _this3.length = 0;
        _this3._idProp = _this3._options.fieldId || "id";
        _this3._type = {};
        if (_this3._options.type) {
          warnTypeCorectionDeprecation();
          var fields = keys$3(_this3._options.type);
          for (var i = 0, len = fields.length; i < len; i++) {
            var field = fields[i];
            var _value3 = _this3._options.type[field];
            if (_value3 == "Date" || _value3 == "ISODate" || _value3 == "ASPDate") {
              _this3._type[field] = "Date";
            } else {
              _this3._type[field] = _value3;
            }
          }
        }
        if (data2 && data2.length) {
          _this3.add(data2);
        }
        _this3.setOptions(options2);
        return _this3;
      }
      createClass(DataSet2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 && options2.queue !== void 0) {
            if (options2.queue === false) {
              if (this._queue) {
                this._queue.destroy();
                delete this._queue;
              }
            } else {
              if (!this._queue) {
                this._queue = Queue.extend(this, {
                  replace: ["add", "update", "remove"]
                });
              }
              if (options2.queue && _typeof_1(options2.queue) === "object") {
                this._queue.setOptions(options2.queue);
              }
            }
          }
        }
        /**
         * Add a data item or an array with items.
         *
         * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
         *
         * ## Example
         *
         * ```javascript
         * // create a DataSet
         * const data = new vis.DataSet()
         *
         * // add items
         * const ids = data.add([
         *   { id: 1, text: 'item 1' },
         *   { id: 2, text: 'item 2' },
         *   { text: 'item without an id' }
         * ])
         *
         * console.log(ids) // [1, 2, '<UUIDv4>']
         * ```
         *
         * @param data - Items to be added (ids will be generated if missing).
         * @param senderId - Sender id.
         *
         * @returns addedIds - Array with the ids (generated if not present) of the added items.
         *
         * @throws When an item with the same id as any of the added items already exists.
         */
      }, {
        key: "add",
        value: function add(data2, senderId) {
          var _this4 = this;
          var addedIds = [];
          var id2;
          if (isArray$5(data2)) {
            var idsToAdd = map$2(data2).call(data2, function(d) {
              return d[_this4._idProp];
            });
            if (some$2(idsToAdd).call(idsToAdd, function(id3) {
              return _this4._data.has(id3);
            })) {
              throw new Error("A duplicate id was found in the parameter array.");
            }
            for (var i = 0, len = data2.length; i < len; i++) {
              id2 = this._addItem(data2[i]);
              addedIds.push(id2);
            }
          } else if (data2 && _typeof_1(data2) === "object") {
            id2 = this._addItem(data2);
            addedIds.push(id2);
          } else {
            throw new Error("Unknown dataType");
          }
          if (addedIds.length) {
            this._trigger("add", {
              items: addedIds
            }, senderId);
          }
          return addedIds;
        }
        /**
         * Update existing items. When an item does not exist, it will be created.
         *
         * @remarks
         * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
         *
         * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
         *
         * ## Example
         *
         * ```javascript
         * // create a DataSet
         * const data = new vis.DataSet([
         *   { id: 1, text: 'item 1' },
         *   { id: 2, text: 'item 2' },
         *   { id: 3, text: 'item 3' }
         * ])
         *
         * // update items
         * const ids = data.update([
         *   { id: 2, text: 'item 2 (updated)' },
         *   { id: 4, text: 'item 4 (new)' }
         * ])
         *
         * console.log(ids) // [2, 4]
         * ```
         *
         * ## Warning for TypeScript users
         * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
         *
         * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
         * @param senderId - Sender id.
         *
         * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
         *
         * @throws When the supplied data is neither an item nor an array of items.
         */
      }, {
        key: "update",
        value: function update(data2, senderId) {
          var _this5 = this;
          var addedIds = [];
          var updatedIds = [];
          var oldData = [];
          var updatedData = [];
          var idProp = this._idProp;
          var addOrUpdate = function addOrUpdate2(item) {
            var origId = item[idProp];
            if (origId != null && _this5._data.has(origId)) {
              var fullItem = item;
              var oldItem = assign$2({}, _this5._data.get(origId));
              var id2 = _this5._updateItem(fullItem);
              updatedIds.push(id2);
              updatedData.push(fullItem);
              oldData.push(oldItem);
            } else {
              var _id = _this5._addItem(item);
              addedIds.push(_id);
            }
          };
          if (isArray$5(data2)) {
            for (var i = 0, len = data2.length; i < len; i++) {
              if (data2[i] && _typeof_1(data2[i]) === "object") {
                addOrUpdate(data2[i]);
              } else {
                console.warn("Ignoring input item, which is not an object at index " + i);
              }
            }
          } else if (data2 && _typeof_1(data2) === "object") {
            addOrUpdate(data2);
          } else {
            throw new Error("Unknown dataType");
          }
          if (addedIds.length) {
            this._trigger("add", {
              items: addedIds
            }, senderId);
          }
          if (updatedIds.length) {
            var props = {
              items: updatedIds,
              oldData,
              data: updatedData
            };
            this._trigger("update", props, senderId);
          }
          return concat$2(addedIds).call(addedIds, updatedIds);
        }
        /**
         * Update existing items. When an item does not exist, an error will be thrown.
         *
         * @remarks
         * The provided properties will be deeply merged into the existing item.
         * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
         *
         * After the items are updated, the DataSet will trigger an event `update`.
         * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
         *
         * ## Example
         *
         * ```javascript
         * // create a DataSet
         * const data = new vis.DataSet([
         *   { id: 1, text: 'item 1' },
         *   { id: 2, text: 'item 2' },
         *   { id: 3, text: 'item 3' },
         * ])
         *
         * // update items
         * const ids = data.update([
         *   { id: 2, text: 'item 2 (updated)' }, // works
         *   // { id: 4, text: 'item 4 (new)' }, // would throw
         *   // { text: 'item 4 (new)' }, // would also throw
         * ])
         *
         * console.log(ids) // [2]
         * ```
         *
         * @param data - Updates (the id and optionally other props) to the items in this data set.
         * @param senderId - Sender id.
         *
         * @returns updatedIds - The ids of the updated items.
         *
         * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
         */
      }, {
        key: "updateOnly",
        value: function updateOnly(data2, senderId) {
          var _context20, _this6 = this;
          if (!isArray$5(data2)) {
            data2 = [data2];
          }
          var updateEventData = map$2(_context20 = map$2(data2).call(data2, function(update) {
            var oldData = _this6._data.get(update[_this6._idProp]);
            if (oldData == null) {
              throw new Error("Updating non-existent items is not allowed.");
            }
            return {
              oldData,
              update
            };
          })).call(_context20, function(_ref5) {
            var oldData = _ref5.oldData, update = _ref5.update;
            var id2 = oldData[_this6._idProp];
            var updatedData = pureDeepObjectAssign(oldData, update);
            _this6._data.set(id2, updatedData);
            return {
              id: id2,
              oldData,
              updatedData
            };
          });
          if (updateEventData.length) {
            var props = {
              items: map$2(updateEventData).call(updateEventData, function(value) {
                return value.id;
              }),
              oldData: map$2(updateEventData).call(updateEventData, function(value) {
                return value.oldData;
              }),
              data: map$2(updateEventData).call(updateEventData, function(value) {
                return value.updatedData;
              })
            };
            this._trigger("update", props, senderId);
            return props.items;
          } else {
            return [];
          }
        }
        /** @inheritdoc */
      }, {
        key: "get",
        value: function get2(first2, second) {
          var id2 = void 0;
          var ids = void 0;
          var options2 = void 0;
          if (isId(first2)) {
            id2 = first2;
            options2 = second;
          } else if (isArray$5(first2)) {
            ids = first2;
            options2 = second;
          } else {
            options2 = first2;
          }
          var returnType = options2 && options2.returnType === "Object" ? "Object" : "Array";
          var type = options2 && options2.type || this._options.type;
          var filter3 = options2 && filter$2(options2);
          var items = [];
          var item = null;
          var itemIds = null;
          var itemId = null;
          if (id2 != null) {
            item = this._getItem(id2, type);
            if (item && filter3 && !filter3(item)) {
              item = null;
            }
          } else if (ids != null) {
            for (var i = 0, len = ids.length; i < len; i++) {
              item = this._getItem(ids[i], type);
              if (item != null && (!filter3 || filter3(item))) {
                items.push(item);
              }
            }
          } else {
            var _context21;
            itemIds = toConsumableArray(keys$6(_context21 = this._data).call(_context21));
            for (var _i = 0, _len2 = itemIds.length; _i < _len2; _i++) {
              itemId = itemIds[_i];
              item = this._getItem(itemId, type);
              if (item != null && (!filter3 || filter3(item))) {
                items.push(item);
              }
            }
          }
          if (options2 && options2.order && id2 == void 0) {
            this._sort(items, options2.order);
          }
          if (options2 && options2.fields) {
            var fields = options2.fields;
            if (id2 != void 0 && item != null) {
              item = this._filterFields(item, fields);
            } else {
              for (var _i2 = 0, _len3 = items.length; _i2 < _len3; _i2++) {
                items[_i2] = this._filterFields(items[_i2], fields);
              }
            }
          }
          if (returnType == "Object") {
            var result = {};
            for (var _i3 = 0, _len4 = items.length; _i3 < _len4; _i3++) {
              var resultant = items[_i3];
              var _id2 = resultant[this._idProp];
              result[_id2] = resultant;
            }
            return result;
          } else {
            if (id2 != null) {
              return item;
            } else {
              return items;
            }
          }
        }
        /** @inheritdoc */
      }, {
        key: "getIds",
        value: function getIds(options2) {
          var data2 = this._data;
          var filter3 = options2 && filter$2(options2);
          var order = options2 && options2.order;
          var type = options2 && options2.type || this._options.type;
          var itemIds = toConsumableArray(keys$6(data2).call(data2));
          var ids = [];
          var item;
          var items;
          if (filter3) {
            if (order) {
              items = [];
              for (var i = 0, len = itemIds.length; i < len; i++) {
                var id2 = itemIds[i];
                item = this._getItem(id2, type);
                if (filter3(item)) {
                  items.push(item);
                }
              }
              this._sort(items, order);
              for (var _i4 = 0, _len5 = items.length; _i4 < _len5; _i4++) {
                ids.push(items[_i4][this._idProp]);
              }
            } else {
              for (var _i5 = 0, _len6 = itemIds.length; _i5 < _len6; _i5++) {
                var _id3 = itemIds[_i5];
                item = this._getItem(_id3, type);
                if (filter3(item)) {
                  ids.push(item[this._idProp]);
                }
              }
            }
          } else {
            if (order) {
              items = [];
              for (var _i6 = 0, _len7 = itemIds.length; _i6 < _len7; _i6++) {
                var _id4 = itemIds[_i6];
                items.push(data2.get(_id4));
              }
              this._sort(items, order);
              for (var _i7 = 0, _len8 = items.length; _i7 < _len8; _i7++) {
                ids.push(items[_i7][this._idProp]);
              }
            } else {
              for (var _i8 = 0, _len9 = itemIds.length; _i8 < _len9; _i8++) {
                var _id5 = itemIds[_i8];
                item = data2.get(_id5);
                ids.push(item[this._idProp]);
              }
            }
          }
          return ids;
        }
        /** @inheritdoc */
      }, {
        key: "getDataSet",
        value: function getDataSet() {
          return this;
        }
        /** @inheritdoc */
      }, {
        key: "forEach",
        value: function forEach3(callback, options2) {
          var filter3 = options2 && filter$2(options2);
          var type = options2 && options2.type || this._options.type;
          var data2 = this._data;
          var itemIds = toConsumableArray(keys$6(data2).call(data2));
          if (options2 && options2.order) {
            var items = this.get(options2);
            for (var i = 0, len = items.length; i < len; i++) {
              var item = items[i];
              var id2 = item[this._idProp];
              callback(item, id2);
            }
          } else {
            for (var _i9 = 0, _len10 = itemIds.length; _i9 < _len10; _i9++) {
              var _id6 = itemIds[_i9];
              var _item = this._getItem(_id6, type);
              if (!filter3 || filter3(_item)) {
                callback(_item, _id6);
              }
            }
          }
        }
        /** @inheritdoc */
      }, {
        key: "map",
        value: function map3(callback, options2) {
          var filter3 = options2 && filter$2(options2);
          var type = options2 && options2.type || this._options.type;
          var mappedItems = [];
          var data2 = this._data;
          var itemIds = toConsumableArray(keys$6(data2).call(data2));
          for (var i = 0, len = itemIds.length; i < len; i++) {
            var id2 = itemIds[i];
            var item = this._getItem(id2, type);
            if (!filter3 || filter3(item)) {
              mappedItems.push(callback(item, id2));
            }
          }
          if (options2 && options2.order) {
            this._sort(mappedItems, options2.order);
          }
          return mappedItems;
        }
        /**
         * Filter the fields of an item.
         *
         * @param item - The item whose fields should be filtered.
         * @param fields - The names of the fields that will be kept.
         *
         * @typeParam K - Field name type.
         *
         * @returns The item without any additional fields.
         */
      }, {
        key: "_filterFields",
        value: function _filterFields(item, fields) {
          var _context22;
          if (!item) {
            return item;
          }
          return reduce$2(_context22 = isArray$5(fields) ? (
            // Use the supplied array
            fields
          ) : (
            // Use the keys of the supplied object
            keys$3(fields)
          )).call(_context22, function(filteredItem, field) {
            filteredItem[field] = item[field];
            return filteredItem;
          }, {});
        }
        /**
         * Sort the provided array with items.
         *
         * @param items - Items to be sorted in place.
         * @param order - A field name or custom sort function.
         *
         * @typeParam T - The type of the items in the items array.
         */
      }, {
        key: "_sort",
        value: function _sort(items, order) {
          if (typeof order === "string") {
            var name = order;
            sort$2(items).call(items, function(a, b) {
              var av = a[name];
              var bv = b[name];
              return av > bv ? 1 : av < bv ? -1 : 0;
            });
          } else if (typeof order === "function") {
            sort$2(items).call(items, order);
          } else {
            throw new TypeError("Order must be a function or a string");
          }
        }
        /**
         * Remove an item or multiple items by reference (only the id is used) or by id.
         *
         * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
         *
         * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
         *
         * ## Example
         * ```javascript
         * // create a DataSet
         * const data = new vis.DataSet([
         *   { id: 1, text: 'item 1' },
         *   { id: 2, text: 'item 2' },
         *   { id: 3, text: 'item 3' }
         * ])
         *
         * // remove items
         * const ids = data.remove([2, { id: 3 }, 4])
         *
         * console.log(ids) // [2, 3]
         * ```
         *
         * @param id - One or more items or ids of items to be removed.
         * @param senderId - Sender id.
         *
         * @returns The ids of the removed items.
         */
      }, {
        key: "remove",
        value: function remove(id2, senderId) {
          var removedIds = [];
          var removedItems = [];
          var ids = isArray$5(id2) ? id2 : [id2];
          for (var i = 0, len = ids.length; i < len; i++) {
            var item = this._remove(ids[i]);
            if (item) {
              var itemId = item[this._idProp];
              if (itemId != null) {
                removedIds.push(itemId);
                removedItems.push(item);
              }
            }
          }
          if (removedIds.length) {
            this._trigger("remove", {
              items: removedIds,
              oldData: removedItems
            }, senderId);
          }
          return removedIds;
        }
        /**
         * Remove an item by its id or reference.
         *
         * @param id - Id of an item or the item itself.
         *
         * @returns The removed item if removed, null otherwise.
         */
      }, {
        key: "_remove",
        value: function _remove(id2) {
          var ident;
          if (isId(id2)) {
            ident = id2;
          } else if (id2 && _typeof_1(id2) === "object") {
            ident = id2[this._idProp];
          }
          if (ident != null && this._data.has(ident)) {
            var item = this._data.get(ident) || null;
            this._data.delete(ident);
            --this.length;
            return item;
          }
          return null;
        }
        /**
         * Clear the entire data set.
         *
         * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
         *
         * @param senderId - Sender id.
         *
         * @returns removedIds - The ids of all removed items.
         */
      }, {
        key: "clear",
        value: function clear(senderId) {
          var _context23;
          var ids = toConsumableArray(keys$6(_context23 = this._data).call(_context23));
          var items = [];
          for (var i = 0, len = ids.length; i < len; i++) {
            items.push(this._data.get(ids[i]));
          }
          this._data.clear();
          this.length = 0;
          this._trigger("remove", {
            items: ids,
            oldData: items
          }, senderId);
          return ids;
        }
        /**
         * Find the item with maximum value of a specified field.
         *
         * @param field - Name of the property that should be searched for max value.
         *
         * @returns Item containing max value, or null if no items.
         */
      }, {
        key: "max",
        value: function max2(field) {
          var _context24;
          var max3 = null;
          var maxField = null;
          var _iterator11 = _createForOfIteratorHelper$1(values$3(_context24 = this._data).call(_context24)), _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
              var item = _step11.value;
              var itemField = item[field];
              if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
                max3 = item;
                maxField = itemField;
              }
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
          return max3 || null;
        }
        /**
         * Find the item with minimum value of a specified field.
         *
         * @param field - Name of the property that should be searched for min value.
         *
         * @returns Item containing min value, or null if no items.
         */
      }, {
        key: "min",
        value: function min2(field) {
          var _context25;
          var min3 = null;
          var minField = null;
          var _iterator12 = _createForOfIteratorHelper$1(values$3(_context25 = this._data).call(_context25)), _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
              var item = _step12.value;
              var itemField = item[field];
              if (typeof itemField === "number" && (minField == null || itemField < minField)) {
                min3 = item;
                minField = itemField;
              }
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
          return min3 || null;
        }
        /**
         * Find all distinct values of a specified field
         *
         * @param prop - The property name whose distinct values should be returned.
         *
         * @returns Unordered array containing all distinct values. Items without specified property are ignored.
         */
      }, {
        key: "distinct",
        value: function distinct(prop) {
          var data2 = this._data;
          var itemIds = toConsumableArray(keys$6(data2).call(data2));
          var values3 = [];
          var fieldType = this._options.type && this._options.type[prop] || null;
          var count = 0;
          for (var i = 0, len = itemIds.length; i < len; i++) {
            var id2 = itemIds[i];
            var item = data2.get(id2);
            var _value4 = item[prop];
            var exists = false;
            for (var j = 0; j < count; j++) {
              if (values3[j] == _value4) {
                exists = true;
                break;
              }
            }
            if (!exists && _value4 !== void 0) {
              values3[count] = _value4;
              count++;
            }
          }
          if (fieldType) {
            for (var _i10 = 0, _len11 = values3.length; _i10 < _len11; _i10++) {
              values3[_i10] = convert(values3[_i10], fieldType);
            }
          }
          return values3;
        }
        /**
         * Add a single item. Will fail when an item with the same id already exists.
         *
         * @param item - A new item to be added.
         *
         * @returns Added item's id. An id is generated when it is not present in the item.
         */
      }, {
        key: "_addItem",
        value: function _addItem(item) {
          var id2 = item[this._idProp];
          if (id2 != null) {
            if (this._data.has(id2)) {
              throw new Error("Cannot add item: item with id " + id2 + " already exists");
            }
          } else {
            id2 = v4();
            item[this._idProp] = id2;
          }
          var d = {};
          var fields = keys$3(item);
          for (var i = 0, len = fields.length; i < len; i++) {
            var field = fields[i];
            var fieldType = this._type[field];
            d[field] = convert(item[field], fieldType);
          }
          this._data.set(id2, d);
          ++this.length;
          return id2;
        }
        /**
         * Get an item. Fields can be converted to a specific type
         *
         * @param id - Id of the requested item.
         * @param types - Property name to type name object map of type converstions.
         *
         * @returns The item, optionally after type conversion.
         */
      }, {
        key: "_getItem",
        value: function _getItem(id2, types) {
          var raw = this._data.get(id2);
          if (!raw) {
            return null;
          }
          var converted;
          var fields = keys$3(raw);
          if (types) {
            warnTypeCorectionDeprecation();
            converted = {};
            for (var i = 0, len = fields.length; i < len; i++) {
              var field = fields[i];
              var _value5 = raw[field];
              converted[field] = convert(_value5, types[field]);
            }
          } else {
            converted = _objectSpread({}, raw);
          }
          if (converted[this._idProp] == null) {
            converted[this._idProp] = raw.id;
          }
          return converted;
        }
        /**
         * Update a single item: merge with existing item.
         * Will fail when the item has no id, or when there does not exist an item with the same id.
         *
         * @param item - The new item
         *
         * @returns The id of the updated item.
         */
      }, {
        key: "_updateItem",
        value: function _updateItem(item) {
          var id2 = item[this._idProp];
          if (id2 == null) {
            throw new Error("Cannot update item: item has no id (item: " + stringify$2(item) + ")");
          }
          var d = this._data.get(id2);
          if (!d) {
            throw new Error("Cannot update item: no item with id " + id2 + " found");
          }
          var fields = keys$3(item);
          for (var i = 0, len = fields.length; i < len; i++) {
            var field = fields[i];
            var fieldType = this._type[field];
            d[field] = convert(item[field], fieldType);
          }
          return id2;
        }
        /** @inheritdoc */
      }, {
        key: "stream",
        value: function stream(ids) {
          if (ids) {
            var data2 = this._data;
            return new DataStream(defineProperty$7({}, iterator$4, regenerator.mark(function _callee3() {
              var _iterator13, _step13, id2, item;
              return regenerator.wrap(function _callee3$(_context26) {
                while (1) {
                  switch (_context26.prev = _context26.next) {
                    case 0:
                      _iterator13 = _createForOfIteratorHelper$1(ids);
                      _context26.prev = 1;
                      _iterator13.s();
                    case 3:
                      if ((_step13 = _iterator13.n()).done) {
                        _context26.next = 11;
                        break;
                      }
                      id2 = _step13.value;
                      item = data2.get(id2);
                      if (!(item != null)) {
                        _context26.next = 9;
                        break;
                      }
                      _context26.next = 9;
                      return [id2, item];
                    case 9:
                      _context26.next = 3;
                      break;
                    case 11:
                      _context26.next = 16;
                      break;
                    case 13:
                      _context26.prev = 13;
                      _context26.t0 = _context26["catch"](1);
                      _iterator13.e(_context26.t0);
                    case 16:
                      _context26.prev = 16;
                      _iterator13.f();
                      return _context26.finish(16);
                    case 19:
                    case "end":
                      return _context26.stop();
                  }
                }
              }, _callee3, null, [[1, 13, 16, 19]]);
            })));
          } else {
            var _context27;
            return new DataStream(defineProperty$7({}, iterator$4, bind$2(_context27 = entries$2(this._data)).call(_context27, this._data)));
          }
        }
      }]);
      return DataSet2;
    }(DataSetPart);
    DataView = function(_DataSetPart2) {
      inherits(DataView2, _DataSetPart2);
      var _super2 = _createSuper(DataView2);
      function DataView2(data2, options2) {
        var _context30;
        var _this7;
        classCallCheck(this, DataView2);
        _this7 = _super2.call(this);
        _this7.length = 0;
        _this7._ids = new set$3();
        _this7._options = options2 || {};
        _this7._listener = bind$2(_context30 = _this7._onEvent).call(_context30, assertThisInitialized(_this7));
        _this7.setData(data2);
        return _this7;
      }
      createClass(DataView2, [{
        key: "setData",
        value: function setData(data2) {
          if (this._data) {
            if (this._data.off) {
              this._data.off("*", this._listener);
            }
            var ids = this._data.getIds({
              filter: filter$2(this._options)
            });
            var items = this._data.get(ids);
            this._ids.clear();
            this.length = 0;
            this._trigger("remove", {
              items: ids,
              oldData: items
            });
          }
          if (data2 != null) {
            this._data = data2;
            var _ids = this._data.getIds({
              filter: filter$2(this._options)
            });
            for (var i = 0, len = _ids.length; i < len; i++) {
              var id2 = _ids[i];
              this._ids.add(id2);
            }
            this.length = _ids.length;
            this._trigger("add", {
              items: _ids
            });
          } else {
            this._data = new DataSet();
          }
          if (this._data.on) {
            this._data.on("*", this._listener);
          }
        }
        /**
         * Refresh the DataView.
         * Useful when the DataView has a filter function containing a variable parameter.
         */
      }, {
        key: "refresh",
        value: function refresh() {
          var ids = this._data.getIds({
            filter: filter$2(this._options)
          });
          var oldIds = toConsumableArray(this._ids);
          var newIds = {};
          var addedIds = [];
          var removedIds = [];
          var removedItems = [];
          for (var i = 0, len = ids.length; i < len; i++) {
            var id2 = ids[i];
            newIds[id2] = true;
            if (!this._ids.has(id2)) {
              addedIds.push(id2);
              this._ids.add(id2);
            }
          }
          for (var _i11 = 0, _len12 = oldIds.length; _i11 < _len12; _i11++) {
            var _id7 = oldIds[_i11];
            var item = this._data.get(_id7);
            if (item == null) {
              console.error("If you see this, report it please.");
            } else if (!newIds[_id7]) {
              removedIds.push(_id7);
              removedItems.push(item);
              this._ids.delete(_id7);
            }
          }
          this.length += addedIds.length - removedIds.length;
          if (addedIds.length) {
            this._trigger("add", {
              items: addedIds
            });
          }
          if (removedIds.length) {
            this._trigger("remove", {
              items: removedIds,
              oldData: removedItems
            });
          }
        }
        /** @inheritdoc */
      }, {
        key: "get",
        value: function get2(first2, second) {
          if (this._data == null) {
            return null;
          }
          var ids = null;
          var options2;
          if (isId(first2) || isArray$5(first2)) {
            ids = first2;
            options2 = second;
          } else {
            options2 = first2;
          }
          var viewOptions = assign$2({}, this._options, options2);
          var thisFilter = filter$2(this._options);
          var optionsFilter = options2 && filter$2(options2);
          if (thisFilter && optionsFilter) {
            viewOptions.filter = function(item) {
              return thisFilter(item) && optionsFilter(item);
            };
          }
          if (ids == null) {
            return this._data.get(viewOptions);
          } else {
            return this._data.get(ids, viewOptions);
          }
        }
        /** @inheritdoc */
      }, {
        key: "getIds",
        value: function getIds(options2) {
          if (this._data.length) {
            var defaultFilter = filter$2(this._options);
            var optionsFilter = options2 != null ? filter$2(options2) : null;
            var filter3;
            if (optionsFilter) {
              if (defaultFilter) {
                filter3 = function filter4(item) {
                  return defaultFilter(item) && optionsFilter(item);
                };
              } else {
                filter3 = optionsFilter;
              }
            } else {
              filter3 = defaultFilter;
            }
            return this._data.getIds({
              filter: filter3,
              order: options2 && options2.order
            });
          } else {
            return [];
          }
        }
        /** @inheritdoc */
      }, {
        key: "forEach",
        value: function forEach3(callback, options2) {
          if (this._data) {
            var _context31;
            var defaultFilter = filter$2(this._options);
            var optionsFilter = options2 && filter$2(options2);
            var filter3;
            if (optionsFilter) {
              if (defaultFilter) {
                filter3 = function filter4(item) {
                  return defaultFilter(item) && optionsFilter(item);
                };
              } else {
                filter3 = optionsFilter;
              }
            } else {
              filter3 = defaultFilter;
            }
            forEach$2(_context31 = this._data).call(_context31, callback, {
              filter: filter3,
              order: options2 && options2.order
            });
          }
        }
        /** @inheritdoc */
      }, {
        key: "map",
        value: function map3(callback, options2) {
          if (this._data) {
            var _context32;
            var defaultFilter = filter$2(this._options);
            var optionsFilter = options2 && filter$2(options2);
            var filter3;
            if (optionsFilter) {
              if (defaultFilter) {
                filter3 = function filter4(item) {
                  return defaultFilter(item) && optionsFilter(item);
                };
              } else {
                filter3 = optionsFilter;
              }
            } else {
              filter3 = defaultFilter;
            }
            return map$2(_context32 = this._data).call(_context32, callback, {
              filter: filter3,
              order: options2 && options2.order
            });
          } else {
            return [];
          }
        }
        /** @inheritdoc */
      }, {
        key: "getDataSet",
        value: function getDataSet() {
          return this._data.getDataSet();
        }
        /** @inheritdoc */
      }, {
        key: "stream",
        value: function stream(ids) {
          var _context33;
          return this._data.stream(ids || defineProperty$7({}, iterator$4, bind$2(_context33 = keys$6(this._ids)).call(_context33, this._ids)));
        }
        /**
         * Render the instance unusable prior to garbage collection.
         *
         * @remarks
         * The intention of this method is to help discover scenarios where the data
         * view is being used when the programmer thinks it has been garbage collected
         * already. It's stricter version of `dataView.setData(null)`.
         */
      }, {
        key: "dispose",
        value: function dispose() {
          var _a;
          if ((_a = this._data) === null || _a === void 0 ? void 0 : _a.off) {
            this._data.off("*", this._listener);
          }
          var message = "This data view has already been disposed of.";
          defineProperty$2(this, "_data", {
            get: function get2() {
              throw new Error(message);
            },
            set: function set2() {
              throw new Error(message);
            },
            configurable: false
          });
        }
        /**
         * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
         *
         * @param event - The name of the event.
         * @param params - Parameters of the event.
         * @param senderId - Id supplied by the sender.
         */
      }, {
        key: "_onEvent",
        value: function _onEvent(event, params, senderId) {
          if (!params || !params.items || !this._data) {
            return;
          }
          var ids = params.items;
          var addedIds = [];
          var updatedIds = [];
          var removedIds = [];
          var oldItems = [];
          var updatedItems = [];
          var removedItems = [];
          switch (event) {
            case "add":
              for (var i = 0, len = ids.length; i < len; i++) {
                var id2 = ids[i];
                var item = this.get(id2);
                if (item) {
                  this._ids.add(id2);
                  addedIds.push(id2);
                }
              }
              break;
            case "update":
              for (var _i12 = 0, _len13 = ids.length; _i12 < _len13; _i12++) {
                var _id8 = ids[_i12];
                var _item2 = this.get(_id8);
                if (_item2) {
                  if (this._ids.has(_id8)) {
                    updatedIds.push(_id8);
                    updatedItems.push(params.data[_i12]);
                    oldItems.push(params.oldData[_i12]);
                  } else {
                    this._ids.add(_id8);
                    addedIds.push(_id8);
                  }
                } else {
                  if (this._ids.has(_id8)) {
                    this._ids.delete(_id8);
                    removedIds.push(_id8);
                    removedItems.push(params.oldData[_i12]);
                  }
                }
              }
              break;
            case "remove":
              for (var _i13 = 0, _len14 = ids.length; _i13 < _len14; _i13++) {
                var _id9 = ids[_i13];
                if (this._ids.has(_id9)) {
                  this._ids.delete(_id9);
                  removedIds.push(_id9);
                  removedItems.push(params.oldData[_i13]);
                }
              }
              break;
          }
          this.length += addedIds.length - removedIds.length;
          if (addedIds.length) {
            this._trigger("add", {
              items: addedIds
            }, senderId);
          }
          if (updatedIds.length) {
            this._trigger("update", {
              items: updatedIds,
              oldData: oldItems,
              data: updatedItems
            }, senderId);
          }
          if (removedIds.length) {
            this._trigger("remove", {
              items: removedIds,
              oldData: removedItems
            }, senderId);
          }
        }
      }]);
      return DataView2;
    }(DataSetPart);
    index$1 = Object.freeze({
      __proto__: null,
      DELETE,
      DataSet,
      DataStream,
      DataView,
      Queue,
      createNewDataPipeFrom
    });
    nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;
    FAILS_ON_PRIMITIVES$3 = fails(function() {
      return !Object.getOwnPropertyNames(1);
    });
    _export({
      target: "Object",
      stat: true,
      forced: FAILS_ON_PRIMITIVES$3
    }, {
      getOwnPropertyNames: nativeGetOwnPropertyNames$2
    });
    Object$2 = path.Object;
    getOwnPropertyNames4 = function getOwnPropertyNames5(it2) {
      return Object$2.getOwnPropertyNames(it2);
    };
    getOwnPropertyNames$1 = getOwnPropertyNames4;
    getOwnPropertyNames$2 = getOwnPropertyNames$1;
    trim$2 = stringTrim.trim;
    $parseFloat = global_1.parseFloat;
    FORCED$6 = 1 / $parseFloat(whitespaces + "-0") !== -Infinity;
    numberParseFloat = FORCED$6 ? function parseFloat2(string2) {
      var trimmedString = trim$2(String(string2));
      var result = $parseFloat(trimmedString);
      return result === 0 && trimmedString.charAt(0) == "-" ? -0 : result;
    } : $parseFloat;
    _export({
      global: true,
      forced: parseFloat != numberParseFloat
    }, {
      parseFloat: numberParseFloat
    });
    _parseFloat = path.parseFloat;
    _parseFloat$1 = _parseFloat;
    _parseFloat$2 = _parseFloat$1;
    LabelAccumulator = function() {
      function LabelAccumulator2(measureText) {
        classCallCheck(this, LabelAccumulator2);
        this.measureText = measureText;
        this.current = 0;
        this.width = 0;
        this.height = 0;
        this.lines = [];
      }
      createClass(LabelAccumulator2, [{
        key: "_add",
        value: function _add(l, text) {
          var mod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "normal";
          if (this.lines[l] === void 0) {
            this.lines[l] = {
              width: 0,
              height: 0,
              blocks: []
            };
          }
          var tmpText = text;
          if (text === void 0 || text === "") tmpText = " ";
          var result = this.measureText(tmpText, mod);
          var block = assign$2({}, values$3(result));
          block.text = text;
          block.width = result.width;
          block.mod = mod;
          if (text === void 0 || text === "") {
            block.width = 0;
          }
          this.lines[l].blocks.push(block);
          this.lines[l].width += block.width;
        }
        /**
         * Returns the width in pixels of the current line.
         *
         * @returns {number}
         */
      }, {
        key: "curWidth",
        value: function curWidth() {
          var line = this.lines[this.current];
          if (line === void 0) return 0;
          return line.width;
        }
        /**
         * Add text in block to current line
         *
         * @param {string} text
         * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
         */
      }, {
        key: "append",
        value: function append(text) {
          var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
          this._add(this.current, text, mod);
        }
        /**
         * Add text in block to current line and start a new line
         *
         * @param {string} text
         * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
         */
      }, {
        key: "newLine",
        value: function newLine(text) {
          var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
          this._add(this.current, text, mod);
          this.current++;
        }
        /**
         * Determine and set the heights of all the lines currently contained in this instance
         *
         * Note that width has already been set.
         * 
         * @private
         */
      }, {
        key: "determineLineHeights",
        value: function determineLineHeights() {
          for (var k = 0; k < this.lines.length; k++) {
            var line = this.lines[k];
            var height = 0;
            if (line.blocks !== void 0) {
              for (var l = 0; l < line.blocks.length; l++) {
                var block = line.blocks[l];
                if (height < block.height) {
                  height = block.height;
                }
              }
            }
            line.height = height;
          }
        }
        /**
         * Determine the full size of the label text, as determined by current lines and blocks
         * 
         * @private
         */
      }, {
        key: "determineLabelSize",
        value: function determineLabelSize() {
          var width = 0;
          var height = 0;
          for (var k = 0; k < this.lines.length; k++) {
            var line = this.lines[k];
            if (line.width > width) {
              width = line.width;
            }
            height += line.height;
          }
          this.width = width;
          this.height = height;
        }
        /**
         * Remove all empty blocks and empty lines we don't need
         * 
         * This must be done after the width/height determination,
         * so that these are set properly for processing here.
         *
         * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
         * @private
         */
      }, {
        key: "removeEmptyBlocks",
        value: function removeEmptyBlocks() {
          var tmpLines = [];
          for (var k = 0; k < this.lines.length; k++) {
            var line = this.lines[k];
            if (line.blocks.length === 0) continue;
            if (k === this.lines.length - 1) {
              if (line.width === 0) continue;
            }
            var tmpLine = {};
            assign$2(tmpLine, line);
            tmpLine.blocks = [];
            var firstEmptyBlock = void 0;
            var tmpBlocks = [];
            for (var l = 0; l < line.blocks.length; l++) {
              var block = line.blocks[l];
              if (block.width !== 0) {
                tmpBlocks.push(block);
              } else {
                if (firstEmptyBlock === void 0) {
                  firstEmptyBlock = block;
                }
              }
            }
            if (tmpBlocks.length === 0 && firstEmptyBlock !== void 0) {
              tmpBlocks.push(firstEmptyBlock);
            }
            tmpLine.blocks = tmpBlocks;
            tmpLines.push(tmpLine);
          }
          return tmpLines;
        }
        /**
         * Set the sizes for all lines and the whole thing.
         *
         * @returns {{width: (number|*), height: (number|*), lines: Array}}
         */
      }, {
        key: "finalize",
        value: function finalize() {
          this.determineLineHeights();
          this.determineLabelSize();
          var tmpLines = this.removeEmptyBlocks();
          return {
            width: this.width,
            height: this.height,
            lines: tmpLines
          };
        }
      }]);
      return LabelAccumulator2;
    }();
    tagPattern = {
      // HTML
      "<b>": /<b>/,
      "<i>": /<i>/,
      "<code>": /<code>/,
      "</b>": /<\/b>/,
      "</i>": /<\/i>/,
      "</code>": /<\/code>/,
      // Markdown
      "*": /\*/,
      // bold
      "_": /\_/,
      // ital
      "`": /`/,
      // mono
      "afterBold": /[^\*]/,
      "afterItal": /[^_]/,
      "afterMono": /[^`]/
    };
    MarkupAccumulator = function() {
      function MarkupAccumulator2(text) {
        classCallCheck(this, MarkupAccumulator2);
        this.text = text;
        this.bold = false;
        this.ital = false;
        this.mono = false;
        this.spacing = false;
        this.position = 0;
        this.buffer = "";
        this.modStack = [];
        this.blocks = [];
      }
      createClass(MarkupAccumulator2, [{
        key: "mod",
        value: function mod() {
          return this.modStack.length === 0 ? "normal" : this.modStack[0];
        }
        /**
         * Return the mod label currently active
         * 
         * @returns {string}  label of active mod 
         * @private
         */
      }, {
        key: "modName",
        value: function modName() {
          if (this.modStack.length === 0) return "normal";
          else if (this.modStack[0] === "mono") return "mono";
          else {
            if (this.bold && this.ital) {
              return "boldital";
            } else if (this.bold) {
              return "bold";
            } else if (this.ital) {
              return "ital";
            }
          }
        }
        /**
         * @private
         */
      }, {
        key: "emitBlock",
        value: function emitBlock() {
          if (this.spacing) {
            this.add(" ");
            this.spacing = false;
          }
          if (this.buffer.length > 0) {
            this.blocks.push({
              text: this.buffer,
              mod: this.modName()
            });
            this.buffer = "";
          }
        }
        /**
         * Output text to buffer
         *
         * @param {string} text  text to add
         * @private
         */
      }, {
        key: "add",
        value: function add(text) {
          if (text === " ") {
            this.spacing = true;
          }
          if (this.spacing) {
            this.buffer += " ";
            this.spacing = false;
          }
          if (text != " ") {
            this.buffer += text;
          }
        }
        /**
         * Handle parsing of whitespace
         *
         * @param {string} ch  the character to check
         * @returns {boolean} true if the character was processed as whitespace, false otherwise
         */
      }, {
        key: "parseWS",
        value: function parseWS(ch) {
          if (/[ \t]/.test(ch)) {
            if (!this.mono) {
              this.spacing = true;
            } else {
              this.add(ch);
            }
            return true;
          }
          return false;
        }
        /**
         * @param {string} tagName  label for block type to set
         * @private
         */
      }, {
        key: "setTag",
        value: function setTag(tagName) {
          this.emitBlock();
          this[tagName] = true;
          this.modStack.unshift(tagName);
        }
        /**
         * @param {string} tagName  label for block type to unset
         * @private
         */
      }, {
        key: "unsetTag",
        value: function unsetTag(tagName) {
          this.emitBlock();
          this[tagName] = false;
          this.modStack.shift();
        }
        /**
         * @param {string} tagName label for block type we are currently processing
         * @param {string|RegExp} tag string to match in text
         * @returns {boolean} true if the tag was processed, false otherwise
         */
      }, {
        key: "parseStartTag",
        value: function parseStartTag(tagName, tag) {
          if (!this.mono && !this[tagName] && this.match(tag)) {
            this.setTag(tagName);
            return true;
          }
          return false;
        }
        /**
         * @param {string|RegExp} tag
         * @param {number} [advance=true] if set, advance current position in text
         * @returns {boolean} true if match at given position, false otherwise
         * @private
         */
      }, {
        key: "match",
        value: function match2(tag) {
          var advance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var _this$prepareRegExp = this.prepareRegExp(tag), _this$prepareRegExp2 = slicedToArray(_this$prepareRegExp, 2), regExp = _this$prepareRegExp2[0], length2 = _this$prepareRegExp2[1];
          var matched = regExp.test(this.text.substr(this.position, length2));
          if (matched && advance) {
            this.position += length2 - 1;
          }
          return matched;
        }
        /**
         * @param {string} tagName label for block type we are currently processing
         * @param {string|RegExp} tag string to match in text
         * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag 
         * @returns {boolean} true if the tag was processed, false otherwise
         */
      }, {
        key: "parseEndTag",
        value: function parseEndTag(tagName, tag, nextTag) {
          var checkTag = this.mod() === tagName;
          if (tagName === "mono") {
            checkTag = checkTag && this.mono;
          } else {
            checkTag = checkTag && !this.mono;
          }
          if (checkTag && this.match(tag)) {
            if (nextTag !== void 0) {
              if (this.position === this.text.length - 1 || this.match(nextTag, false)) {
                this.unsetTag(tagName);
              }
            } else {
              this.unsetTag(tagName);
            }
            return true;
          }
          return false;
        }
        /**
         * @param {string|RegExp} tag  string to match in text
         * @param {value} value  string to replace tag with, if found at current position
         * @returns {boolean} true if the tag was processed, false otherwise
         */
      }, {
        key: "replace",
        value: function replace(tag, value) {
          if (this.match(tag)) {
            this.add(value);
            this.position += length - 1;
            return true;
          }
          return false;
        }
        /**
         * Create a regular expression for the tag if it isn't already one.
         *
         * The return value is an array `[RegExp, number]`, with exactly two value, where:
         *  - RegExp is the regular expression to use
         *  - number is the lenth of the input string to match
         *
         * @param {string|RegExp} tag  string to match in text
         * @returns {Array}  regular expression to use and length of input string to match
         * @private
         */
      }, {
        key: "prepareRegExp",
        value: function prepareRegExp(tag) {
          var length2;
          var regExp;
          if (tag instanceof RegExp) {
            regExp = tag;
            length2 = 1;
          } else {
            var prepared = tagPattern[tag];
            if (prepared !== void 0) {
              regExp = prepared;
            } else {
              regExp = new RegExp(tag);
            }
            length2 = tag.length;
          }
          return [regExp, length2];
        }
      }]);
      return MarkupAccumulator2;
    }();
    LabelSplitter = function() {
      function LabelSplitter2(ctx, parent, selected, hover) {
        var _this = this;
        classCallCheck(this, LabelSplitter2);
        this.ctx = ctx;
        this.parent = parent;
        this.selected = selected;
        this.hover = hover;
        var textWidth = function textWidth2(text, mod) {
          if (text === void 0) return 0;
          var values3 = _this.parent.getFormattingValues(ctx, selected, hover, mod);
          var width = 0;
          if (text !== "") {
            var measure = _this.ctx.measureText(text);
            width = measure.width;
          }
          return {
            width,
            values: values3
          };
        };
        this.lines = new LabelAccumulator(textWidth);
      }
      createClass(LabelSplitter2, [{
        key: "process",
        value: function process3(text) {
          if (!isValidLabel(text)) {
            return this.lines.finalize();
          }
          var font = this.parent.fontOptions;
          text = text.replace(/\r\n/g, "\n");
          text = text.replace(/\r/g, "\n");
          var nlLines = String(text).split("\n");
          var lineCount = nlLines.length;
          if (font.multi) {
            for (var i = 0; i < lineCount; i++) {
              var blocks = this.splitBlocks(nlLines[i], font.multi);
              if (blocks === void 0) continue;
              if (blocks.length === 0) {
                this.lines.newLine("");
                continue;
              }
              if (font.maxWdt > 0) {
                for (var j = 0; j < blocks.length; j++) {
                  var mod = blocks[j].mod;
                  var _text = blocks[j].text;
                  this.splitStringIntoLines(_text, mod, true);
                }
              } else {
                for (var _j = 0; _j < blocks.length; _j++) {
                  var _mod = blocks[_j].mod;
                  var _text2 = blocks[_j].text;
                  this.lines.append(_text2, _mod);
                }
              }
              this.lines.newLine();
            }
          } else {
            if (font.maxWdt > 0) {
              for (var _i = 0; _i < lineCount; _i++) {
                this.splitStringIntoLines(nlLines[_i]);
              }
            } else {
              for (var _i2 = 0; _i2 < lineCount; _i2++) {
                this.lines.newLine(nlLines[_i2]);
              }
            }
          }
          return this.lines.finalize();
        }
        /**
         * normalize the markup system
         *
         * @param {boolean|'md'|'markdown'|'html'} markupSystem
         * @returns {string}
         */
      }, {
        key: "decodeMarkupSystem",
        value: function decodeMarkupSystem(markupSystem) {
          var system = "none";
          if (markupSystem === "markdown" || markupSystem === "md") {
            system = "markdown";
          } else if (markupSystem === true || markupSystem === "html") {
            system = "html";
          }
          return system;
        }
        /**
         *
         * @param {string} text
         * @returns {Array}
         */
      }, {
        key: "splitHtmlBlocks",
        value: function splitHtmlBlocks(text) {
          var s = new MarkupAccumulator(text);
          var parseEntities = function parseEntities2(ch2) {
            if (/&/.test(ch2)) {
              var parsed2 = s.replace(s.text, "&lt;", "<") || s.replace(s.text, "&amp;", "&");
              if (!parsed2) {
                s.add("&");
              }
              return true;
            }
            return false;
          };
          while (s.position < s.text.length) {
            var ch = s.text.charAt(s.position);
            var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag("bold", "<b>") || s.parseStartTag("ital", "<i>") || s.parseStartTag("mono", "<code>") || s.parseEndTag("bold", "</b>") || s.parseEndTag("ital", "</i>") || s.parseEndTag("mono", "</code>")) || parseEntities(ch);
            if (!parsed) {
              s.add(ch);
            }
            s.position++;
          }
          s.emitBlock();
          return s.blocks;
        }
        /**
         *
         * @param {string} text
         * @returns {Array}
         */
      }, {
        key: "splitMarkdownBlocks",
        value: function splitMarkdownBlocks(text) {
          var _this2 = this;
          var s = new MarkupAccumulator(text);
          var beginable = true;
          var parseOverride = function parseOverride2(ch2) {
            if (/\\/.test(ch2)) {
              if (s.position < _this2.text.length + 1) {
                s.position++;
                ch2 = _this2.text.charAt(s.position);
                if (/ \t/.test(ch2)) {
                  s.spacing = true;
                } else {
                  s.add(ch2);
                  beginable = false;
                }
              }
              return true;
            }
            return false;
          };
          while (s.position < s.text.length) {
            var ch = s.text.charAt(s.position);
            var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag("bold", "*") || s.parseStartTag("ital", "_") || s.parseStartTag("mono", "`")) || s.parseEndTag("bold", "*", "afterBold") || s.parseEndTag("ital", "_", "afterItal") || s.parseEndTag("mono", "`", "afterMono");
            if (!parsed) {
              s.add(ch);
              beginable = false;
            }
            s.position++;
          }
          s.emitBlock();
          return s.blocks;
        }
        /**
         * Explodes a piece of text into single-font blocks using a given markup
         *
         * @param {string} text
         * @param {boolean|'md'|'markdown'|'html'} markupSystem
         * @returns {Array.<{text: string, mod: string}>}
         * @private
         */
      }, {
        key: "splitBlocks",
        value: function splitBlocks(text, markupSystem) {
          var system = this.decodeMarkupSystem(markupSystem);
          if (system === "none") {
            return [{
              text,
              mod: "normal"
            }];
          } else if (system === "markdown") {
            return this.splitMarkdownBlocks(text);
          } else if (system === "html") {
            return this.splitHtmlBlocks(text);
          }
        }
        /**
         * @param {string} text
         * @returns {boolean} true if text length over the current max with
         * @private
         */
      }, {
        key: "overMaxWidth",
        value: function overMaxWidth(text) {
          var width = this.ctx.measureText(text).width;
          return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
        }
        /**
         * Determine the longest part of the sentence which still fits in the 
         * current max width.
         * 
         * @param {Array} words  Array of strings signifying a text lines
         * @return {number}      index of first item in string making string go over max
         * @private
         */
      }, {
        key: "getLongestFit",
        value: function getLongestFit(words) {
          var text = "";
          var w = 0;
          while (w < words.length) {
            var pre = text === "" ? "" : " ";
            var newText = text + pre + words[w];
            if (this.overMaxWidth(newText)) break;
            text = newText;
            w++;
          }
          return w;
        }
        /**
         * Determine the longest part of the string which still fits in the
         * current max width.
         * 
         * @param {Array} words Array of strings signifying a text lines
         * @return {number} index of first item in string making string go over max
         */
      }, {
        key: "getLongestFitWord",
        value: function getLongestFitWord(words) {
          var w = 0;
          while (w < words.length) {
            if (this.overMaxWidth(slice$5(words).call(words, 0, w))) break;
            w++;
          }
          return w;
        }
        /**
         * Split the passed text into lines, according to width constraint (if any).
         * 
         * The method assumes that the input string is a single line, i.e. without lines break.
         *
         * This method retains spaces, if still present (case `font.multi: false`).
         * A space which falls on an internal line break, will be replaced by a newline.
         * There is no special handling of tabs; these go along with the flow.
         * 
         * @param {string} str
         * @param {string} [mod='normal']
         * @param {boolean} [appendLast=false]
         * @private
         */
      }, {
        key: "splitStringIntoLines",
        value: function splitStringIntoLines(str) {
          var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
          var appendLast = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod);
          str = str.replace(/^( +)/g, "$1\r");
          str = str.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
          var words = str.split("\r");
          while (words.length > 0) {
            var w = this.getLongestFit(words);
            if (w === 0) {
              var word = words[0];
              var x = this.getLongestFitWord(word);
              this.lines.newLine(slice$5(word).call(word, 0, x), mod);
              words[0] = slice$5(word).call(word, x);
            } else {
              var newW = w;
              if (words[w - 1] === " ") {
                w--;
              } else if (words[newW] === " ") {
                newW++;
              }
              var text = slice$5(words).call(words, 0, w).join("");
              if (w == words.length && appendLast) {
                this.lines.append(text, mod);
              } else {
                this.lines.newLine(text, mod);
              }
              words = slice$5(words).call(words, newW);
            }
          }
        }
      }]);
      return LabelSplitter2;
    }();
    multiFontStyle = ["bold", "ital", "boldital", "mono"];
    Label = function() {
      function Label2(body, options2) {
        var edgelabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        classCallCheck(this, Label2);
        this.body = body;
        this.pointToSelf = false;
        this.baseSize = void 0;
        this.fontOptions = {};
        this.setOptions(options2);
        this.size = {
          top: 0,
          left: 0,
          width: 0,
          height: 0,
          yLine: 0
        };
        this.isEdgeLabel = edgelabel;
      }
      createClass(Label2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.elementOptions = options2;
          this.initFontOptions(options2.font);
          if (isValidLabel(options2.label)) {
            this.labelDirty = true;
          } else {
            options2.label = void 0;
          }
          if (options2.font !== void 0 && options2.font !== null) {
            if (typeof options2.font === "string") {
              this.baseSize = this.fontOptions.size;
            } else if (_typeof_1(options2.font) === "object") {
              var size = options2.font.size;
              if (size !== void 0) {
                this.baseSize = size;
              }
            }
          }
        }
        /**
         * Init the font Options structure.
         *
         * Member fontOptions serves as an accumulator for the current font options.
         * As such, it needs to be completely separated from the node options.
         *
         * @param {Object} newFontOptions the new font options to process
         * @private
         */
      }, {
        key: "initFontOptions",
        value: function initFontOptions(newFontOptions) {
          var _this = this;
          forEach$3(multiFontStyle, function(style) {
            _this.fontOptions[style] = {};
          });
          if (Label2.parseFontString(this.fontOptions, newFontOptions)) {
            this.fontOptions.vadjust = 0;
            return;
          }
          forEach$3(newFontOptions, function(prop, n) {
            if (prop !== void 0 && prop !== null && _typeof_1(prop) !== "object") {
              _this.fontOptions[n] = prop;
            }
          });
        }
        /**
         * If in-variable is a string, parse it as a font specifier.
         *
         * Note that following is not done here and have to be done after the call:
         * - Not all font options are set (vadjust, mod)
         *
         * @param {Object} outOptions  out-parameter, object in which to store the parse results (if any)
         * @param {Object} inOptions  font options to parse
         * @return {boolean} true if font parsed as string, false otherwise
         * @static
         */
      }, {
        key: "constrain",
        /**
         * Set the width and height constraints based on 'nearest' value
         *
         * @param {Array} pile array of option objects to consider
         * @returns {object} the actual constraint values to use
         * @private
         */
        value: function constrain(pile) {
          var fontOptions = {
            constrainWidth: false,
            maxWdt: -1,
            minWdt: -1,
            constrainHeight: false,
            minHgt: -1,
            valign: "middle"
          };
          var widthConstraint = topMost(pile, "widthConstraint");
          if (typeof widthConstraint === "number") {
            fontOptions.maxWdt = Number(widthConstraint);
            fontOptions.minWdt = Number(widthConstraint);
          } else if (_typeof_1(widthConstraint) === "object") {
            var widthConstraintMaximum = topMost(pile, ["widthConstraint", "maximum"]);
            if (typeof widthConstraintMaximum === "number") {
              fontOptions.maxWdt = Number(widthConstraintMaximum);
            }
            var widthConstraintMinimum = topMost(pile, ["widthConstraint", "minimum"]);
            if (typeof widthConstraintMinimum === "number") {
              fontOptions.minWdt = Number(widthConstraintMinimum);
            }
          }
          var heightConstraint = topMost(pile, "heightConstraint");
          if (typeof heightConstraint === "number") {
            fontOptions.minHgt = Number(heightConstraint);
          } else if (_typeof_1(heightConstraint) === "object") {
            var heightConstraintMinimum = topMost(pile, ["heightConstraint", "minimum"]);
            if (typeof heightConstraintMinimum === "number") {
              fontOptions.minHgt = Number(heightConstraintMinimum);
            }
            var heightConstraintValign = topMost(pile, ["heightConstraint", "valign"]);
            if (typeof heightConstraintValign === "string") {
              if (heightConstraintValign === "top" || heightConstraintValign === "bottom") {
                fontOptions.valign = heightConstraintValign;
              }
            }
          }
          return fontOptions;
        }
        /**
         * Set options and update internal state
         *
         * @param {Object} options  options to set
         * @param {Array}  pile     array of option objects to consider for option 'chosen'
         */
      }, {
        key: "update",
        value: function update(options2, pile) {
          this.setOptions(options2, true);
          this.propagateFonts(pile);
          deepExtend(this.fontOptions, this.constrain(pile));
          this.fontOptions.chooser = choosify("label", pile);
        }
        /**
         * When margins are set in an element, adjust sizes is called to remove them
         * from the width/height constraints. This must be done prior to label sizing.
         *
         * @param {{top: number, right: number, bottom: number, left: number}} margins
         */
      }, {
        key: "adjustSizes",
        value: function adjustSizes(margins) {
          var widthBias = margins ? margins.right + margins.left : 0;
          if (this.fontOptions.constrainWidth) {
            this.fontOptions.maxWdt -= widthBias;
            this.fontOptions.minWdt -= widthBias;
          }
          var heightBias = margins ? margins.top + margins.bottom : 0;
          if (this.fontOptions.constrainHeight) {
            this.fontOptions.minHgt -= heightBias;
          }
        }
        /////////////////////////////////////////////////////////
        // Methods for handling options piles
        // Eventually, these will be moved to a separate class
        /////////////////////////////////////////////////////////
        /**
         * Add the font members of the passed list of option objects to the pile.
         *
         * @param {Pile} dstPile  pile of option objects add to 
         * @param {Pile} srcPile  pile of option objects to take font options from
         * @private
         */
      }, {
        key: "addFontOptionsToPile",
        value: function addFontOptionsToPile(dstPile, srcPile) {
          for (var i = 0; i < srcPile.length; ++i) {
            this.addFontToPile(dstPile, srcPile[i]);
          }
        }
        /**
         * Add given font option object to the list of objects (the 'pile') to consider for determining
         * multi-font option values.
         *
         * @param {Pile} pile  pile of option objects to use
         * @param {object} options  instance to add to pile
         * @private
         */
      }, {
        key: "addFontToPile",
        value: function addFontToPile(pile, options2) {
          if (options2 === void 0) return;
          if (options2.font === void 0 || options2.font === null) return;
          var item = options2.font;
          pile.push(item);
        }
        /**
         * Collect all own-property values from the font pile that aren't multi-font option objectss.
         *
         * @param {Pile} pile  pile of option objects to use
         * @returns {object} object with all current own basic font properties
         * @private
         */
      }, {
        key: "getBasicOptions",
        value: function getBasicOptions(pile) {
          var ret = {};
          for (var n = 0; n < pile.length; ++n) {
            var fontOptions = pile[n];
            var tmpShorthand = {};
            if (Label2.parseFontString(tmpShorthand, fontOptions)) {
              fontOptions = tmpShorthand;
            }
            forEach$3(fontOptions, function(opt, name) {
              if (opt === void 0) return;
              if (Object.prototype.hasOwnProperty.call(ret, name)) return;
              if (indexOf$3(multiFontStyle).call(multiFontStyle, name) !== -1) {
                ret[name] = {};
              } else {
                ret[name] = opt;
              }
            });
          }
          return ret;
        }
        /**
         * Return the value for given option for the given multi-font.
         *
         * All available option objects are trawled in the set order to construct the option values.
         *
         * ---------------------------------------------------------------------
         * ## Traversal of pile for multi-fonts
         *
         * The determination of multi-font option values is a special case, because any values not
         * present in the multi-font options should by definition be taken from the main font options,
         * i.e. from the current 'parent' object of the multi-font option.
         *
         * ### Search order for multi-fonts
         *
         * 'bold' used as example:
         *
         *   - search in option group 'bold' in local properties
         *   - search in main font option group in local properties
         *
         * ---------------------------------------------------------------------
         *
         * @param {Pile} pile  pile of option objects to use
         * @param {MultiFontStyle} multiName sub path for the multi-font
         * @param {string} option  the option to search for, for the given multi-font
         * @returns {string|number} the value for the given option
         * @private
         */
      }, {
        key: "getFontOption",
        value: function getFontOption(pile, multiName, option) {
          var multiFont;
          for (var n = 0; n < pile.length; ++n) {
            var fontOptions = pile[n];
            if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {
              multiFont = fontOptions[multiName];
              if (multiFont === void 0 || multiFont === null) continue;
              var tmpShorthand = {};
              if (Label2.parseFontString(tmpShorthand, multiFont)) {
                multiFont = tmpShorthand;
              }
              if (Object.prototype.hasOwnProperty.call(multiFont, option)) {
                return multiFont[option];
              }
            }
          }
          if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {
            return this.fontOptions[option];
          }
          throw new Error("Did not find value for multi-font for property: '" + option + "'");
        }
        /**
         * Return all options values for the given multi-font.
         *
         * All available option objects are trawled in the set order to construct the option values.
         *
         * @param {Pile} pile  pile of option objects to use
         * @param {MultiFontStyle} multiName sub path for the mod-font
         * @returns {MultiFontOptions}
         * @private
         */
      }, {
        key: "getFontOptions",
        value: function getFontOptions(pile, multiName) {
          var result = {};
          var optionNames = ["color", "size", "face", "mod", "vadjust"];
          for (var i = 0; i < optionNames.length; ++i) {
            var mod = optionNames[i];
            result[mod] = this.getFontOption(pile, multiName, mod);
          }
          return result;
        }
        /////////////////////////////////////////////////////////
        // End methods for handling options piles
        /////////////////////////////////////////////////////////
        /**
         * Collapse the font options for the multi-font to single objects, from
         * the chain of option objects passed (the 'pile').
         *
         * @param {Pile} pile  sequence of option objects to consider.
         *                     First item in list assumed to be the newly set options.
         */
      }, {
        key: "propagateFonts",
        value: function propagateFonts(pile) {
          var _this2 = this;
          var fontPile = [];
          this.addFontOptionsToPile(fontPile, pile);
          this.fontOptions = this.getBasicOptions(fontPile);
          var _loop = function _loop2(i2) {
            var mod = multiFontStyle[i2];
            var modOptions = _this2.fontOptions[mod];
            var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);
            forEach$3(tmpMultiFontOptions, function(option, n) {
              modOptions[n] = option;
            });
            modOptions.size = Number(modOptions.size);
            modOptions.vadjust = Number(modOptions.vadjust);
          };
          for (var i = 0; i < multiFontStyle.length; ++i) {
            _loop(i);
          }
        }
        /**
         * Main function. This is called from anything that wants to draw a label.
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x
         * @param {number} y
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {string} [baseline='middle']
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover) {
          var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
          if (this.elementOptions.label === void 0) return;
          var viewFontSize = this.fontOptions.size * this.body.view.scale;
          if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return;
          if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
            viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
          }
          this.calculateLabelSize(ctx, selected, hover, x, y, baseline);
          this._drawBackground(ctx);
          this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);
        }
        /**
         * Draws the label background
         * @param {CanvasRenderingContext2D} ctx
         * @private
         */
      }, {
        key: "_drawBackground",
        value: function _drawBackground(ctx) {
          if (this.fontOptions.background !== void 0 && this.fontOptions.background !== "none") {
            ctx.fillStyle = this.fontOptions.background;
            var size = this.getSize();
            ctx.fillRect(size.left, size.top, size.width, size.height);
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x
         * @param {number} y
         * @param {string} [baseline='middle']
         * @param {number} viewFontSize 
         * @private
         */
      }, {
        key: "_drawText",
        value: function _drawText(ctx, x, y) {
          var baseline = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "middle";
          var viewFontSize = arguments.length > 4 ? arguments[4] : void 0;
          var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);
          var _this$_setAlignment2 = slicedToArray(_this$_setAlignment, 2);
          x = _this$_setAlignment2[0];
          y = _this$_setAlignment2[1];
          ctx.textAlign = "left";
          x = x - this.size.width / 2;
          if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
            if (this.fontOptions.valign === "top") {
              y -= (this.size.height - this.size.labelHeight) / 2;
            }
            if (this.fontOptions.valign === "bottom") {
              y += (this.size.height - this.size.labelHeight) / 2;
            }
          }
          for (var i = 0; i < this.lineCount; i++) {
            var line = this.lines[i];
            if (line && line.blocks) {
              var width = 0;
              if (this.isEdgeLabel || this.fontOptions.align === "center") {
                width += (this.size.width - line.width) / 2;
              } else if (this.fontOptions.align === "right") {
                width += this.size.width - line.width;
              }
              for (var j = 0; j < line.blocks.length; j++) {
                var block = line.blocks[j];
                ctx.font = block.font;
                var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor), _this$_getColor2 = slicedToArray(_this$_getColor, 2), fontColor = _this$_getColor2[0], strokeColor = _this$_getColor2[1];
                if (block.strokeWidth > 0) {
                  ctx.lineWidth = block.strokeWidth;
                  ctx.strokeStyle = strokeColor;
                  ctx.lineJoin = "round";
                }
                ctx.fillStyle = fontColor;
                if (block.strokeWidth > 0) {
                  ctx.strokeText(block.text, x + width, y + block.vadjust);
                }
                ctx.fillText(block.text, x + width, y + block.vadjust);
                width += block.width;
              }
              y += line.height;
            }
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x
         * @param {number} y
         * @param {string} baseline
         * @returns {Array.<number>}
         * @private
         */
      }, {
        key: "_setAlignment",
        value: function _setAlignment(ctx, x, y, baseline) {
          if (this.isEdgeLabel && this.fontOptions.align !== "horizontal" && this.pointToSelf === false) {
            x = 0;
            y = 0;
            var lineMargin = 2;
            if (this.fontOptions.align === "top") {
              ctx.textBaseline = "alphabetic";
              y -= 2 * lineMargin;
            } else if (this.fontOptions.align === "bottom") {
              ctx.textBaseline = "hanging";
              y += 2 * lineMargin;
            } else {
              ctx.textBaseline = "middle";
            }
          } else {
            ctx.textBaseline = baseline;
          }
          return [x, y];
        }
        /**
         * fade in when relative scale is between threshold and threshold - 1.
         * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
         *
         * @param {string} color  The font color to use
         * @param {number} viewFontSize
         * @param {string} initialStrokeColor
         * @returns {Array.<string>} An array containing the font color and stroke color
         * @private
         */
      }, {
        key: "_getColor",
        value: function _getColor(color, viewFontSize, initialStrokeColor) {
          var fontColor = color || "#000000";
          var strokeColor = initialStrokeColor || "#ffffff";
          if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
            var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
            fontColor = overrideOpacity(fontColor, opacity);
            strokeColor = overrideOpacity(strokeColor, opacity);
          }
          return [fontColor, strokeColor];
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         * @returns {{width: number, height: number}}
         */
      }, {
        key: "getTextSize",
        value: function getTextSize(ctx) {
          var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          this._processLabel(ctx, selected, hover);
          return {
            width: this.size.width,
            height: this.size.height,
            lineCount: this.lineCount
          };
        }
        /**
         * Get the current dimensions of the label
         *
         * @return {rect}
         */
      }, {
        key: "getSize",
        value: function getSize() {
          var lineMargin = 2;
          var x = this.size.left;
          var y = this.size.top - 0.5 * lineMargin;
          if (this.isEdgeLabel) {
            var x2 = -this.size.width * 0.5;
            switch (this.fontOptions.align) {
              case "middle":
                x = x2;
                y = -this.size.height * 0.5;
                break;
              case "top":
                x = x2;
                y = -(this.size.height + lineMargin);
                break;
              case "bottom":
                x = x2;
                y = lineMargin;
                break;
            }
          }
          var ret = {
            left: x,
            top: y,
            width: this.size.width,
            height: this.size.height
          };
          return ret;
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {number} [x=0]
         * @param {number} [y=0]
         * @param {'middle'|'hanging'} [baseline='middle']
         */
      }, {
        key: "calculateLabelSize",
        value: function calculateLabelSize(ctx, selected, hover) {
          var x = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
          var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
          this._processLabel(ctx, selected, hover);
          this.size.left = x - this.size.width * 0.5;
          this.size.top = y - this.size.height * 0.5;
          this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
          if (baseline === "hanging") {
            this.size.top += 0.5 * this.fontOptions.size;
            this.size.top += 4;
            this.size.yLine += 4;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {string} mod
         * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
         */
      }, {
        key: "getFormattingValues",
        value: function getFormattingValues(ctx, selected, hover, mod) {
          var getValue = function getValue2(fontOptions, mod2, option) {
            if (mod2 === "normal") {
              if (option === "mod") return "";
              return fontOptions[option];
            }
            if (fontOptions[mod2][option] !== void 0) {
              return fontOptions[mod2][option];
            } else {
              return fontOptions[option];
            }
          };
          var values3 = {
            color: getValue(this.fontOptions, mod, "color"),
            size: getValue(this.fontOptions, mod, "size"),
            face: getValue(this.fontOptions, mod, "face"),
            mod: getValue(this.fontOptions, mod, "mod"),
            vadjust: getValue(this.fontOptions, mod, "vadjust"),
            strokeWidth: this.fontOptions.strokeWidth,
            strokeColor: this.fontOptions.strokeColor
          };
          if (selected || hover) {
            if (mod === "normal" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
              values3.mod = "bold";
            } else {
              if (typeof this.fontOptions.chooser === "function") {
                this.fontOptions.chooser(values3, this.elementOptions.id, selected, hover);
              }
            }
          }
          var fontString = "";
          if (values3.mod !== void 0 && values3.mod !== "") {
            fontString += values3.mod + " ";
          }
          fontString += values3.size + "px " + values3.face;
          ctx.font = fontString.replace(/"/g, "");
          values3.font = ctx.font;
          values3.height = values3.size;
          return values3;
        }
        /**
         *
         * @param {boolean} selected
         * @param {boolean} hover
         * @returns {boolean}
         */
      }, {
        key: "differentState",
        value: function differentState(selected, hover) {
          return selected !== this.selectedState || hover !== this.hoverState;
        }
        /**
         * This explodes the passed text into lines and determines the width, height and number of lines.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {string} inText  the text to explode
         * @returns {{width, height, lines}|*}
         * @private
         */
      }, {
        key: "_processLabelText",
        value: function _processLabelText(ctx, selected, hover, inText) {
          var splitter = new LabelSplitter(ctx, this, selected, hover);
          return splitter.process(inText);
        }
        /**
         * This explodes the label string into lines and sets the width, height and number of lines.
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         * @private
         */
      }, {
        key: "_processLabel",
        value: function _processLabel(ctx, selected, hover) {
          if (this.labelDirty === false && !this.differentState(selected, hover)) return;
          var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);
          if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
            state.width = this.fontOptions.minWdt;
          }
          this.size.labelHeight = state.height;
          if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
            state.height = this.fontOptions.minHgt;
          }
          this.lines = state.lines;
          this.lineCount = state.lines.length;
          this.size.width = state.width;
          this.size.height = state.height;
          this.selectedState = selected;
          this.hoverState = hover;
          this.labelDirty = false;
        }
        /**
         * Check if this label is visible
         *
         * @return {boolean} true if this label will be show, false otherwise
         */
      }, {
        key: "visible",
        value: function visible() {
          if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === void 0) {
            return false;
          }
          var viewFontSize = this.fontOptions.size * this.body.view.scale;
          if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
            return false;
          }
          return true;
        }
      }], [{
        key: "parseFontString",
        value: function parseFontString(outOptions, inOptions) {
          if (!inOptions || typeof inOptions !== "string") return false;
          var newOptionsArray = inOptions.split(" ");
          outOptions.size = +newOptionsArray[0].replace("px", "");
          outOptions.face = newOptionsArray[1];
          outOptions.color = newOptionsArray[2];
          return true;
        }
      }]);
      return Label2;
    }();
    arrayFill = function fill(value) {
      var O = toObject(this);
      var length2 = toLength(O.length);
      var argumentsLength = arguments.length;
      var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length2);
      var end = argumentsLength > 2 ? arguments[2] : void 0;
      var endPos = end === void 0 ? length2 : toAbsoluteIndex(end, length2);
      while (endPos > index2) O[index2++] = value;
      return O;
    };
    _export({
      target: "Array",
      proto: true
    }, {
      fill: arrayFill
    });
    fill2 = entryVirtual("Array").fill;
    ArrayPrototype$g = Array.prototype;
    fill_1 = function(it2) {
      var own = it2.fill;
      return it2 === ArrayPrototype$g || it2 instanceof Array && own === ArrayPrototype$g.fill ? fill2 : own;
    };
    fill$1 = fill_1;
    fill$2 = fill$1;
    NodeBase = function() {
      function NodeBase2(options2, body, labelModule) {
        classCallCheck(this, NodeBase2);
        this.body = body;
        this.labelModule = labelModule;
        this.setOptions(options2);
        this.top = void 0;
        this.left = void 0;
        this.height = void 0;
        this.width = void 0;
        this.radius = void 0;
        this.margin = void 0;
        this.refreshNeeded = true;
        this.boundingBox = {
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        };
      }
      createClass(NodeBase2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
        }
        /**
         *
         * @param {Label} labelModule
         * @private
         */
      }, {
        key: "_setMargins",
        value: function _setMargins(labelModule) {
          this.margin = {};
          if (this.options.margin) {
            if (_typeof_1(this.options.margin) == "object") {
              this.margin.top = this.options.margin.top;
              this.margin.right = this.options.margin.right;
              this.margin.bottom = this.options.margin.bottom;
              this.margin.left = this.options.margin.left;
            } else {
              this.margin.top = this.options.margin;
              this.margin.right = this.options.margin;
              this.margin.bottom = this.options.margin;
              this.margin.left = this.options.margin;
            }
          }
          labelModule.adjustSizes(this.margin);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         * @private
         */
      }, {
        key: "_distanceToBorder",
        value: function _distanceToBorder(ctx, angle) {
          var borderWidth = this.options.borderWidth;
          if (ctx) {
            this.resize(ctx);
          }
          return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         */
      }, {
        key: "enableShadow",
        value: function enableShadow(ctx, values3) {
          if (values3.shadow) {
            ctx.shadowColor = values3.shadowColor;
            ctx.shadowBlur = values3.shadowSize;
            ctx.shadowOffsetX = values3.shadowX;
            ctx.shadowOffsetY = values3.shadowY;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         */
      }, {
        key: "disableShadow",
        value: function disableShadow(ctx, values3) {
          if (values3.shadow) {
            ctx.shadowColor = "rgba(0,0,0,0)";
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         */
      }, {
        key: "enableBorderDashes",
        value: function enableBorderDashes(ctx, values3) {
          if (values3.borderDashes !== false) {
            if (ctx.setLineDash !== void 0) {
              var dashes = values3.borderDashes;
              if (dashes === true) {
                dashes = [5, 15];
              }
              ctx.setLineDash(dashes);
            } else {
              console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
              this.options.shapeProperties.borderDashes = false;
              values3.borderDashes = false;
            }
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         */
      }, {
        key: "disableBorderDashes",
        value: function disableBorderDashes(ctx, values3) {
          if (values3.borderDashes !== false) {
            if (ctx.setLineDash !== void 0) {
              ctx.setLineDash([0]);
            } else {
              console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
              this.options.shapeProperties.borderDashes = false;
              values3.borderDashes = false;
            }
          }
        }
        /**
         * Determine if the shape of a node needs to be recalculated.
         *
         * @param {boolean} selected
         * @param {boolean} hover
         * @returns {boolean}
         * @protected
         */
      }, {
        key: "needsRefresh",
        value: function needsRefresh(selected, hover) {
          if (this.refreshNeeded === true) {
            this.refreshNeeded = false;
            return true;
          }
          return this.width === void 0 || this.labelModule.differentState(selected, hover);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         */
      }, {
        key: "initContextForDraw",
        value: function initContextForDraw(ctx, values3) {
          var borderWidth = values3.borderWidth / this.body.view.scale;
          ctx.lineWidth = Math.min(this.width, borderWidth);
          ctx.strokeStyle = values3.borderColor;
          ctx.fillStyle = values3.color;
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         */
      }, {
        key: "performStroke",
        value: function performStroke(ctx, values3) {
          var borderWidth = values3.borderWidth / this.body.view.scale;
          ctx.save();
          if (borderWidth > 0) {
            this.enableBorderDashes(ctx, values3);
            ctx.stroke();
            this.disableBorderDashes(ctx, values3);
          }
          ctx.restore();
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         */
      }, {
        key: "performFill",
        value: function performFill(ctx, values3) {
          ctx.save();
          ctx.fillStyle = values3.color;
          this.enableShadow(ctx, values3);
          fill$2(ctx).call(ctx);
          this.disableShadow(ctx, values3);
          ctx.restore();
          this.performStroke(ctx, values3);
        }
        /**
         *
         * @param {number} margin
         * @private
         */
      }, {
        key: "_addBoundingBoxMargin",
        value: function _addBoundingBoxMargin(margin) {
          this.boundingBox.left -= margin;
          this.boundingBox.top -= margin;
          this.boundingBox.bottom += margin;
          this.boundingBox.right += margin;
        }
        /**
         * Actual implementation of this method call.
         *
         * Doing it like this makes it easier to override
         * in the child classes.
         *
         * @param {number} x width
         * @param {number} y height
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         * @private
         */
      }, {
        key: "_updateBoundingBox",
        value: function _updateBoundingBox(x, y, ctx, selected, hover) {
          if (ctx !== void 0) {
            this.resize(ctx, selected, hover);
          }
          this.left = x - this.width / 2;
          this.top = y - this.height / 2;
          this.boundingBox.left = this.left;
          this.boundingBox.top = this.top;
          this.boundingBox.bottom = this.top + this.height;
          this.boundingBox.right = this.left + this.width;
        }
        /**
         * Default implementation of this method call.
         * This acts as a stub which can be overridden.
         *
         * @param {number} x width
         * @param {number} y height
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(x, y, ctx, selected, hover) {
          this._updateBoundingBox(x, y, ctx, selected, hover);
        }
        /**
         * Determine the dimensions to use for nodes with an internal label
         *
         * Currently, these are: Circle, Ellipse, Database, Box
         * The other nodes have external labels, and will not call this method
         *
         * If there is no label, decent default values are supplied.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} [selected]
         * @param {boolean} [hover]
         * @returns {{width:number, height:number}}
         */
      }, {
        key: "getDimensionsFromLabel",
        value: function getDimensionsFromLabel(ctx, selected, hover) {
          this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
          var width = this.textSize.width;
          var height = this.textSize.height;
          var DEFAULT_SIZE = 14;
          if (width === 0) {
            width = DEFAULT_SIZE;
            height = DEFAULT_SIZE;
          }
          return {
            width,
            height
          };
        }
      }]);
      return NodeBase2;
    }();
    Box = function(_NodeBase) {
      inherits(Box2, _NodeBase);
      var _super = _createSuper$1(Box2);
      function Box2(options2, body, labelModule) {
        var _this;
        classCallCheck(this, Box2);
        _this = _super.call(this, options2, body, labelModule);
        _this._setMargins(labelModule);
        return _this;
      }
      createClass(Box2, [{
        key: "resize",
        value: function resize(ctx) {
          var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
          var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
          if (this.needsRefresh(selected, hover)) {
            var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
            this.width = dimensions.width + this.margin.right + this.margin.left;
            this.height = dimensions.height + this.margin.top + this.margin.bottom;
            this.radius = this.width / 2;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this.resize(ctx, selected, hover);
          this.left = x - this.width / 2;
          this.top = y - this.height / 2;
          this.initContextForDraw(ctx, values3);
          drawRoundRect(ctx, this.left, this.top, this.width, this.height, values3.borderRadius);
          this.performFill(ctx, values3);
          this.updateBoundingBox(x, y, ctx, selected, hover);
          this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
        }
        /**
         *
         * @param {number} x width
         * @param {number} y height
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} selected
         * @param {boolean} hover
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(x, y, ctx, selected, hover) {
          this._updateBoundingBox(x, y, ctx, selected, hover);
          var borderRadius = this.options.shapeProperties.borderRadius;
          this._addBoundingBoxMargin(borderRadius);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          if (ctx) {
            this.resize(ctx);
          }
          var borderWidth = this.options.borderWidth;
          return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
        }
      }]);
      return Box2;
    }(NodeBase);
    CircleImageBase = function(_NodeBase) {
      inherits(CircleImageBase2, _NodeBase);
      var _super = _createSuper$2(CircleImageBase2);
      function CircleImageBase2(options2, body, labelModule) {
        var _this;
        classCallCheck(this, CircleImageBase2);
        _this = _super.call(this, options2, body, labelModule);
        _this.labelOffset = 0;
        _this.selected = false;
        return _this;
      }
      createClass(CircleImageBase2, [{
        key: "setOptions",
        value: function setOptions(options2, imageObj, imageObjAlt) {
          this.options = options2;
          if (!(imageObj === void 0 && imageObjAlt === void 0)) {
            this.setImages(imageObj, imageObjAlt);
          }
        }
        /**
         * Set the images for this node.
         *
         * The images can be updated after the initial setting of options;
         * therefore, this method needs to be reentrant. 
         *
         * For correct working in error cases, it is necessary to properly set
         * field 'nodes.brokenImage' in the options.
         *
         * @param {Image} imageObj  required; main image to show for this node
         * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
         */
      }, {
        key: "setImages",
        value: function setImages(imageObj, imageObjAlt) {
          if (imageObjAlt && this.selected) {
            this.imageObj = imageObjAlt;
            this.imageObjAlt = imageObj;
          } else {
            this.imageObj = imageObj;
            this.imageObjAlt = imageObjAlt;
          }
        }
        /**
         * Set selection and switch between the base and the selected image.
         *
         * Do the switch only if imageObjAlt exists.
         *
         * @param {boolean} selected value of new selected state for current node
         */
      }, {
        key: "switchImages",
        value: function switchImages(selected) {
          var selection_changed = selected && !this.selected || !selected && this.selected;
          this.selected = selected;
          if (this.imageObjAlt !== void 0 && selection_changed) {
            var imageTmp = this.imageObj;
            this.imageObj = this.imageObjAlt;
            this.imageObjAlt = imageTmp;
          }
        }
        /**
         * Returns Image Padding from node options
         *
         * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape
         * @private
         */
      }, {
        key: "_getImagePadding",
        value: function _getImagePadding() {
          var imgPadding = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
          if (this.options.imagePadding) {
            var optImgPadding = this.options.imagePadding;
            if (_typeof_1(optImgPadding) == "object") {
              imgPadding.top = optImgPadding.top;
              imgPadding.right = optImgPadding.right;
              imgPadding.bottom = optImgPadding.bottom;
              imgPadding.left = optImgPadding.left;
            } else {
              imgPadding.top = optImgPadding;
              imgPadding.right = optImgPadding;
              imgPadding.bottom = optImgPadding;
              imgPadding.left = optImgPadding;
            }
          }
          return imgPadding;
        }
        /**
         * Adjust the node dimensions for a loaded image.
         *
         * Pre: this.imageObj is valid
         */
      }, {
        key: "_resizeImage",
        value: function _resizeImage() {
          var width, height;
          if (this.options.shapeProperties.useImageSize === false) {
            var ratio_width = 1;
            var ratio_height = 1;
            if (this.imageObj.width && this.imageObj.height) {
              if (this.imageObj.width > this.imageObj.height) {
                ratio_width = this.imageObj.width / this.imageObj.height;
              } else {
                ratio_height = this.imageObj.height / this.imageObj.width;
              }
            }
            width = this.options.size * 2 * ratio_width;
            height = this.options.size * 2 * ratio_height;
          } else {
            var imgPadding = this._getImagePadding();
            width = this.imageObj.width + imgPadding.left + imgPadding.right;
            height = this.imageObj.height + imgPadding.top + imgPadding.bottom;
          }
          this.width = width;
          this.height = height;
          this.radius = 0.5 * this.width;
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {ArrowOptions} values
         * @private
         */
      }, {
        key: "_drawRawCircle",
        value: function _drawRawCircle(ctx, x, y, values3) {
          this.initContextForDraw(ctx, values3);
          drawCircle(ctx, x, y, values3.size);
          this.performFill(ctx, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {ArrowOptions} values
         * @private
         */
      }, {
        key: "_drawImageAtPosition",
        value: function _drawImageAtPosition(ctx, values3) {
          if (this.imageObj.width != 0) {
            ctx.globalAlpha = values3.opacity !== void 0 ? values3.opacity : 1;
            this.enableShadow(ctx, values3);
            var factor = 1;
            if (this.options.shapeProperties.interpolation === true) {
              factor = this.imageObj.width / this.width / this.body.view.scale;
            }
            var imgPadding = this._getImagePadding();
            var imgPosLeft = this.left + imgPadding.left;
            var imgPosTop = this.top + imgPadding.top;
            var imgWidth = this.width - imgPadding.left - imgPadding.right;
            var imgHeight = this.height - imgPadding.top - imgPadding.bottom;
            this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight);
            this.disableShadow(ctx, values3);
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @private
         */
      }, {
        key: "_drawImageLabel",
        value: function _drawImageLabel(ctx, x, y, selected, hover) {
          var offset = 0;
          if (this.height !== void 0) {
            offset = this.height * 0.5;
            var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);
            if (labelDimensions.lineCount >= 1) {
              offset += labelDimensions.height / 2;
            }
          }
          var yLabel = y + offset;
          if (this.options.label) {
            this.labelOffset = offset;
          }
          this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
        }
      }]);
      return CircleImageBase2;
    }(NodeBase);
    Circle = function(_CircleImageBase) {
      inherits(Circle2, _CircleImageBase);
      var _super = _createSuper$3(Circle2);
      function Circle2(options2, body, labelModule) {
        var _this;
        classCallCheck(this, Circle2);
        _this = _super.call(this, options2, body, labelModule);
        _this._setMargins(labelModule);
        return _this;
      }
      createClass(Circle2, [{
        key: "resize",
        value: function resize(ctx) {
          var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
          var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
          if (this.needsRefresh(selected, hover)) {
            var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
            var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);
            this.options.size = diameter / 2;
            this.width = diameter;
            this.height = diameter;
            this.radius = this.width / 2;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this.resize(ctx, selected, hover);
          this.left = x - this.width / 2;
          this.top = y - this.height / 2;
          this._drawRawCircle(ctx, x, y, values3);
          this.updateBoundingBox(x, y);
          this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);
        }
        /**
         *
         * @param {number} x width
         * @param {number} y height
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(x, y) {
          this.boundingBox.top = y - this.options.size;
          this.boundingBox.left = x - this.options.size;
          this.boundingBox.right = x + this.options.size;
          this.boundingBox.bottom = y + this.options.size;
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle - Unused
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          if (ctx) {
            this.resize(ctx);
          }
          return this.width * 0.5;
        }
      }]);
      return Circle2;
    }(CircleImageBase);
    CircularImage = function(_CircleImageBase) {
      inherits(CircularImage2, _CircleImageBase);
      var _super = _createSuper$4(CircularImage2);
      function CircularImage2(options2, body, labelModule, imageObj, imageObjAlt) {
        var _this;
        classCallCheck(this, CircularImage2);
        _this = _super.call(this, options2, body, labelModule);
        _this.setImages(imageObj, imageObjAlt);
        return _this;
      }
      createClass(CircularImage2, [{
        key: "resize",
        value: function resize(ctx) {
          var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
          var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
          var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
          if (imageAbsent) {
            var diameter = this.options.size * 2;
            this.width = diameter;
            this.height = diameter;
            this.radius = 0.5 * this.width;
            return;
          }
          if (this.needsRefresh(selected, hover)) {
            this._resizeImage();
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this.switchImages(selected);
          this.resize();
          var labelX = x, labelY = y;
          if (this.options.shapeProperties.coordinateOrigin === "top-left") {
            this.left = x;
            this.top = y;
            labelX += this.width / 2;
            labelY += this.height / 2;
          } else {
            this.left = x - this.width / 2;
            this.top = y - this.height / 2;
          }
          this._drawRawCircle(ctx, labelX, labelY, values3);
          ctx.save();
          ctx.clip();
          this._drawImageAtPosition(ctx, values3);
          ctx.restore();
          this._drawImageLabel(ctx, labelX, labelY, selected, hover);
          this.updateBoundingBox(x, y);
        }
        // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here
        /**
         *
         * @param {number} x width
         * @param {number} y height
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(x, y) {
          if (this.options.shapeProperties.coordinateOrigin === "top-left") {
            this.boundingBox.top = y;
            this.boundingBox.left = x;
            this.boundingBox.right = x + this.options.size * 2;
            this.boundingBox.bottom = y + this.options.size * 2;
          } else {
            this.boundingBox.top = y - this.options.size;
            this.boundingBox.left = x - this.options.size;
            this.boundingBox.right = x + this.options.size;
            this.boundingBox.bottom = y + this.options.size;
          }
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle - Unused
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          if (ctx) {
            this.resize(ctx);
          }
          return this.width * 0.5;
        }
      }]);
      return CircularImage2;
    }(CircleImageBase);
    ShapeBase = function(_NodeBase) {
      inherits(ShapeBase2, _NodeBase);
      var _super = _createSuper$5(ShapeBase2);
      function ShapeBase2(options2, body, labelModule) {
        classCallCheck(this, ShapeBase2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(ShapeBase2, [{
        key: "resize",
        value: function resize(ctx) {
          var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
          var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
          var values3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            size: this.options.size
          };
          if (this.needsRefresh(selected, hover)) {
            this.labelModule.getTextSize(ctx, selected, hover);
            var size = 2 * values3.size;
            this.width = size;
            this.height = size;
            this.radius = 0.5 * this.width;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {string} shape
         * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
         * @param {number} x
         * @param {number} y
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         * @param {function} customRenderer - a custom shape renderer similar to getShape(shape) functions
         * @private
         */
      }, {
        key: "_drawShape",
        value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values3, customRenderer) {
          this.resize(ctx, selected, hover, values3);
          this.left = x - this.width / 2;
          this.top = y - this.height / 2;
          if (shape === "custom") {
            ctx.save();
            customRenderer({
              ctx,
              x,
              y,
              state: {
                selected,
                hover
              },
              style: _objectSpread$1({}, values3),
              label: this.options.label
            });
            ctx.restore();
            return;
          } else {
            this.initContextForDraw(ctx, values3);
            getShape(shape)(ctx, x, y, values3.size);
            this.performFill(ctx, values3);
          }
          if (this.options.icon !== void 0) {
            if (this.options.icon.code !== void 0) {
              ctx.font = (selected ? "bold " : "") + this.height / 2 + "px " + (this.options.icon.face || "FontAwesome");
              ctx.fillStyle = this.options.icon.color || "black";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(this.options.icon.code, x, y);
            }
          }
          if (this.options.label !== void 0) {
            this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, "hanging");
            var yLabel = y + 0.5 * this.height + 0.5 * this.labelModule.size.height;
            this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
          }
          this.updateBoundingBox(x, y);
        }
        /**
         *
         * @param {number} x
         * @param {number} y
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(x, y) {
          this.boundingBox.top = y - this.options.size;
          this.boundingBox.left = x - this.options.size;
          this.boundingBox.right = x + this.options.size;
          this.boundingBox.bottom = y + this.options.size;
          if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
            this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
            this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
            this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
          }
        }
      }]);
      return ShapeBase2;
    }(NodeBase);
    CustomShape = function(_ShapeBase) {
      inherits(CustomShape2, _ShapeBase);
      var _super = _createSuper$6(CustomShape2);
      function CustomShape2(options2, body, labelModule, ctxRenderer) {
        var _this;
        classCallCheck(this, CustomShape2);
        _this = _super.call(this, options2, body, labelModule, ctxRenderer);
        _this.ctxRenderer = ctxRenderer;
        return _this;
      }
      createClass(CustomShape2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "custom", 4, x, y, selected, hover, values3, this.ctxRenderer);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return CustomShape2;
    }(ShapeBase);
    Database = function(_NodeBase) {
      inherits(Database2, _NodeBase);
      var _super = _createSuper$7(Database2);
      function Database2(options2, body, labelModule) {
        var _this;
        classCallCheck(this, Database2);
        _this = _super.call(this, options2, body, labelModule);
        _this._setMargins(labelModule);
        return _this;
      }
      createClass(Database2, [{
        key: "resize",
        value: function resize(ctx, selected, hover) {
          if (this.needsRefresh(selected, hover)) {
            var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
            var size = dimensions.width + this.margin.right + this.margin.left;
            this.width = size;
            this.height = size;
            this.radius = this.width / 2;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this.resize(ctx, selected, hover);
          this.left = x - this.width / 2;
          this.top = y - this.height / 2;
          this.initContextForDraw(ctx, values3);
          drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);
          this.performFill(ctx, values3);
          this.updateBoundingBox(x, y, ctx, selected, hover);
          this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Database2;
    }(NodeBase);
    Diamond = function(_ShapeBase) {
      inherits(Diamond2, _ShapeBase);
      var _super = _createSuper$8(Diamond2);
      function Diamond2(options2, body, labelModule) {
        classCallCheck(this, Diamond2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(Diamond2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "diamond", 4, x, y, selected, hover, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Diamond2;
    }(ShapeBase);
    Dot = function(_ShapeBase) {
      inherits(Dot2, _ShapeBase);
      var _super = _createSuper$9(Dot2);
      function Dot2(options2, body, labelModule) {
        classCallCheck(this, Dot2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(Dot2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "circle", 2, x, y, selected, hover, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          if (ctx) {
            this.resize(ctx);
          }
          return this.options.size;
        }
      }]);
      return Dot2;
    }(ShapeBase);
    Ellipse = function(_NodeBase) {
      inherits(Ellipse2, _NodeBase);
      var _super = _createSuper$a(Ellipse2);
      function Ellipse2(options2, body, labelModule) {
        classCallCheck(this, Ellipse2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(Ellipse2, [{
        key: "resize",
        value: function resize(ctx) {
          var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
          var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
          if (this.needsRefresh(selected, hover)) {
            var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
            this.height = dimensions.height * 2;
            this.width = dimensions.width + dimensions.height;
            this.radius = 0.5 * this.width;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this.resize(ctx, selected, hover);
          this.left = x - this.width * 0.5;
          this.top = y - this.height * 0.5;
          this.initContextForDraw(ctx, values3);
          drawEllipse(ctx, this.left, this.top, this.width, this.height);
          this.performFill(ctx, values3);
          this.updateBoundingBox(x, y, ctx, selected, hover);
          this.labelModule.draw(ctx, x, y, selected, hover);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          if (ctx) {
            this.resize(ctx);
          }
          var a = this.width * 0.5;
          var b = this.height * 0.5;
          var w = Math.sin(angle) * a;
          var h = Math.cos(angle) * b;
          return a * b / Math.sqrt(w * w + h * h);
        }
      }]);
      return Ellipse2;
    }(NodeBase);
    Icon = function(_NodeBase) {
      inherits(Icon2, _NodeBase);
      var _super = _createSuper$b(Icon2);
      function Icon2(options2, body, labelModule) {
        var _this;
        classCallCheck(this, Icon2);
        _this = _super.call(this, options2, body, labelModule);
        _this._setMargins(labelModule);
        return _this;
      }
      createClass(Icon2, [{
        key: "resize",
        value: function resize(ctx, selected, hover) {
          if (this.needsRefresh(selected, hover)) {
            this.iconSize = {
              width: Number(this.options.icon.size),
              height: Number(this.options.icon.size)
            };
            this.width = this.iconSize.width + this.margin.right + this.margin.left;
            this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
            this.radius = 0.5 * this.width;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this.resize(ctx, selected, hover);
          this.options.icon.size = this.options.icon.size || 50;
          this.left = x - this.width / 2;
          this.top = y - this.height / 2;
          this._icon(ctx, x, y, selected, hover, values3);
          if (this.options.label !== void 0) {
            var iconTextSpacing = 5;
            this.labelModule.draw(ctx, this.left + this.iconSize.width / 2 + this.margin.left, y + this.height / 2 + iconTextSpacing, selected);
          }
          this.updateBoundingBox(x, y);
        }
        /**
         *
         * @param {number} x
         * @param {number} y
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(x, y) {
          this.boundingBox.top = y - this.options.icon.size * 0.5;
          this.boundingBox.left = x - this.options.icon.size * 0.5;
          this.boundingBox.right = x + this.options.icon.size * 0.5;
          this.boundingBox.bottom = y + this.options.icon.size * 0.5;
          if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
            var iconTextSpacing = 5;
            this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
            this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
            this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover - Unused
         * @param {ArrowOptions} values
         */
      }, {
        key: "_icon",
        value: function _icon(ctx, x, y, selected, hover, values3) {
          var iconSize = Number(this.options.icon.size);
          if (this.options.icon.code !== void 0) {
            ctx.font = [
              this.options.icon.weight != null ? this.options.icon.weight : selected ? "bold" : "",
              // If the weight is forced (for example to make Font Awesome 5 work
              // properly) substitute slightly bigger size for bold font face.
              (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + "px",
              this.options.icon.face
            ].join(" ");
            ctx.fillStyle = this.options.icon.color || "black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            this.enableShadow(ctx, values3);
            ctx.fillText(this.options.icon.code, x, y);
            this.disableShadow(ctx, values3);
          } else {
            console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Icon2;
    }(NodeBase);
    Image$1 = function(_CircleImageBase) {
      inherits(Image2, _CircleImageBase);
      var _super = _createSuper$c(Image2);
      function Image2(options2, body, labelModule, imageObj, imageObjAlt) {
        var _this;
        classCallCheck(this, Image2);
        _this = _super.call(this, options2, body, labelModule);
        _this.setImages(imageObj, imageObjAlt);
        return _this;
      }
      createClass(Image2, [{
        key: "resize",
        value: function resize(ctx) {
          var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
          var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
          var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
          if (imageAbsent) {
            var side = this.options.size * 2;
            this.width = side;
            this.height = side;
            return;
          }
          if (this.needsRefresh(selected, hover)) {
            this._resizeImage();
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          ctx.save();
          this.switchImages(selected);
          this.resize();
          var labelX = x, labelY = y;
          if (this.options.shapeProperties.coordinateOrigin === "top-left") {
            this.left = x;
            this.top = y;
            labelX += this.width / 2;
            labelY += this.height / 2;
          } else {
            this.left = x - this.width / 2;
            this.top = y - this.height / 2;
          }
          if (this.options.shapeProperties.useBorderWithImage === true) {
            var neutralborderWidth = this.options.borderWidth;
            var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
            var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
            ctx.lineWidth = Math.min(this.width, borderWidth);
            ctx.beginPath();
            var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
            var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
            if (values3.opacity !== void 0) {
              strokeStyle = overrideOpacity(strokeStyle, values3.opacity);
              fillStyle = overrideOpacity(fillStyle, values3.opacity);
            }
            ctx.strokeStyle = strokeStyle;
            ctx.fillStyle = fillStyle;
            ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
            fill$2(ctx).call(ctx);
            this.performStroke(ctx, values3);
            ctx.closePath();
          }
          this._drawImageAtPosition(ctx, values3);
          this._drawImageLabel(ctx, labelX, labelY, selected, hover);
          this.updateBoundingBox(x, y);
          ctx.restore();
        }
        /**
         *
         * @param {number} x
         * @param {number} y
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(x, y) {
          this.resize();
          if (this.options.shapeProperties.coordinateOrigin === "top-left") {
            this.left = x;
            this.top = y;
          } else {
            this.left = x - this.width / 2;
            this.top = y - this.height / 2;
          }
          this.boundingBox.left = this.left;
          this.boundingBox.top = this.top;
          this.boundingBox.bottom = this.top + this.height;
          this.boundingBox.right = this.left + this.width;
          if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
            this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
            this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
            this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Image2;
    }(CircleImageBase);
    Square = function(_ShapeBase) {
      inherits(Square2, _ShapeBase);
      var _super = _createSuper$d(Square2);
      function Square2(options2, body, labelModule) {
        classCallCheck(this, Square2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(Square2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "square", 2, x, y, selected, hover, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Square2;
    }(ShapeBase);
    Hexagon = function(_ShapeBase) {
      inherits(Hexagon2, _ShapeBase);
      var _super = _createSuper$e(Hexagon2);
      function Hexagon2(options2, body, labelModule) {
        classCallCheck(this, Hexagon2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(Hexagon2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "hexagon", 4, x, y, selected, hover, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Hexagon2;
    }(ShapeBase);
    Star = function(_ShapeBase) {
      inherits(Star2, _ShapeBase);
      var _super = _createSuper$f(Star2);
      function Star2(options2, body, labelModule) {
        classCallCheck(this, Star2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(Star2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "star", 4, x, y, selected, hover, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Star2;
    }(ShapeBase);
    Text = function(_NodeBase) {
      inherits(Text2, _NodeBase);
      var _super = _createSuper$g(Text2);
      function Text2(options2, body, labelModule) {
        var _this;
        classCallCheck(this, Text2);
        _this = _super.call(this, options2, body, labelModule);
        _this._setMargins(labelModule);
        return _this;
      }
      createClass(Text2, [{
        key: "resize",
        value: function resize(ctx, selected, hover) {
          if (this.needsRefresh(selected, hover)) {
            this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
            this.width = this.textSize.width + this.margin.right + this.margin.left;
            this.height = this.textSize.height + this.margin.top + this.margin.bottom;
            this.radius = 0.5 * this.width;
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x width
         * @param {number} y height
         * @param {boolean} selected
         * @param {boolean} hover
         * @param {ArrowOptions} values
         */
      }, {
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this.resize(ctx, selected, hover);
          this.left = x - this.width / 2;
          this.top = y - this.height / 2;
          this.enableShadow(ctx, values3);
          this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
          this.disableShadow(ctx, values3);
          this.updateBoundingBox(x, y, ctx, selected, hover);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Text2;
    }(NodeBase);
    Triangle = function(_ShapeBase) {
      inherits(Triangle2, _ShapeBase);
      var _super = _createSuper$h(Triangle2);
      function Triangle2(options2, body, labelModule) {
        classCallCheck(this, Triangle2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(Triangle2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "triangle", 3, x, y, selected, hover, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return Triangle2;
    }(ShapeBase);
    TriangleDown = function(_ShapeBase) {
      inherits(TriangleDown2, _ShapeBase);
      var _super = _createSuper$i(TriangleDown2);
      function TriangleDown2(options2, body, labelModule) {
        classCallCheck(this, TriangleDown2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(TriangleDown2, [{
        key: "draw",
        value: function draw(ctx, x, y, selected, hover, values3) {
          this._drawShape(ctx, "triangleDown", 3, x, y, selected, hover, values3);
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} angle
         * @returns {number}
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this._distanceToBorder(ctx, angle);
        }
      }]);
      return TriangleDown2;
    }(ShapeBase);
    errorFound = false;
    printStyle = "background: #FFeeee; color: #dd0000";
    Validator = function() {
      function Validator2() {
        classCallCheck(this, Validator2);
      }
      createClass(Validator2, null, [{
        key: "validate",
        value: function validate(options2, referenceOptions, subObject) {
          errorFound = false;
          allOptions = referenceOptions;
          var usedOptions = referenceOptions;
          if (subObject !== void 0) {
            usedOptions = referenceOptions[subObject];
          }
          Validator2.parse(options2, usedOptions, []);
          return errorFound;
        }
        /**
         * Will traverse an object recursively and check every value
         * @param {Object} options
         * @param {Object} referenceOptions
         * @param {array} path    | where to look for the actual option
         * @static
         */
      }, {
        key: "parse",
        value: function parse(options2, referenceOptions, path2) {
          for (var option in options2) {
            if (Object.prototype.hasOwnProperty.call(options2, option)) {
              Validator2.check(option, options2, referenceOptions, path2);
            }
          }
        }
        /**
         * Check every value. If the value is an object, call the parse function on that object.
         * @param {string} option
         * @param {Object} options
         * @param {Object} referenceOptions
         * @param {array} path    | where to look for the actual option
         * @static
         */
      }, {
        key: "check",
        value: function check2(option, options2, referenceOptions, path2) {
          if (referenceOptions[option] === void 0 && referenceOptions.__any__ === void 0) {
            Validator2.getSuggestion(option, referenceOptions, path2);
            return;
          }
          var referenceOption = option;
          var is_object = true;
          if (referenceOptions[option] === void 0 && referenceOptions.__any__ !== void 0) {
            referenceOption = "__any__";
            is_object = Validator2.getType(options2[option]) === "object";
          }
          var refOptionObj = referenceOptions[referenceOption];
          if (is_object && refOptionObj.__type__ !== void 0) {
            refOptionObj = refOptionObj.__type__;
          }
          Validator2.checkFields(option, options2, referenceOptions, referenceOption, refOptionObj, path2);
        }
        /**
         *
         * @param {string}  option           | the option property
         * @param {Object}  options          | The supplied options object
         * @param {Object}  referenceOptions | The reference options containing all options and their allowed formats
         * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
         * @param {string}  refOptionObj     | This is the type object from the reference options
         * @param {Array}   path             | where in the object is the option
         * @static
         */
      }, {
        key: "checkFields",
        value: function checkFields(option, options2, referenceOptions, referenceOption, refOptionObj, path2) {
          var log = function log2(message) {
            console.log("%c" + message + Validator2.printLocation(path2, option), printStyle);
          };
          var optionType = Validator2.getType(options2[option]);
          var refOptionType = refOptionObj[optionType];
          if (refOptionType !== void 0) {
            if (Validator2.getType(refOptionType) === "array" && indexOf$3(refOptionType).call(refOptionType, options2[option]) === -1) {
              log('Invalid option detected in "' + option + '". Allowed values are:' + Validator2.print(refOptionType) + ' not "' + options2[option] + '". ');
              errorFound = true;
            } else if (optionType === "object" && referenceOption !== "__any__") {
              path2 = copyAndExtendArray(path2, option);
              Validator2.parse(options2[option], referenceOptions[referenceOption], path2);
            }
          } else if (refOptionObj["any"] === void 0) {
            log('Invalid type received for "' + option + '". Expected: ' + Validator2.print(keys$3(refOptionObj)) + ". Received [" + optionType + '] "' + options2[option] + '"');
            errorFound = true;
          }
        }
        /**
         *
         * @param {Object|boolean|number|string|Array.<number>|Date|Node|Moment|undefined|null} object
         * @returns {string}
         * @static
         */
      }, {
        key: "getType",
        value: function getType2(object2) {
          var type = _typeof_1(object2);
          if (type === "object") {
            if (object2 === null) {
              return "null";
            }
            if (object2 instanceof Boolean) {
              return "boolean";
            }
            if (object2 instanceof Number) {
              return "number";
            }
            if (object2 instanceof String) {
              return "string";
            }
            if (isArray$5(object2)) {
              return "array";
            }
            if (object2 instanceof Date) {
              return "date";
            }
            if (object2.nodeType !== void 0) {
              return "dom";
            }
            if (object2._isAMomentObject === true) {
              return "moment";
            }
            return "object";
          } else if (type === "number") {
            return "number";
          } else if (type === "boolean") {
            return "boolean";
          } else if (type === "string") {
            return "string";
          } else if (type === void 0) {
            return "undefined";
          }
          return type;
        }
        /**
         * @param {string} option
         * @param {Object} options
         * @param {Array.<string>} path
         * @static
         */
      }, {
        key: "getSuggestion",
        value: function getSuggestion(option, options2, path2) {
          var localSearch = Validator2.findInOptions(option, options2, path2, false);
          var globalSearch = Validator2.findInOptions(option, allOptions, [], true);
          var localSearchThreshold = 8;
          var globalSearchThreshold = 4;
          var msg;
          if (localSearch.indexMatch !== void 0) {
            msg = " in " + Validator2.printLocation(localSearch.path, option, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
          } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
            msg = " in " + Validator2.printLocation(localSearch.path, option, "") + "Perhaps it was misplaced? Matching option found at: " + Validator2.printLocation(globalSearch.path, globalSearch.closestMatch, "");
          } else if (localSearch.distance <= localSearchThreshold) {
            msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator2.printLocation(localSearch.path, option);
          } else {
            msg = ". Did you mean one of these: " + Validator2.print(keys$3(options2)) + Validator2.printLocation(path2, option);
          }
          console.log('%cUnknown option detected: "' + option + '"' + msg, printStyle);
          errorFound = true;
        }
        /**
         * traverse the options in search for a match.
         * @param {string} option
         * @param {Object} options
         * @param {Array} path    | where to look for the actual option
         * @param {boolean} [recursive=false]
         * @returns {{closestMatch: string, path: Array, distance: number}}
         * @static
         */
      }, {
        key: "findInOptions",
        value: function findInOptions(option, options2, path2) {
          var recursive = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          var min2 = 1e9;
          var closestMatch = "";
          var closestMatchPath = [];
          var lowerCaseOption = option.toLowerCase();
          var indexMatch = void 0;
          for (var op in options2) {
            var distance = void 0;
            if (options2[op].__type__ !== void 0 && recursive === true) {
              var result = Validator2.findInOptions(option, options2[op], copyAndExtendArray(path2, op));
              if (min2 > result.distance) {
                closestMatch = result.closestMatch;
                closestMatchPath = result.path;
                min2 = result.distance;
                indexMatch = result.indexMatch;
              }
            } else {
              var _context;
              if (indexOf$3(_context = op.toLowerCase()).call(_context, lowerCaseOption) !== -1) {
                indexMatch = op;
              }
              distance = Validator2.levenshteinDistance(option, op);
              if (min2 > distance) {
                closestMatch = op;
                closestMatchPath = copyArray(path2);
                min2 = distance;
              }
            }
          }
          return {
            closestMatch,
            path: closestMatchPath,
            distance: min2,
            indexMatch
          };
        }
        /**
         * @param {Array.<string>} path
         * @param {Object} option
         * @param {string} prefix
         * @returns {String}
         * @static
         */
      }, {
        key: "printLocation",
        value: function printLocation(path2, option) {
          var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Problem value found at: \n";
          var str = "\n\n" + prefix + "options = {\n";
          for (var i = 0; i < path2.length; i++) {
            for (var j = 0; j < i + 1; j++) {
              str += "  ";
            }
            str += path2[i] + ": {\n";
          }
          for (var _j = 0; _j < path2.length + 1; _j++) {
            str += "  ";
          }
          str += option + "\n";
          for (var _i = 0; _i < path2.length + 1; _i++) {
            for (var _j2 = 0; _j2 < path2.length - _i; _j2++) {
              str += "  ";
            }
            str += "}\n";
          }
          return str + "\n\n";
        }
        /**
         * @param {Object} options
         * @returns {String}
         * @static
         */
      }, {
        key: "print",
        value: function print(options2) {
          return stringify$2(options2).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ", ");
        }
        /**
         *  Compute the edit distance between the two given strings
         * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
         *
         * Copyright (c) 2011 Andrei Mackenzie
         *
         * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
         *
         * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
         *
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
         *
         * @param {string} a
         * @param {string} b
         * @returns {Array.<Array.<number>>}}
         * @static
         */
      }, {
        key: "levenshteinDistance",
        value: function levenshteinDistance(a, b) {
          if (a.length === 0) return b.length;
          if (b.length === 0) return a.length;
          var matrix = [];
          var i;
          for (i = 0; i <= b.length; i++) {
            matrix[i] = [i];
          }
          var j;
          for (j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
          }
          for (i = 1; i <= b.length; i++) {
            for (j = 1; j <= a.length; j++) {
              if (b.charAt(i - 1) == a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
              } else {
                matrix[i][j] = Math.min(
                  matrix[i - 1][j - 1] + 1,
                  // substitution
                  Math.min(
                    matrix[i][j - 1] + 1,
                    // insertion
                    matrix[i - 1][j] + 1
                  )
                );
              }
            }
          }
          return matrix[b.length][a.length];
        }
      }]);
      return Validator2;
    }();
    Node = function() {
      function Node2(options2, body, imagelist, grouplist, globalOptions, defaultOptions) {
        classCallCheck(this, Node2);
        this.options = bridgeObject(globalOptions);
        this.globalOptions = globalOptions;
        this.defaultOptions = defaultOptions;
        this.body = body;
        this.edges = [];
        this.id = void 0;
        this.imagelist = imagelist;
        this.grouplist = grouplist;
        this.x = void 0;
        this.y = void 0;
        this.baseSize = this.options.size;
        this.baseFontSize = this.options.font.size;
        this.predefinedPosition = false;
        this.selected = false;
        this.hover = false;
        this.labelModule = new Label(
          this.body,
          this.options,
          false
          /* Not edge label */
        );
        this.setOptions(options2);
      }
      createClass(Node2, [{
        key: "attachEdge",
        value: function attachEdge(edge) {
          var _context;
          if (indexOf$3(_context = this.edges).call(_context, edge) === -1) {
            this.edges.push(edge);
          }
        }
        /**
         * Detach a edge from the node
         *
         * @param {Edge} edge
         */
      }, {
        key: "detachEdge",
        value: function detachEdge(edge) {
          var _context2;
          var index2 = indexOf$3(_context2 = this.edges).call(_context2, edge);
          if (index2 != -1) {
            var _context3;
            splice$2(_context3 = this.edges).call(_context3, index2, 1);
          }
        }
        /**
         * Set or overwrite options for the node
         *
         * @param {Object} options an object with options
         * @returns {null|boolean}
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          var currentShape = this.options.shape;
          if (!options2) {
            return;
          }
          if (typeof options2.color !== "undefined") {
            this._localColor = options2.color;
          }
          if (options2.id !== void 0) {
            this.id = options2.id;
          }
          if (this.id === void 0) {
            throw new Error("Node must have an id");
          }
          Node2.checkMass(options2, this.id);
          if (options2.x !== void 0) {
            if (options2.x === null) {
              this.x = void 0;
              this.predefinedPosition = false;
            } else {
              this.x = _parseInt$2(options2.x);
              this.predefinedPosition = true;
            }
          }
          if (options2.y !== void 0) {
            if (options2.y === null) {
              this.y = void 0;
              this.predefinedPosition = false;
            } else {
              this.y = _parseInt$2(options2.y);
              this.predefinedPosition = true;
            }
          }
          if (options2.size !== void 0) {
            this.baseSize = options2.size;
          }
          if (options2.value !== void 0) {
            options2.value = _parseFloat$2(options2.value);
          }
          Node2.parseOptions(this.options, options2, true, this.globalOptions, this.grouplist);
          var pile = [options2, this.options, this.defaultOptions];
          this.chooser = choosify("node", pile);
          this._load_images();
          this.updateLabelModule(options2);
          if (options2.opacity !== void 0 && Node2.checkOpacity(options2.opacity)) {
            this.options.opacity = options2.opacity;
          }
          this.updateShape(currentShape);
          return options2.hidden !== void 0 || options2.physics !== void 0;
        }
        /**
         * Load the images from the options, for the nodes that need them.
         *
         * Images are always loaded, even if they are not used in the current shape.
         * The user may switch to an image shape later on.
         *
         * @private
         */
      }, {
        key: "_load_images",
        value: function _load_images() {
          if (this.options.shape === "circularImage" || this.options.shape === "image") {
            if (this.options.image === void 0) {
              throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
            }
          }
          if (this.options.image === void 0) {
            return;
          }
          if (this.imagelist === void 0) {
            throw new Error("Internal Error: No images provided");
          }
          if (typeof this.options.image === "string") {
            this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
          } else {
            if (this.options.image.unselected === void 0) {
              throw new Error("No unselected image provided");
            }
            this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);
            if (this.options.image.selected !== void 0) {
              this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
            } else {
              this.imageObjAlt = void 0;
            }
          }
        }
        /**
         * Check that opacity is only between 0 and 1
         * 
         * @param {Number} opacity 
         * @returns {boolean}
         */
      }, {
        key: "getFormattingValues",
        /**
         *
         * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
         */
        value: function getFormattingValues() {
          var values3 = {
            color: this.options.color.background,
            opacity: this.options.opacity,
            borderWidth: this.options.borderWidth,
            borderColor: this.options.color.border,
            size: this.options.size,
            borderDashes: this.options.shapeProperties.borderDashes,
            borderRadius: this.options.shapeProperties.borderRadius,
            shadow: this.options.shadow.enabled,
            shadowColor: this.options.shadow.color,
            shadowSize: this.options.shadow.size,
            shadowX: this.options.shadow.x,
            shadowY: this.options.shadow.y
          };
          if (this.selected || this.hover) {
            if (this.chooser === true) {
              if (this.selected) {
                values3.borderWidth *= 2;
                values3.color = this.options.color.highlight.background;
                values3.borderColor = this.options.color.highlight.border;
                values3.shadow = this.options.shadow.enabled;
              } else if (this.hover) {
                values3.color = this.options.color.hover.background;
                values3.borderColor = this.options.color.hover.border;
                values3.shadow = this.options.shadow.enabled;
              }
            } else if (typeof this.chooser === "function") {
              this.chooser(values3, this.options.id, this.selected, this.hover);
              if (values3.shadow === false) {
                if (values3.shadowColor !== this.options.shadow.color || values3.shadowSize !== this.options.shadow.size || values3.shadowX !== this.options.shadow.x || values3.shadowY !== this.options.shadow.y) {
                  values3.shadow = true;
                }
              }
            }
          } else {
            values3.shadow = this.options.shadow.enabled;
          }
          if (this.options.opacity !== void 0) {
            var opacity = this.options.opacity;
            values3.borderColor = overrideOpacity(values3.borderColor, opacity);
            values3.color = overrideOpacity(values3.color, opacity);
            values3.shadowColor = overrideOpacity(values3.shadowColor, opacity);
          }
          return values3;
        }
        /**
         *
         * @param {Object} options
         */
      }, {
        key: "updateLabelModule",
        value: function updateLabelModule(options2) {
          if (this.options.label === void 0 || this.options.label === null) {
            this.options.label = "";
          }
          Node2.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options2), {}, {
            color: options2 && options2.color || this._localColor || void 0
          }), this.grouplist);
          var currentGroup = this.grouplist.get(this.options.group, false);
          var pile = [
            options2,
            // new options
            this.options,
            // current node options, see comment above for prototype
            currentGroup,
            // group options, if any
            this.globalOptions,
            // Currently set global node options
            this.defaultOptions
            // Default global node options
          ];
          this.labelModule.update(this.options, pile);
          if (this.labelModule.baseSize !== void 0) {
            this.baseFontSize = this.labelModule.baseSize;
          }
        }
        /**
         *
         * @param {string} currentShape
         */
      }, {
        key: "updateShape",
        value: function updateShape(currentShape) {
          if (currentShape === this.options.shape && this.shape) {
            this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
          } else {
            switch (this.options.shape) {
              case "box":
                this.shape = new Box(this.options, this.body, this.labelModule);
                break;
              case "circle":
                this.shape = new Circle(this.options, this.body, this.labelModule);
                break;
              case "circularImage":
                this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                break;
              case "custom":
                this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);
                break;
              case "database":
                this.shape = new Database(this.options, this.body, this.labelModule);
                break;
              case "diamond":
                this.shape = new Diamond(this.options, this.body, this.labelModule);
                break;
              case "dot":
                this.shape = new Dot(this.options, this.body, this.labelModule);
                break;
              case "ellipse":
                this.shape = new Ellipse(this.options, this.body, this.labelModule);
                break;
              case "icon":
                this.shape = new Icon(this.options, this.body, this.labelModule);
                break;
              case "image":
                this.shape = new Image$1(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                break;
              case "square":
                this.shape = new Square(this.options, this.body, this.labelModule);
                break;
              case "hexagon":
                this.shape = new Hexagon(this.options, this.body, this.labelModule);
                break;
              case "star":
                this.shape = new Star(this.options, this.body, this.labelModule);
                break;
              case "text":
                this.shape = new Text(this.options, this.body, this.labelModule);
                break;
              case "triangle":
                this.shape = new Triangle(this.options, this.body, this.labelModule);
                break;
              case "triangleDown":
                this.shape = new TriangleDown(this.options, this.body, this.labelModule);
                break;
              default:
                this.shape = new Ellipse(this.options, this.body, this.labelModule);
                break;
            }
          }
          this.needsRefresh();
        }
        /**
         * select this node
         */
      }, {
        key: "select",
        value: function select() {
          this.selected = true;
          this.needsRefresh();
        }
        /**
         * unselect this node
         */
      }, {
        key: "unselect",
        value: function unselect() {
          this.selected = false;
          this.needsRefresh();
        }
        /**
         * Reset the calculated size of the node, forces it to recalculate its size
         */
      }, {
        key: "needsRefresh",
        value: function needsRefresh() {
          this.shape.refreshNeeded = true;
        }
        /**
         * get the title of this node.
         * @return {string} title    The title of the node, or undefined when no title
         *                           has been set.
         */
      }, {
        key: "getTitle",
        value: function getTitle() {
          return this.options.title;
        }
        /**
         * Calculate the distance to the border of the Node
         * @param {CanvasRenderingContext2D}   ctx
         * @param {number} angle        Angle in radians
         * @returns {number} distance   Distance to the border in pixels
         */
      }, {
        key: "distanceToBorder",
        value: function distanceToBorder(ctx, angle) {
          return this.shape.distanceToBorder(ctx, angle);
        }
        /**
         * Check if this node has a fixed x and y position
         * @return {boolean}      true if fixed, false if not
         */
      }, {
        key: "isFixed",
        value: function isFixed() {
          return this.options.fixed.x && this.options.fixed.y;
        }
        /**
         * check if this node is selecte
         * @return {boolean} selected   True if node is selected, else false
         */
      }, {
        key: "isSelected",
        value: function isSelected() {
          return this.selected;
        }
        /**
         * Retrieve the value of the node. Can be undefined
         * @return {number} value
         */
      }, {
        key: "getValue",
        value: function getValue() {
          return this.options.value;
        }
        /**
         * Get the current dimensions of the label
         *
         * @return {rect}
         */
      }, {
        key: "getLabelSize",
        value: function getLabelSize() {
          return this.labelModule.size();
        }
        /**
         * Adjust the value range of the node. The node will adjust it's size
         * based on its value.
         * @param {number} min
         * @param {number} max
         * @param {number} total
         */
      }, {
        key: "setValueRange",
        value: function setValueRange(min2, max2, total) {
          if (this.options.value !== void 0) {
            var scale = this.options.scaling.customScalingFunction(min2, max2, total, this.options.value);
            var sizeDiff = this.options.scaling.max - this.options.scaling.min;
            if (this.options.scaling.label.enabled === true) {
              var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
              this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
            }
            this.options.size = this.options.scaling.min + scale * sizeDiff;
          } else {
            this.options.size = this.baseSize;
            this.options.font.size = this.baseFontSize;
          }
          this.updateLabelModule();
        }
        /**
         * Draw this node in the given canvas
         * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
         * @param {CanvasRenderingContext2D}   ctx
         */
      }, {
        key: "draw",
        value: function draw(ctx) {
          var values3 = this.getFormattingValues();
          this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values3);
        }
        /**
         * Update the bounding box of the shape
         * @param {CanvasRenderingContext2D}   ctx
         */
      }, {
        key: "updateBoundingBox",
        value: function updateBoundingBox(ctx) {
          this.shape.updateBoundingBox(this.x, this.y, ctx);
        }
        /**
         * Recalculate the size of this node in the given canvas
         * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
         * @param {CanvasRenderingContext2D}   ctx
         */
      }, {
        key: "resize",
        value: function resize(ctx) {
          var values3 = this.getFormattingValues();
          this.shape.resize(ctx, this.selected, this.hover, values3);
        }
        /**
         * Determine all visual elements of this node instance, in which the given
         * point falls within the bounding shape.
         *
         * @param {point} point
         * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
         */
      }, {
        key: "getItemsOnPoint",
        value: function getItemsOnPoint(point) {
          var ret = [];
          if (this.labelModule.visible()) {
            if (pointInRect(this.labelModule.getSize(), point)) {
              ret.push({
                nodeId: this.id,
                labelId: 0
              });
            }
          }
          if (pointInRect(this.shape.boundingBox, point)) {
            ret.push({
              nodeId: this.id
            });
          }
          return ret;
        }
        /**
         * Check if this object is overlapping with the provided object
         * @param {Object} obj   an object with parameters left, top, right, bottom
         * @return {boolean}     True if location is located on node
         */
      }, {
        key: "isOverlappingWith",
        value: function isOverlappingWith(obj) {
          return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
        }
        /**
         * Check if this object is overlapping with the provided object
         * @param {Object} obj   an object with parameters left, top, right, bottom
         * @return {boolean}     True if location is located on node
         */
      }, {
        key: "isBoundingBoxOverlappingWith",
        value: function isBoundingBoxOverlappingWith(obj) {
          return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
        }
        /**
        * Check valid values for mass
        *
        * The mass may not be negative or zero. If it is, reset to 1
        *
        * @param {object} options
        * @param {Node.id} id
         * @static
        */
      }], [{
        key: "checkOpacity",
        value: function checkOpacity(opacity) {
          return 0 <= opacity && opacity <= 1;
        }
        /**
         * Check that origin is 'center' or 'top-left'
         * 
         * @param {String} origin 
         * @returns {boolean}
         */
      }, {
        key: "checkCoordinateOrigin",
        value: function checkCoordinateOrigin(origin) {
          return origin === void 0 || origin === "center" || origin === "top-left";
        }
        /**
         * Copy group option values into the node options.
         *
         * The group options override the global node options, so the copy of group options
         *  must happen *after* the global node options have been set.
         *
         * This method must also be called also if the global node options have changed and the group options did not.
         *
         * @param {Object} parentOptions
         * @param {Object} newOptions  new values for the options, currently only passed in for check
         * @param {Object} groupList
         */
      }, {
        key: "updateGroupOptions",
        value: function updateGroupOptions(parentOptions, newOptions, groupList) {
          var _context4;
          if (groupList === void 0) return;
          var group = parentOptions.group;
          if (newOptions !== void 0 && newOptions.group !== void 0 && group !== newOptions.group) {
            throw new Error("updateGroupOptions: group values in options don't match.");
          }
          var hasGroup = typeof group === "number" || typeof group === "string" && group != "";
          if (!hasGroup) return;
          var groupObj = groupList.get(group);
          if (groupObj.opacity !== void 0 && newOptions.opacity === void 0) {
            if (!Node2.checkOpacity(groupObj.opacity)) {
              console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + groupObj.opacity);
              groupObj.opacity = void 0;
            }
          }
          var skipProperties = filter$2(_context4 = getOwnPropertyNames$2(newOptions)).call(_context4, function(p) {
            return newOptions[p] != null;
          });
          skipProperties.push("font");
          selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);
          parentOptions.color = parseColor(parentOptions.color);
        }
        /**
         * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
         * Static so it can also be used by the handler.
         *
         * @param {Object} parentOptions
         * @param {Object} newOptions
         * @param {boolean} [allowDeletion=false]
         * @param {Object} [globalOptions={}]
         * @param {Object} [groupList]
         * @static
         */
      }, {
        key: "parseOptions",
        value: function parseOptions(parentOptions, newOptions) {
          var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var groupList = arguments.length > 4 ? arguments[4] : void 0;
          var fields = ["color", "fixed", "shadow"];
          selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);
          Node2.checkMass(newOptions);
          if (parentOptions.opacity !== void 0) {
            if (!Node2.checkOpacity(parentOptions.opacity)) {
              console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + parentOptions.opacity);
              parentOptions.opacity = void 0;
            }
          }
          if (newOptions.opacity !== void 0) {
            if (!Node2.checkOpacity(newOptions.opacity)) {
              console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + newOptions.opacity);
              newOptions.opacity = void 0;
            }
          }
          if (newOptions.shapeProperties && !Node2.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {
            console.error("Invalid option for node coordinateOrigin, found: " + newOptions.shapeProperties.coordinateOrigin);
          }
          mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
          if (newOptions.color !== void 0 && newOptions.color !== null) {
            var parsedColor = parseColor(newOptions.color);
            fillIfDefined(parentOptions.color, parsedColor);
          } else if (allowDeletion === true && newOptions.color === null) {
            parentOptions.color = bridgeObject(globalOptions.color);
          }
          if (newOptions.fixed !== void 0 && newOptions.fixed !== null) {
            if (typeof newOptions.fixed === "boolean") {
              parentOptions.fixed.x = newOptions.fixed;
              parentOptions.fixed.y = newOptions.fixed;
            } else {
              if (newOptions.fixed.x !== void 0 && typeof newOptions.fixed.x === "boolean") {
                parentOptions.fixed.x = newOptions.fixed.x;
              }
              if (newOptions.fixed.y !== void 0 && typeof newOptions.fixed.y === "boolean") {
                parentOptions.fixed.y = newOptions.fixed.y;
              }
            }
          }
          if (allowDeletion === true && newOptions.font === null) {
            parentOptions.font = bridgeObject(globalOptions.font);
          }
          Node2.updateGroupOptions(parentOptions, newOptions, groupList);
          if (newOptions.scaling !== void 0) {
            mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
          }
        }
      }, {
        key: "checkMass",
        value: function checkMass(options2, id2) {
          if (options2.mass !== void 0 && options2.mass <= 0) {
            var strId = "";
            if (id2 !== void 0) {
              strId = " in node id: " + id2;
            }
            console.log("%cNegative or zero mass disallowed" + strId + ", setting mass to 1.", printStyle);
            options2.mass = 1;
          }
        }
      }]);
      return Node2;
    }();
    NodesHandler = function() {
      function NodesHandler2(body, images, groups, layoutEngine) {
        var _context, _this = this;
        classCallCheck(this, NodesHandler2);
        this.body = body;
        this.images = images;
        this.groups = groups;
        this.layoutEngine = layoutEngine;
        this.body.functions.createNode = bind$2(_context = this.create).call(_context, this);
        this.nodesListeners = {
          add: function add(event, params) {
            _this.add(params.items);
          },
          update: function update(event, params) {
            _this.update(params.items, params.data, params.oldData);
          },
          remove: function remove(event, params) {
            _this.remove(params.items);
          }
        };
        this.defaultOptions = {
          borderWidth: 1,
          borderWidthSelected: 2,
          brokenImage: void 0,
          color: {
            border: "#2B7CE9",
            background: "#97C2FC",
            highlight: {
              border: "#2B7CE9",
              background: "#D2E5FF"
            },
            hover: {
              border: "#2B7CE9",
              background: "#D2E5FF"
            }
          },
          opacity: void 0,
          // number between 0 and 1
          fixed: {
            x: false,
            y: false
          },
          font: {
            color: "#343434",
            size: 14,
            // px
            face: "arial",
            background: "none",
            strokeWidth: 0,
            // px
            strokeColor: "#ffffff",
            align: "center",
            vadjust: 0,
            multi: false,
            bold: {
              mod: "bold"
            },
            boldital: {
              mod: "bold italic"
            },
            ital: {
              mod: "italic"
            },
            mono: {
              mod: "",
              size: 15,
              // px
              face: "monospace",
              vadjust: 2
            }
          },
          group: void 0,
          hidden: false,
          icon: {
            face: "FontAwesome",
            //'FontAwesome',
            code: void 0,
            //'\uf007',
            size: 50,
            //50,
            color: "#2B7CE9"
            //'#aa00ff'
          },
          image: void 0,
          // --> URL
          imagePadding: {
            // only for image shape
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          },
          label: void 0,
          labelHighlightBold: true,
          level: void 0,
          margin: {
            top: 5,
            right: 5,
            bottom: 5,
            left: 5
          },
          mass: 1,
          physics: true,
          scaling: {
            min: 10,
            max: 30,
            label: {
              enabled: false,
              min: 14,
              max: 30,
              maxVisible: 30,
              drawThreshold: 5
            },
            customScalingFunction: function customScalingFunction(min2, max2, total, value) {
              if (max2 === min2) {
                return 0.5;
              } else {
                var scale = 1 / (max2 - min2);
                return Math.max(0, (value - min2) * scale);
              }
            }
          },
          shadow: {
            enabled: false,
            color: "rgba(0,0,0,0.5)",
            size: 10,
            x: 5,
            y: 5
          },
          shape: "ellipse",
          shapeProperties: {
            borderDashes: false,
            // only for borders
            borderRadius: 6,
            // only for box shape
            interpolation: true,
            // only for image and circularImage shapes
            useImageSize: false,
            // only for image and circularImage shapes
            useBorderWithImage: false,
            // only for image shape
            coordinateOrigin: "center"
            // only for image and circularImage shapes
          },
          size: 25,
          title: void 0,
          value: void 0,
          x: void 0,
          y: void 0
        };
        if (this.defaultOptions.mass <= 0) {
          throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
        }
        this.options = bridgeObject(this.defaultOptions);
        this.bindEventListeners();
      }
      createClass(NodesHandler2, [{
        key: "bindEventListeners",
        value: function bindEventListeners() {
          var _context2, _context3, _this2 = this;
          this.body.emitter.on("refreshNodes", bind$2(_context2 = this.refresh).call(_context2, this));
          this.body.emitter.on("refresh", bind$2(_context3 = this.refresh).call(_context3, this));
          this.body.emitter.on("destroy", function() {
            forEach$3(_this2.nodesListeners, function(callback, event) {
              if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
            });
            delete _this2.body.functions.createNode;
            delete _this2.nodesListeners.add;
            delete _this2.nodesListeners.update;
            delete _this2.nodesListeners.remove;
            delete _this2.nodesListeners;
          });
        }
        /**
         *
         * @param {Object} options
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            Node.parseOptions(this.options, options2);
            if (options2.opacity !== void 0) {
              if (isNan$2(options2.opacity) || !_isFinite$2(options2.opacity) || options2.opacity < 0 || options2.opacity > 1) {
                console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + options2.opacity);
              } else {
                this.options.opacity = options2.opacity;
              }
            }
            if (options2.shape !== void 0) {
              for (var nodeId in this.body.nodes) {
                if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
                  this.body.nodes[nodeId].updateShape();
                }
              }
            }
            if (typeof options2.font !== "undefined" || typeof options2.widthConstraint !== "undefined" || typeof options2.heightConstraint !== "undefined") {
              for (var _i = 0, _Object$keys = keys$3(this.body.nodes); _i < _Object$keys.length; _i++) {
                var _nodeId = _Object$keys[_i];
                this.body.nodes[_nodeId].updateLabelModule();
                this.body.nodes[_nodeId].needsRefresh();
              }
            }
            if (options2.size !== void 0) {
              for (var _nodeId2 in this.body.nodes) {
                if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
                  this.body.nodes[_nodeId2].needsRefresh();
                }
              }
            }
            if (options2.hidden !== void 0 || options2.physics !== void 0) {
              this.body.emitter.emit("_dataChanged");
            }
          }
        }
        /**
         * Set a data set with nodes for the network
         * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
         * @param {boolean} [doNotEmit=false]
         * @private
         */
      }, {
        key: "setData",
        value: function setData(nodes) {
          var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var oldNodesData = this.body.data.nodes;
          if (nodes instanceof DataSet || nodes instanceof DataView) {
            this.body.data.nodes = nodes;
          } else if (isArray$5(nodes)) {
            this.body.data.nodes = new DataSet();
            this.body.data.nodes.add(nodes);
          } else if (!nodes) {
            this.body.data.nodes = new DataSet();
          } else {
            throw new TypeError("Array or DataSet expected");
          }
          if (oldNodesData) {
            forEach$3(this.nodesListeners, function(callback, event) {
              oldNodesData.off(event, callback);
            });
          }
          this.body.nodes = {};
          if (this.body.data.nodes) {
            var me = this;
            forEach$3(this.nodesListeners, function(callback, event) {
              me.body.data.nodes.on(event, callback);
            });
            var ids = this.body.data.nodes.getIds();
            this.add(ids, true);
          }
          if (doNotEmit === false) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         * Add nodes
         * @param {number[] | string[]} ids
         * @param {boolean} [doNotEmit=false]
         * @private
         */
      }, {
        key: "add",
        value: function add(ids) {
          var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var id2;
          var newNodes = [];
          for (var i = 0; i < ids.length; i++) {
            id2 = ids[i];
            var properties = this.body.data.nodes.get(id2);
            var node = this.create(properties);
            newNodes.push(node);
            this.body.nodes[id2] = node;
          }
          this.layoutEngine.positionInitially(newNodes);
          if (doNotEmit === false) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         * Update existing nodes, or create them when not yet existing
         * @param {number[] | string[]} ids id's of changed nodes
         * @param {Array} changedData array with changed data
         * @param {Array|undefined} oldData optional; array with previous data
         * @private
         */
      }, {
        key: "update",
        value: function update(ids, changedData, oldData) {
          var nodes = this.body.nodes;
          var dataChanged = false;
          for (var i = 0; i < ids.length; i++) {
            var id2 = ids[i];
            var node = nodes[id2];
            var data2 = changedData[i];
            if (node !== void 0) {
              if (node.setOptions(data2)) {
                dataChanged = true;
              }
            } else {
              dataChanged = true;
              node = this.create(data2);
              nodes[id2] = node;
            }
          }
          if (!dataChanged && oldData !== void 0) {
            dataChanged = some$2(changedData).call(changedData, function(newValue, index2) {
              var oldValue = oldData[index2];
              return oldValue && oldValue.level !== newValue.level;
            });
          }
          if (dataChanged === true) {
            this.body.emitter.emit("_dataChanged");
          } else {
            this.body.emitter.emit("_dataUpdated");
          }
        }
        /**
         * Remove existing nodes. If nodes do not exist, the method will just ignore it.
         * @param {number[] | string[]} ids
         * @private
         */
      }, {
        key: "remove",
        value: function remove(ids) {
          var nodes = this.body.nodes;
          for (var i = 0; i < ids.length; i++) {
            var id2 = ids[i];
            delete nodes[id2];
          }
          this.body.emitter.emit("_dataChanged");
        }
        /**
         * create a node
         * @param {Object} properties
         * @param {class} [constructorClass=Node.default]
         * @returns {*}
         */
      }, {
        key: "create",
        value: function create5(properties) {
          var constructorClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Node;
          return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
        }
        /**
         *
         * @param {boolean} [clearPositions=false]
         */
      }, {
        key: "refresh",
        value: function refresh() {
          var _this3 = this;
          var clearPositions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          forEach$3(this.body.nodes, function(node, nodeId) {
            var data2 = _this3.body.data.nodes.get(nodeId);
            if (data2 !== void 0) {
              if (clearPositions === true) {
                node.setOptions({
                  x: null,
                  y: null
                });
              }
              node.setOptions({
                fixed: false
              });
              node.setOptions(data2);
            }
          });
        }
        /**
         * Returns the positions of the nodes.
         * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string
         * @returns {{}}
         */
      }, {
        key: "getPositions",
        value: function getPositions(ids) {
          var dataArray = {};
          if (ids !== void 0) {
            if (isArray$5(ids) === true) {
              for (var i = 0; i < ids.length; i++) {
                if (this.body.nodes[ids[i]] !== void 0) {
                  var node = this.body.nodes[ids[i]];
                  dataArray[ids[i]] = {
                    x: Math.round(node.x),
                    y: Math.round(node.y)
                  };
                }
              }
            } else {
              if (this.body.nodes[ids] !== void 0) {
                var _node = this.body.nodes[ids];
                dataArray[ids] = {
                  x: Math.round(_node.x),
                  y: Math.round(_node.y)
                };
              }
            }
          } else {
            for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {
              var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];
              dataArray[this.body.nodeIndices[_i2]] = {
                x: Math.round(_node2.x),
                y: Math.round(_node2.y)
              };
            }
          }
          return dataArray;
        }
        /**
         * Retrieves the x y position of a specific id.
         *
         * @param {string} id The id to retrieve.
         *
         * @throws {TypeError} If no id is included.
         * @throws {ReferenceError} If an invalid id is provided.
         *
         * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.
         */
      }, {
        key: "getPosition",
        value: function getPosition(id2) {
          if (id2 == void 0) {
            throw new TypeError("No id was specified for getPosition method.");
          } else if (this.body.nodes[id2] == void 0) {
            throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(id2));
          } else {
            return {
              x: Math.round(this.body.nodes[id2].x),
              y: Math.round(this.body.nodes[id2].y)
            };
          }
        }
        /**
         * Load the XY positions of the nodes into the dataset.
         */
      }, {
        key: "storePositions",
        value: function storePositions() {
          var dataArray = [];
          var dataset = this.body.data.nodes.getDataSet();
          var _iterator = _createForOfIteratorHelper$2(dataset.get()), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var dsNode = _step.value;
              var id2 = dsNode.id;
              var bodyNode = this.body.nodes[id2];
              var x = Math.round(bodyNode.x);
              var y = Math.round(bodyNode.y);
              if (dsNode.x !== x || dsNode.y !== y) {
                dataArray.push({
                  id: id2,
                  x,
                  y
                });
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          dataset.update(dataArray);
        }
        /**
         * get the bounding box of a node.
         * @param {Node.id} nodeId
         * @returns {j|*}
         */
      }, {
        key: "getBoundingBox",
        value: function getBoundingBox(nodeId) {
          if (this.body.nodes[nodeId] !== void 0) {
            return this.body.nodes[nodeId].shape.boundingBox;
          }
        }
        /**
         * Get the Ids of nodes connected to this node.
         * @param {Node.id} nodeId
         * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
         *                                          Any other value returns both parent and child nodes.
         * @returns {Array}
         */
      }, {
        key: "getConnectedNodes",
        value: function getConnectedNodes(nodeId, direction) {
          var nodeList = [];
          if (this.body.nodes[nodeId] !== void 0) {
            var node = this.body.nodes[nodeId];
            var nodeObj = {};
            for (var i = 0; i < node.edges.length; i++) {
              var edge = node.edges[i];
              if (direction !== "to" && edge.toId == node.id) {
                if (nodeObj[edge.fromId] === void 0) {
                  nodeList.push(edge.fromId);
                  nodeObj[edge.fromId] = true;
                }
              } else if (direction !== "from" && edge.fromId == node.id) {
                if (nodeObj[edge.toId] === void 0) {
                  nodeList.push(edge.toId);
                  nodeObj[edge.toId] = true;
                }
              }
            }
          }
          return nodeList;
        }
        /**
         * Get the ids of the edges connected to this node.
         * @param {Node.id} nodeId
         * @returns {*}
         */
      }, {
        key: "getConnectedEdges",
        value: function getConnectedEdges(nodeId) {
          var edgeList = [];
          if (this.body.nodes[nodeId] !== void 0) {
            var node = this.body.nodes[nodeId];
            for (var i = 0; i < node.edges.length; i++) {
              edgeList.push(node.edges[i].id);
            }
          } else {
            console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
          }
          return edgeList;
        }
        /**
         * Move a node.
         *
         * @param {Node.id} nodeId
         * @param {number} x
         * @param {number} y
         */
      }, {
        key: "moveNode",
        value: function moveNode(nodeId, x, y) {
          var _this4 = this;
          if (this.body.nodes[nodeId] !== void 0) {
            this.body.nodes[nodeId].x = Number(x);
            this.body.nodes[nodeId].y = Number(y);
            setTimeout$2(function() {
              _this4.body.emitter.emit("startSimulation");
            }, 0);
          } else {
            console.log("Node id supplied to moveNode does not exist. Provided: ", nodeId);
          }
        }
      }]);
      return NodesHandler2;
    }();
    getOwnPropertyDescriptor$4 = getOwnPropertyDescriptor_1;
    getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$4;
    _export({
      target: "Reflect",
      stat: true
    }, {
      get: get$1
    });
    get$2 = path.Reflect.get;
    get$3 = get$2;
    get$4 = get$3;
    superPropBase = _superPropBase;
    get$5 = createCommonjsModule(function(module) {
      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && get$4) {
          module.exports = _get = get$4;
        } else {
          module.exports = _get = function _get2(target2, property2, receiver2) {
            var base = superPropBase(target2, property2);
            if (!base) return;
            var desc = getOwnPropertyDescriptor$5(base, property2);
            if (desc.get) {
              return desc.get.call(receiver2);
            }
            return desc.value;
          };
        }
        return _get(target, property, receiver || target);
      }
      module.exports = _get;
    });
    $hypot = Math.hypot;
    abs$1 = Math.abs;
    sqrt = Math.sqrt;
    BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
    _export({
      target: "Math",
      stat: true,
      forced: BUGGY
    }, {
      hypot: function hypot(value1, value2) {
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;
        while (i < aLen) {
          arg = abs$1(arguments[i++]);
          if (larg < arg) {
            div = larg / arg;
            sum = sum * div * div + 1;
            larg = arg;
          } else if (arg > 0) {
            div = arg / larg;
            sum += div * div;
          } else sum += arg;
        }
        return larg === Infinity ? Infinity : larg * sqrt(sum);
      }
    });
    hypot2 = path.Math.hypot;
    hypot$1 = hypot2;
    hypot$2 = hypot$1;
    EndPoint = function() {
      function EndPoint2() {
        classCallCheck(this, EndPoint2);
      }
      createClass(EndPoint2, null, [{
        key: "transform",
        /**
         * Apply transformation on points for display.
         *
         * The following is done:
         * - rotate by the specified angle
         * - multiply the (normalized) coordinates by the passed length
         * - offset by the target coordinates
         *
         * @param points - The point(s) to be transformed.
         * @param arrowData - The data determining the result of the transformation.
         */
        value: function transform(points, arrowData) {
          if (!isArray$5(points)) {
            points = [points];
          }
          var x = arrowData.point.x;
          var y = arrowData.point.y;
          var angle = arrowData.angle;
          var length2 = arrowData.length;
          for (var i = 0; i < points.length; ++i) {
            var p = points[i];
            var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);
            var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);
            p.x = x + length2 * xt;
            p.y = y + length2 * yt;
          }
        }
        /**
         * Draw a closed path using the given real coordinates.
         *
         * @param ctx - The path will be rendered into this context.
         * @param points - The points of the path.
         */
      }, {
        key: "drawPath",
        value: function drawPath(ctx, points) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (var i = 1; i < points.length; ++i) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.closePath();
        }
      }]);
      return EndPoint2;
    }();
    Image$2 = function(_EndPoint) {
      inherits(Image2, _EndPoint);
      var _super = _createSuper$j(Image2);
      function Image2() {
        classCallCheck(this, Image2);
        return _super.apply(this, arguments);
      }
      createClass(Image2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns False as there is no way to fill an image.
         */
        value: function draw(ctx, arrowData) {
          if (arrowData.image) {
            ctx.save();
            ctx.translate(arrowData.point.x, arrowData.point.y);
            ctx.rotate(Math.PI / 2 + arrowData.angle);
            var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;
            var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;
            arrowData.image.drawImageAtPosition(
              ctx,
              1,
              // scale
              -width / 2,
              // x
              0,
              // y
              width,
              height
            );
            ctx.restore();
          }
          return false;
        }
      }]);
      return Image2;
    }(EndPoint);
    Arrow = function(_EndPoint2) {
      inherits(Arrow2, _EndPoint2);
      var _super2 = _createSuper$j(Arrow2);
      function Arrow2() {
        classCallCheck(this, Arrow2);
        return _super2.apply(this, arguments);
      }
      createClass(Arrow2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: 0,
            y: 0
          }, {
            x: -1,
            y: 0.3
          }, {
            x: -0.9,
            y: 0
          }, {
            x: -1,
            y: -0.3
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return Arrow2;
    }(EndPoint);
    Crow = function() {
      function Crow2() {
        classCallCheck(this, Crow2);
      }
      createClass(Crow2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: -1,
            y: 0
          }, {
            x: 0,
            y: 0.3
          }, {
            x: -0.4,
            y: 0
          }, {
            x: 0,
            y: -0.3
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return Crow2;
    }();
    Curve = function() {
      function Curve2() {
        classCallCheck(this, Curve2);
      }
      createClass(Curve2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var point = {
            x: -0.4,
            y: 0
          };
          EndPoint.transform(point, arrowData);
          ctx.strokeStyle = ctx.fillStyle;
          ctx.fillStyle = "rgba(0, 0, 0, 0)";
          var pi = Math.PI;
          var startAngle = arrowData.angle - pi / 2;
          var endAngle = arrowData.angle + pi / 2;
          ctx.beginPath();
          ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
          ctx.stroke();
          return true;
        }
      }]);
      return Curve2;
    }();
    InvertedCurve = function() {
      function InvertedCurve2() {
        classCallCheck(this, InvertedCurve2);
      }
      createClass(InvertedCurve2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var point = {
            x: -0.3,
            y: 0
          };
          EndPoint.transform(point, arrowData);
          ctx.strokeStyle = ctx.fillStyle;
          ctx.fillStyle = "rgba(0, 0, 0, 0)";
          var pi = Math.PI;
          var startAngle = arrowData.angle + pi / 2;
          var endAngle = arrowData.angle + 3 * pi / 2;
          ctx.beginPath();
          ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
          ctx.stroke();
          return true;
        }
      }]);
      return InvertedCurve2;
    }();
    Triangle$1 = function() {
      function Triangle2() {
        classCallCheck(this, Triangle2);
      }
      createClass(Triangle2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: 0.02,
            y: 0
          }, {
            x: -1,
            y: 0.3
          }, {
            x: -1,
            y: -0.3
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return Triangle2;
    }();
    InvertedTriangle = function() {
      function InvertedTriangle2() {
        classCallCheck(this, InvertedTriangle2);
      }
      createClass(InvertedTriangle2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: 0,
            y: 0.3
          }, {
            x: 0,
            y: -0.3
          }, {
            x: -1,
            y: 0
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return InvertedTriangle2;
    }();
    Circle$1 = function() {
      function Circle2() {
        classCallCheck(this, Circle2);
      }
      createClass(Circle2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var point = {
            x: -0.4,
            y: 0
          };
          EndPoint.transform(point, arrowData);
          drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);
          return true;
        }
      }]);
      return Circle2;
    }();
    Bar = function() {
      function Bar2() {
        classCallCheck(this, Bar2);
      }
      createClass(Bar2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: 0,
            y: 0.5
          }, {
            x: 0,
            y: -0.5
          }, {
            x: -0.15,
            y: -0.5
          }, {
            x: -0.15,
            y: 0.5
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return Bar2;
    }();
    Box$1 = function() {
      function Box2() {
        classCallCheck(this, Box2);
      }
      createClass(Box2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: 0,
            y: 0.3
          }, {
            x: 0,
            y: -0.3
          }, {
            x: -0.6,
            y: -0.3
          }, {
            x: -0.6,
            y: 0.3
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return Box2;
    }();
    Diamond$1 = function() {
      function Diamond2() {
        classCallCheck(this, Diamond2);
      }
      createClass(Diamond2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: 0,
            y: 0
          }, {
            x: -0.5,
            y: -0.3
          }, {
            x: -1,
            y: 0
          }, {
            x: -0.5,
            y: 0.3
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return Diamond2;
    }();
    Vee = function() {
      function Vee2() {
        classCallCheck(this, Vee2);
      }
      createClass(Vee2, null, [{
        key: "draw",
        /**
         * Draw this shape at the end of a line.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True because ctx.fill() can be used to fill the arrow.
         */
        value: function draw(ctx, arrowData) {
          var points = [{
            x: -1,
            y: 0.3
          }, {
            x: -0.5,
            y: 0
          }, {
            x: -1,
            y: -0.3
          }, {
            x: 0,
            y: 0
          }];
          EndPoint.transform(points, arrowData);
          EndPoint.drawPath(ctx, points);
          return true;
        }
      }]);
      return Vee2;
    }();
    EndPoints = function() {
      function EndPoints2() {
        classCallCheck(this, EndPoints2);
      }
      createClass(EndPoints2, null, [{
        key: "draw",
        /**
         * Draw an endpoint.
         *
         * @param ctx - The shape will be rendered into this context.
         * @param arrowData - The data determining the shape.
         *
         * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.
         */
        value: function draw(ctx, arrowData) {
          var type;
          if (arrowData.type) {
            type = arrowData.type.toLowerCase();
          }
          switch (type) {
            case "image":
              return Image$2.draw(ctx, arrowData);
            case "circle":
              return Circle$1.draw(ctx, arrowData);
            case "box":
              return Box$1.draw(ctx, arrowData);
            case "crow":
              return Crow.draw(ctx, arrowData);
            case "curve":
              return Curve.draw(ctx, arrowData);
            case "diamond":
              return Diamond$1.draw(ctx, arrowData);
            case "inv_curve":
              return InvertedCurve.draw(ctx, arrowData);
            case "triangle":
              return Triangle$1.draw(ctx, arrowData);
            case "inv_triangle":
              return InvertedTriangle.draw(ctx, arrowData);
            case "bar":
              return Bar.draw(ctx, arrowData);
            case "vee":
              return Vee.draw(ctx, arrowData);
            case "arrow":
            // fall-through
            default:
              return Arrow.draw(ctx, arrowData);
          }
        }
      }]);
      return EndPoints2;
    }();
    EdgeBase = function() {
      function EdgeBase2(options2, _body, _labelModule) {
        classCallCheck(this, EdgeBase2);
        this._body = _body;
        this._labelModule = _labelModule;
        this.color = {};
        this.colorDirty = true;
        this.hoverWidth = 1.5;
        this.selectionWidth = 2;
        this.setOptions(options2);
        this.fromPoint = this.from;
        this.toPoint = this.to;
      }
      createClass(EdgeBase2, [{
        key: "connect",
        value: function connect() {
          this.from = this._body.nodes[this.options.from];
          this.to = this._body.nodes[this.options.to];
        }
        /** @inheritdoc */
      }, {
        key: "cleanup",
        value: function cleanup() {
          return false;
        }
        /**
         * Set new edge options.
         *
         * @param options - The new edge options object.
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
          this.from = this._body.nodes[this.options.from];
          this.to = this._body.nodes[this.options.to];
          this.id = this.options.id;
        }
        /** @inheritdoc */
      }, {
        key: "drawLine",
        value: function drawLine(ctx, values3, _selected, _hover) {
          var viaNode = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.getViaNode();
          ctx.strokeStyle = this.getColor(ctx, values3);
          ctx.lineWidth = values3.width;
          if (values3.dashes !== false) {
            this._drawDashedLine(ctx, values3, viaNode);
          } else {
            this._drawLine(ctx, values3, viaNode);
          }
        }
        /**
         * Draw a line with given style between two nodes through supplied node(s).
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Formatting values like color, opacity or shadow.
         * @param viaNode - Additional control point(s) for the edge.
         * @param fromPoint - TODO: Seems ignored, remove?
         * @param toPoint - TODO: Seems ignored, remove?
         */
      }, {
        key: "_drawLine",
        value: function _drawLine(ctx, values3, viaNode, fromPoint, toPoint) {
          if (this.from != this.to) {
            this._line(ctx, values3, viaNode, fromPoint, toPoint);
          } else {
            var _this$_getCircleData = this._getCircleData(ctx), _this$_getCircleData2 = slicedToArray(_this$_getCircleData, 3), x = _this$_getCircleData2[0], y = _this$_getCircleData2[1], radius = _this$_getCircleData2[2];
            this._circle(ctx, values3, x, y, radius);
          }
        }
        /**
         * Draw a dashed line with given style between two nodes through supplied node(s).
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Formatting values like color, opacity or shadow.
         * @param viaNode - Additional control point(s) for the edge.
         * @param _fromPoint - Ignored (TODO: remove in the future).
         * @param _toPoint - Ignored (TODO: remove in the future).
         */
      }, {
        key: "_drawDashedLine",
        value: function _drawDashedLine(ctx, values3, viaNode, _fromPoint, _toPoint) {
          ctx.lineCap = "round";
          var pattern = isArray$5(values3.dashes) ? values3.dashes : [5, 5];
          if (ctx.setLineDash !== void 0) {
            ctx.save();
            ctx.setLineDash(pattern);
            ctx.lineDashOffset = 0;
            if (this.from != this.to) {
              this._line(ctx, values3, viaNode);
            } else {
              var _this$_getCircleData3 = this._getCircleData(ctx), _this$_getCircleData4 = slicedToArray(_this$_getCircleData3, 3), x = _this$_getCircleData4[0], y = _this$_getCircleData4[1], radius = _this$_getCircleData4[2];
              this._circle(ctx, values3, x, y, radius);
            }
            ctx.setLineDash([0]);
            ctx.lineDashOffset = 0;
            ctx.restore();
          } else {
            if (this.from != this.to) {
              drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);
            } else {
              var _this$_getCircleData5 = this._getCircleData(ctx), _this$_getCircleData6 = slicedToArray(_this$_getCircleData5, 3), _x = _this$_getCircleData6[0], _y = _this$_getCircleData6[1], _radius = _this$_getCircleData6[2];
              this._circle(ctx, values3, _x, _y, _radius);
            }
            this.enableShadow(ctx, values3);
            ctx.stroke();
            this.disableShadow(ctx, values3);
          }
        }
        /**
         * Find the intersection between the border of the node and the edge.
         *
         * @param node - The node (either from or to node of the edge).
         * @param ctx - The context that will be used for rendering.
         * @param options - Additional options.
         *
         * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
         */
      }, {
        key: "findBorderPosition",
        value: function findBorderPosition(node, ctx, options2) {
          if (this.from != this.to) {
            return this._findBorderPosition(node, ctx, options2);
          } else {
            return this._findBorderPositionCircle(node, ctx, options2);
          }
        }
        /** @inheritdoc */
      }, {
        key: "findBorderPositions",
        value: function findBorderPositions(ctx) {
          if (this.from != this.to) {
            return {
              from: this._findBorderPosition(this.from, ctx),
              to: this._findBorderPosition(this.to, ctx)
            };
          } else {
            var _context;
            var _this$_getCircleData$ = slice$5(_context = this._getCircleData(ctx)).call(_context, 0, 2), _this$_getCircleData$2 = slicedToArray(_this$_getCircleData$, 2), x = _this$_getCircleData$2[0], y = _this$_getCircleData$2[1];
            return {
              from: this._findBorderPositionCircle(this.from, ctx, {
                x,
                y,
                low: 0.25,
                high: 0.6,
                direction: -1
              }),
              to: this._findBorderPositionCircle(this.from, ctx, {
                x,
                y,
                low: 0.6,
                high: 0.8,
                direction: 1
              })
            };
          }
        }
        /**
         * Compute the center point and radius of an edge connected to the same node at both ends.
         *
         * @param ctx - The context that will be used for rendering.
         *
         * @returns `[x, y, radius]`
         */
      }, {
        key: "_getCircleData",
        value: function _getCircleData(ctx) {
          var radius = this.options.selfReference.size;
          if (ctx !== void 0) {
            if (this.from.shape.width === void 0) {
              this.from.shape.resize(ctx);
            }
          }
          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);
          return [coordinates.x, coordinates.y, radius];
        }
        /**
         * Get a point on a circle.
         *
         * @param x - Center of the circle on the x axis.
         * @param y - Center of the circle on the y axis.
         * @param radius - Radius of the circle.
         * @param position - Value between 0 (line start) and 1 (line end).
         *
         * @returns Cartesian coordinates of requested point on the circle.
         */
      }, {
        key: "_pointOnCircle",
        value: function _pointOnCircle(x, y, radius, position) {
          var angle = position * 2 * Math.PI;
          return {
            x: x + radius * Math.cos(angle),
            y: y - radius * Math.sin(angle)
          };
        }
        /**
         * Find the intersection between the border of the node and the edge.
         *
         * @remarks
         * This function uses binary search to look for the point where the circle crosses the border of the node.
         *
         * @param nearNode - The node (either from or to node of the edge).
         * @param ctx - The context that will be used for rendering.
         * @param options - Additional options.
         *
         * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
         */
      }, {
        key: "_findBorderPositionCircle",
        value: function _findBorderPositionCircle(nearNode, ctx, options2) {
          var x = options2.x;
          var y = options2.y;
          var low2 = options2.low;
          var high = options2.high;
          var direction = options2.direction;
          var maxIterations = 10;
          var radius = this.options.selfReference.size;
          var threshold = 0.05;
          var pos;
          var middle = (low2 + high) * 0.5;
          var endPointOffset = 0;
          if (this.options.arrowStrikethrough === true) {
            if (direction === -1) {
              endPointOffset = this.options.endPointOffset.from;
            } else if (direction === 1) {
              endPointOffset = this.options.endPointOffset.to;
            }
          }
          var iteration = 0;
          do {
            middle = (low2 + high) * 0.5;
            pos = this._pointOnCircle(x, y, radius, middle);
            var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);
            var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;
            var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));
            var difference = distanceToBorder - distanceToPoint;
            if (Math.abs(difference) < threshold) {
              break;
            } else if (difference > 0) {
              if (direction > 0) {
                low2 = middle;
              } else {
                high = middle;
              }
            } else {
              if (direction > 0) {
                high = middle;
              } else {
                low2 = middle;
              }
            }
            ++iteration;
          } while (low2 <= high && iteration < maxIterations);
          return _objectSpread$3(_objectSpread$3({}, pos), {}, {
            t: middle
          });
        }
        /**
         * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.
         *
         * @param selected - Determines wheter the line is selected.
         * @param hover - Determines wheter the line is being hovered, only applies if selected is false.
         *
         * @returns The width of the line.
         */
      }, {
        key: "getLineWidth",
        value: function getLineWidth(selected, hover) {
          if (selected === true) {
            return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);
          } else if (hover === true) {
            return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);
          } else {
            return Math.max(this.options.width, 0.3 / this._body.view.scale);
          }
        }
        /**
         * Compute the color or gradient for given edge.
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Formatting values like color, opacity or shadow.
         * @param _selected - Ignored (TODO: remove in the future).
         * @param _hover - Ignored (TODO: remove in the future).
         *
         * @returns Color string if single color is inherited or gradient if two.
         */
      }, {
        key: "getColor",
        value: function getColor(ctx, values3) {
          if (values3.inheritsColor !== false) {
            if (values3.inheritsColor === "both" && this.from.id !== this.to.id) {
              var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
              var fromColor = this.from.options.color.highlight.border;
              var toColor = this.to.options.color.highlight.border;
              if (this.from.selected === false && this.to.selected === false) {
                fromColor = overrideOpacity(this.from.options.color.border, values3.opacity);
                toColor = overrideOpacity(this.to.options.color.border, values3.opacity);
              } else if (this.from.selected === true && this.to.selected === false) {
                toColor = this.to.options.color.border;
              } else if (this.from.selected === false && this.to.selected === true) {
                fromColor = this.from.options.color.border;
              }
              grd.addColorStop(0, fromColor);
              grd.addColorStop(1, toColor);
              return grd;
            }
            if (values3.inheritsColor === "to") {
              return overrideOpacity(this.to.options.color.border, values3.opacity);
            } else {
              return overrideOpacity(this.from.options.color.border, values3.opacity);
            }
          } else {
            return overrideOpacity(values3.color, values3.opacity);
          }
        }
        /**
         * Draw a line from a node to itself, a circle.
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Formatting values like color, opacity or shadow.
         * @param x - Center of the circle on the x axis.
         * @param y - Center of the circle on the y axis.
         * @param radius - Radius of the circle.
         */
      }, {
        key: "_circle",
        value: function _circle(ctx, values3, x, y, radius) {
          this.enableShadow(ctx, values3);
          var angleFrom = 0;
          var angleTo = Math.PI * 2;
          if (!this.options.selfReference.renderBehindTheNode) {
            var low2 = this.options.selfReference.angle;
            var high = this.options.selfReference.angle + Math.PI;
            var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {
              x,
              y,
              low: low2,
              high,
              direction: -1
            });
            var pointTTo = this._findBorderPositionCircle(this.from, ctx, {
              x,
              y,
              low: low2,
              high,
              direction: 1
            });
            angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);
            angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);
          }
          ctx.beginPath();
          ctx.arc(x, y, radius, angleFrom, angleTo, false);
          ctx.stroke();
          this.disableShadow(ctx, values3);
        }
        /**
         * @inheritdoc
         *
         * @remarks
         * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
         */
      }, {
        key: "getDistanceToEdge",
        value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
          if (this.from != this.to) {
            return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);
          } else {
            var _this$_getCircleData7 = this._getCircleData(void 0), _this$_getCircleData8 = slicedToArray(_this$_getCircleData7, 3), x = _this$_getCircleData8[0], y = _this$_getCircleData8[1], radius = _this$_getCircleData8[2];
            var dx = x - x3;
            var dy = y - y3;
            return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
          }
        }
        /**
         * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).
         *
         * @param x1 - First end of the line segment on the x axis.
         * @param y1 - First end of the line segment on the y axis.
         * @param x2 - Second end of the line segment on the x axis.
         * @param y2 - Second end of the line segment on the y axis.
         * @param x3 - Position of the point on the x axis.
         * @param y3 - Position of the point on the y axis.
         *
         * @returns The distance between the line segment and the point.
         */
      }, {
        key: "_getDistanceToLine",
        value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
          var px = x2 - x1;
          var py = y2 - y1;
          var something = px * px + py * py;
          var u = ((x3 - x1) * px + (y3 - y1) * py) / something;
          if (u > 1) {
            u = 1;
          } else if (u < 0) {
            u = 0;
          }
          var x = x1 + u * px;
          var y = y1 + u * py;
          var dx = x - x3;
          var dy = y - y3;
          return Math.sqrt(dx * dx + dy * dy);
        }
        /** @inheritdoc */
      }, {
        key: "getArrowData",
        value: function getArrowData(ctx, position, viaNode, _selected, _hover, values3) {
          var angle;
          var arrowPoint;
          var node1;
          var node2;
          var reversed;
          var scaleFactor;
          var type;
          var lineWidth = values3.width;
          if (position === "from") {
            node1 = this.from;
            node2 = this.to;
            reversed = values3.fromArrowScale < 0;
            scaleFactor = Math.abs(values3.fromArrowScale);
            type = values3.fromArrowType;
          } else if (position === "to") {
            node1 = this.to;
            node2 = this.from;
            reversed = values3.toArrowScale < 0;
            scaleFactor = Math.abs(values3.toArrowScale);
            type = values3.toArrowType;
          } else {
            node1 = this.to;
            node2 = this.from;
            reversed = values3.middleArrowScale < 0;
            scaleFactor = Math.abs(values3.middleArrowScale);
            type = values3.middleArrowType;
          }
          var length2 = 15 * scaleFactor + 3 * lineWidth;
          if (node1 != node2) {
            var approximateEdgeLength = hypot$2(node1.x - node2.x, node1.y - node2.y);
            var relativeLength = length2 / approximateEdgeLength;
            if (position !== "middle") {
              if (this.options.smooth.enabled === true) {
                var pointT = this._findBorderPosition(node1, ctx, {
                  via: viaNode
                });
                var guidePos = this.getPoint(pointT.t + relativeLength * (position === "from" ? 1 : -1), viaNode);
                angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);
                arrowPoint = pointT;
              } else {
                angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
                arrowPoint = this._findBorderPosition(node1, ctx);
              }
            } else {
              var halfLength = (reversed ? -relativeLength : relativeLength) / 2;
              var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);
              var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);
              angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);
              arrowPoint = this.getPoint(0.5, viaNode);
            }
          } else {
            var _this$_getCircleData9 = this._getCircleData(ctx), _this$_getCircleData10 = slicedToArray(_this$_getCircleData9, 3), x = _this$_getCircleData10[0], y = _this$_getCircleData10[1], radius = _this$_getCircleData10[2];
            if (position === "from") {
              var low2 = this.options.selfReference.angle;
              var high = this.options.selfReference.angle + Math.PI;
              var _pointT = this._findBorderPositionCircle(this.from, ctx, {
                x,
                y,
                low: low2,
                high,
                direction: -1
              });
              angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
              arrowPoint = _pointT;
            } else if (position === "to") {
              var _low = this.options.selfReference.angle;
              var _high = this.options.selfReference.angle + Math.PI;
              var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {
                x,
                y,
                low: _low,
                high: _high,
                direction: 1
              });
              angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
              arrowPoint = _pointT2;
            } else {
              var pos = this.options.selfReference.angle / (2 * Math.PI);
              arrowPoint = this._pointOnCircle(x, y, radius, pos);
              angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
            }
          }
          var xi = arrowPoint.x - length2 * 0.9 * Math.cos(angle);
          var yi = arrowPoint.y - length2 * 0.9 * Math.sin(angle);
          var arrowCore = {
            x: xi,
            y: yi
          };
          return {
            point: arrowPoint,
            core: arrowCore,
            angle,
            length: length2,
            type
          };
        }
        /** @inheritdoc */
      }, {
        key: "drawArrowHead",
        value: function drawArrowHead(ctx, values3, _selected, _hover, arrowData) {
          ctx.strokeStyle = this.getColor(ctx, values3);
          ctx.fillStyle = ctx.strokeStyle;
          ctx.lineWidth = values3.width;
          var canFill = EndPoints.draw(ctx, arrowData);
          if (canFill) {
            this.enableShadow(ctx, values3);
            fill$2(ctx).call(ctx);
            this.disableShadow(ctx, values3);
          }
        }
        /**
         * Set the shadow formatting values in the context if enabled, do nothing otherwise.
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Formatting values for the shadow.
         */
      }, {
        key: "enableShadow",
        value: function enableShadow(ctx, values3) {
          if (values3.shadow === true) {
            ctx.shadowColor = values3.shadowColor;
            ctx.shadowBlur = values3.shadowSize;
            ctx.shadowOffsetX = values3.shadowX;
            ctx.shadowOffsetY = values3.shadowY;
          }
        }
        /**
         * Reset the shadow formatting values in the context if enabled, do nothing otherwise.
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Formatting values for the shadow.
         */
      }, {
        key: "disableShadow",
        value: function disableShadow(ctx, values3) {
          if (values3.shadow === true) {
            ctx.shadowColor = "rgba(0,0,0,0)";
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
          }
        }
        /**
         * Render the background according to the formatting values.
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Formatting values for the background.
         */
      }, {
        key: "drawBackground",
        value: function drawBackground(ctx, values3) {
          if (values3.background !== false) {
            var origCtxAttr = {
              strokeStyle: ctx.strokeStyle,
              lineWidth: ctx.lineWidth,
              dashes: ctx.dashes
            };
            ctx.strokeStyle = values3.backgroundColor;
            ctx.lineWidth = values3.backgroundSize;
            this.setStrokeDashed(ctx, values3.backgroundDashes);
            ctx.stroke();
            ctx.strokeStyle = origCtxAttr.strokeStyle;
            ctx.lineWidth = origCtxAttr.lineWidth;
            ctx.dashes = origCtxAttr.dashes;
            this.setStrokeDashed(ctx, values3.dashes);
          }
        }
        /**
         * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.
         *
         * @param ctx - The context that will be used for rendering.
         * @param dashes - The pattern [line, space, line], true for default dashed line or false for normal line.
         */
      }, {
        key: "setStrokeDashed",
        value: function setStrokeDashed(ctx, dashes) {
          if (dashes !== false) {
            if (ctx.setLineDash !== void 0) {
              var pattern = isArray$5(dashes) ? dashes : [5, 5];
              ctx.setLineDash(pattern);
            } else {
              console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
            }
          } else {
            if (ctx.setLineDash !== void 0) {
              ctx.setLineDash([]);
            } else {
              console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
            }
          }
        }
      }]);
      return EdgeBase2;
    }();
    BezierEdgeBase = function(_EdgeBase) {
      inherits(BezierEdgeBase2, _EdgeBase);
      var _super = _createSuper$k(BezierEdgeBase2);
      function BezierEdgeBase2(options2, body, labelModule) {
        classCallCheck(this, BezierEdgeBase2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(BezierEdgeBase2, [{
        key: "_findBorderPositionBezier",
        value: function _findBorderPositionBezier(nearNode, ctx) {
          var viaNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._getViaCoordinates();
          var maxIterations = 10;
          var threshold = 0.2;
          var from2 = false;
          var high = 1;
          var low2 = 0;
          var node = this.to;
          var pos;
          var middle;
          var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;
          if (nearNode.id === this.from.id) {
            node = this.from;
            from2 = true;
            endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;
          }
          if (this.options.arrowStrikethrough === false) {
            endPointOffset = 0;
          }
          var iteration = 0;
          do {
            middle = (low2 + high) * 0.5;
            pos = this.getPoint(middle, viaNode);
            var angle = Math.atan2(node.y - pos.y, node.x - pos.x);
            var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;
            var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
            var difference = distanceToBorder - distanceToPoint;
            if (Math.abs(difference) < threshold) {
              break;
            } else if (difference < 0) {
              if (from2 === false) {
                low2 = middle;
              } else {
                high = middle;
              }
            } else {
              if (from2 === false) {
                high = middle;
              } else {
                low2 = middle;
              }
            }
            ++iteration;
          } while (low2 <= high && iteration < maxIterations);
          return _objectSpread$4(_objectSpread$4({}, pos), {}, {
            t: middle
          });
        }
        /**
         * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
         *
         * @remarks
         * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
         *
         * @param x1 - First end of the line segment on the x axis.
         * @param y1 - First end of the line segment on the y axis.
         * @param x2 - Second end of the line segment on the x axis.
         * @param y2 - Second end of the line segment on the y axis.
         * @param x3 - Position of the point on the x axis.
         * @param y3 - Position of the point on the y axis.
         * @param via - The control point for the edge.
         *
         * @returns The distance between the line segment and the point.
         */
      }, {
        key: "_getDistanceToBezierEdge",
        value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
          var minDistance = 1e9;
          var distance;
          var i, t, x, y;
          var lastX = x1;
          var lastY = y1;
          for (i = 1; i < 10; i++) {
            t = 0.1 * i;
            x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
            y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
            if (i > 0) {
              distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
              minDistance = distance < minDistance ? distance : minDistance;
            }
            lastX = x;
            lastY = y;
          }
          return minDistance;
        }
        /**
         * Render a bezier curve between two nodes.
         *
         * @remarks
         * The method accepts zero, one or two control points.
         * Passing zero control points just draws a straight line.
         *
         * @param ctx - The context that will be used for rendering.
         * @param values - Style options for edge drawing.
         * @param viaNode1 - First control point for curve drawing.
         * @param viaNode2 - Second control point for curve drawing.
         */
      }, {
        key: "_bezierCurve",
        value: function _bezierCurve(ctx, values3, viaNode1, viaNode2) {
          ctx.beginPath();
          ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
          if (viaNode1 != null && viaNode1.x != null) {
            if (viaNode2 != null && viaNode2.x != null) {
              ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
            } else {
              ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
            }
          } else {
            ctx.lineTo(this.toPoint.x, this.toPoint.y);
          }
          this.drawBackground(ctx, values3);
          this.enableShadow(ctx, values3);
          ctx.stroke();
          this.disableShadow(ctx, values3);
        }
        /** @inheritdoc */
      }, {
        key: "getViaNode",
        value: function getViaNode() {
          return this._getViaCoordinates();
        }
      }]);
      return BezierEdgeBase2;
    }(EdgeBase);
    BezierEdgeDynamic = function(_BezierEdgeBase) {
      inherits(BezierEdgeDynamic2, _BezierEdgeBase);
      var _super = _createSuper$l(BezierEdgeDynamic2);
      function BezierEdgeDynamic2(options2, body, labelModule) {
        var _this;
        classCallCheck(this, BezierEdgeDynamic2);
        _this = _super.call(this, options2, body, labelModule);
        _this.via = _this.via;
        _this._boundFunction = function() {
          _this.positionBezierNode();
        };
        _this._body.emitter.on("_repositionBezierNodes", _this._boundFunction);
        return _this;
      }
      createClass(BezierEdgeDynamic2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          get$5(getPrototypeOf$5(BezierEdgeDynamic2.prototype), "setOptions", this).call(this, options2);
          var physicsChange = false;
          if (this.options.physics !== options2.physics) {
            physicsChange = true;
          }
          this.options = options2;
          this.id = this.options.id;
          this.from = this._body.nodes[this.options.from];
          this.to = this._body.nodes[this.options.to];
          this.setupSupportNode();
          this.connect();
          if (physicsChange === true) {
            this.via.setOptions({
              physics: this.options.physics
            });
            this.positionBezierNode();
          }
        }
        /** @inheritdoc */
      }, {
        key: "connect",
        value: function connect() {
          this.from = this._body.nodes[this.options.from];
          this.to = this._body.nodes[this.options.to];
          if (this.from === void 0 || this.to === void 0 || this.options.physics === false) {
            this.via.setOptions({
              physics: false
            });
          } else {
            if (this.from.id === this.to.id) {
              this.via.setOptions({
                physics: false
              });
            } else {
              this.via.setOptions({
                physics: true
              });
            }
          }
        }
        /** @inheritdoc */
      }, {
        key: "cleanup",
        value: function cleanup() {
          this._body.emitter.off("_repositionBezierNodes", this._boundFunction);
          if (this.via !== void 0) {
            delete this._body.nodes[this.via.id];
            this.via = void 0;
            return true;
          }
          return false;
        }
        /**
         * Create and add a support node if not already present.
         *
         * @remarks
         * Bezier curves require an anchor point to calculate the smooth flow.
         * These points are nodes.
         * These nodes are invisible but are used for the force calculation.
         *
         * The changed data is not called, if needed, it is returned by the main edge constructor.
         */
      }, {
        key: "setupSupportNode",
        value: function setupSupportNode() {
          if (this.via === void 0) {
            var nodeId = "edgeId:" + this.id;
            var node = this._body.functions.createNode({
              id: nodeId,
              shape: "circle",
              physics: true,
              hidden: true
            });
            this._body.nodes[nodeId] = node;
            this.via = node;
            this.via.parentEdgeId = this.id;
            this.positionBezierNode();
          }
        }
        /**
         * Position bezier node.
         */
      }, {
        key: "positionBezierNode",
        value: function positionBezierNode() {
          if (this.via !== void 0 && this.from !== void 0 && this.to !== void 0) {
            this.via.x = 0.5 * (this.from.x + this.to.x);
            this.via.y = 0.5 * (this.from.y + this.to.y);
          } else if (this.via !== void 0) {
            this.via.x = 0;
            this.via.y = 0;
          }
        }
        /** @inheritdoc */
      }, {
        key: "_line",
        value: function _line(ctx, values3, viaNode) {
          this._bezierCurve(ctx, values3, viaNode);
        }
        /** @inheritdoc */
      }, {
        key: "_getViaCoordinates",
        value: function _getViaCoordinates() {
          return this.via;
        }
        /** @inheritdoc */
      }, {
        key: "getViaNode",
        value: function getViaNode() {
          return this.via;
        }
        /** @inheritdoc */
      }, {
        key: "getPoint",
        value: function getPoint(position) {
          var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.via;
          if (this.from === this.to) {
            var _this$_getCircleData = this._getCircleData(), _this$_getCircleData2 = slicedToArray(_this$_getCircleData, 3), cx = _this$_getCircleData2[0], cy = _this$_getCircleData2[1], cr = _this$_getCircleData2[2];
            var a = 2 * Math.PI * (1 - position);
            return {
              x: cx + cr * Math.sin(a),
              y: cy + cr - cr * (1 - Math.cos(a))
            };
          } else {
            return {
              x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,
              y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y
            };
          }
        }
        /** @inheritdoc */
      }, {
        key: "_findBorderPosition",
        value: function _findBorderPosition(nearNode, ctx) {
          return this._findBorderPositionBezier(nearNode, ctx, this.via);
        }
        /** @inheritdoc */
      }, {
        key: "_getDistanceToEdge",
        value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
          return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
        }
      }]);
      return BezierEdgeDynamic2;
    }(BezierEdgeBase);
    BezierEdgeStatic = function(_BezierEdgeBase) {
      inherits(BezierEdgeStatic2, _BezierEdgeBase);
      var _super = _createSuper$m(BezierEdgeStatic2);
      function BezierEdgeStatic2(options2, body, labelModule) {
        classCallCheck(this, BezierEdgeStatic2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(BezierEdgeStatic2, [{
        key: "_line",
        value: function _line(ctx, values3, viaNode) {
          this._bezierCurve(ctx, values3, viaNode);
        }
        /** @inheritdoc */
      }, {
        key: "getViaNode",
        value: function getViaNode() {
          return this._getViaCoordinates();
        }
        /**
         * Compute the coordinates of the via node.
         *
         * @remarks
         * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
         *
         * @returns Cartesian coordinates of the via node.
         */
      }, {
        key: "_getViaCoordinates",
        value: function _getViaCoordinates() {
          var factor = this.options.smooth.roundness;
          var type = this.options.smooth.type;
          var dx = Math.abs(this.from.x - this.to.x);
          var dy = Math.abs(this.from.y - this.to.y);
          if (type === "discrete" || type === "diagonalCross") {
            var stepX;
            var stepY;
            if (dx <= dy) {
              stepX = stepY = factor * dy;
            } else {
              stepX = stepY = factor * dx;
            }
            if (this.from.x > this.to.x) {
              stepX = -stepX;
            }
            if (this.from.y >= this.to.y) {
              stepY = -stepY;
            }
            var xVia = this.from.x + stepX;
            var yVia = this.from.y + stepY;
            if (type === "discrete") {
              if (dx <= dy) {
                xVia = dx < factor * dy ? this.from.x : xVia;
              } else {
                yVia = dy < factor * dx ? this.from.y : yVia;
              }
            }
            return {
              x: xVia,
              y: yVia
            };
          } else if (type === "straightCross") {
            var _stepX = (1 - factor) * dx;
            var _stepY = (1 - factor) * dy;
            if (dx <= dy) {
              _stepX = 0;
              if (this.from.y < this.to.y) {
                _stepY = -_stepY;
              }
            } else {
              if (this.from.x < this.to.x) {
                _stepX = -_stepX;
              }
              _stepY = 0;
            }
            return {
              x: this.to.x + _stepX,
              y: this.to.y + _stepY
            };
          } else if (type === "horizontal") {
            var _stepX2 = (1 - factor) * dx;
            if (this.from.x < this.to.x) {
              _stepX2 = -_stepX2;
            }
            return {
              x: this.to.x + _stepX2,
              y: this.from.y
            };
          } else if (type === "vertical") {
            var _stepY2 = (1 - factor) * dy;
            if (this.from.y < this.to.y) {
              _stepY2 = -_stepY2;
            }
            return {
              x: this.from.x,
              y: this.to.y + _stepY2
            };
          } else if (type === "curvedCW") {
            dx = this.to.x - this.from.x;
            dy = this.from.y - this.to.y;
            var radius = Math.sqrt(dx * dx + dy * dy);
            var pi = Math.PI;
            var originalAngle = Math.atan2(dy, dx);
            var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);
            return {
              x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),
              y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)
            };
          } else if (type === "curvedCCW") {
            dx = this.to.x - this.from.x;
            dy = this.from.y - this.to.y;
            var _radius = Math.sqrt(dx * dx + dy * dy);
            var _pi = Math.PI;
            var _originalAngle = Math.atan2(dy, dx);
            var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);
            return {
              x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),
              y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)
            };
          } else {
            var _stepX3;
            var _stepY3;
            if (dx <= dy) {
              _stepX3 = _stepY3 = factor * dy;
            } else {
              _stepX3 = _stepY3 = factor * dx;
            }
            if (this.from.x > this.to.x) {
              _stepX3 = -_stepX3;
            }
            if (this.from.y >= this.to.y) {
              _stepY3 = -_stepY3;
            }
            var _xVia = this.from.x + _stepX3;
            var _yVia = this.from.y + _stepY3;
            if (dx <= dy) {
              if (this.from.x <= this.to.x) {
                _xVia = this.to.x < _xVia ? this.to.x : _xVia;
              } else {
                _xVia = this.to.x > _xVia ? this.to.x : _xVia;
              }
            } else {
              if (this.from.y >= this.to.y) {
                _yVia = this.to.y > _yVia ? this.to.y : _yVia;
              } else {
                _yVia = this.to.y < _yVia ? this.to.y : _yVia;
              }
            }
            return {
              x: _xVia,
              y: _yVia
            };
          }
        }
        /** @inheritdoc */
      }, {
        key: "_findBorderPosition",
        value: function _findBorderPosition(nearNode, ctx) {
          var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this._findBorderPositionBezier(nearNode, ctx, options2.via);
        }
        /** @inheritdoc */
      }, {
        key: "_getDistanceToEdge",
        value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
          var viaNode = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates();
          return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
        }
        /** @inheritdoc */
      }, {
        key: "getPoint",
        value: function getPoint(position) {
          var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates();
          var t = position;
          var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
          var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
          return {
            x,
            y
          };
        }
      }]);
      return BezierEdgeStatic2;
    }(BezierEdgeBase);
    CubicBezierEdgeBase = function(_BezierEdgeBase) {
      inherits(CubicBezierEdgeBase2, _BezierEdgeBase);
      var _super = _createSuper$n(CubicBezierEdgeBase2);
      function CubicBezierEdgeBase2(options2, body, labelModule) {
        classCallCheck(this, CubicBezierEdgeBase2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(CubicBezierEdgeBase2, [{
        key: "_getDistanceToBezierEdge2",
        value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {
          var minDistance = 1e9;
          var lastX = x1;
          var lastY = y1;
          var vec = [0, 0, 0, 0];
          for (var i = 1; i < 10; i++) {
            var t = 0.1 * i;
            vec[0] = Math.pow(1 - t, 3);
            vec[1] = 3 * t * Math.pow(1 - t, 2);
            vec[2] = 3 * Math.pow(t, 2) * (1 - t);
            vec[3] = Math.pow(t, 3);
            var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
            var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
            if (i > 0) {
              var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
              minDistance = distance < minDistance ? distance : minDistance;
            }
            lastX = x;
            lastY = y;
          }
          return minDistance;
        }
      }]);
      return CubicBezierEdgeBase2;
    }(BezierEdgeBase);
    CubicBezierEdge = function(_CubicBezierEdgeBase) {
      inherits(CubicBezierEdge2, _CubicBezierEdgeBase);
      var _super = _createSuper$o(CubicBezierEdge2);
      function CubicBezierEdge2(options2, body, labelModule) {
        classCallCheck(this, CubicBezierEdge2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(CubicBezierEdge2, [{
        key: "_line",
        value: function _line(ctx, values3, viaNodes) {
          var via1 = viaNodes[0];
          var via2 = viaNodes[1];
          this._bezierCurve(ctx, values3, via1, via2);
        }
        /**
         * Compute the additional points the edge passes through.
         *
         * @returns Cartesian coordinates of the points the edge passes through.
         */
      }, {
        key: "_getViaCoordinates",
        value: function _getViaCoordinates() {
          var dx = this.from.x - this.to.x;
          var dy = this.from.y - this.to.y;
          var x1;
          var y1;
          var x2;
          var y2;
          var roundness = this.options.smooth.roundness;
          if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === "horizontal") && this.options.smooth.forceDirection !== "vertical") {
            y1 = this.from.y;
            y2 = this.to.y;
            x1 = this.from.x - roundness * dx;
            x2 = this.to.x + roundness * dx;
          } else {
            y1 = this.from.y - roundness * dy;
            y2 = this.to.y + roundness * dy;
            x1 = this.from.x;
            x2 = this.to.x;
          }
          return [{
            x: x1,
            y: y1
          }, {
            x: x2,
            y: y2
          }];
        }
        /** @inheritdoc */
      }, {
        key: "getViaNode",
        value: function getViaNode() {
          return this._getViaCoordinates();
        }
        /** @inheritdoc */
      }, {
        key: "_findBorderPosition",
        value: function _findBorderPosition(nearNode, ctx) {
          return this._findBorderPositionBezier(nearNode, ctx);
        }
        /** @inheritdoc */
      }, {
        key: "_getDistanceToEdge",
        value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
          var _ref = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates(), _ref2 = slicedToArray(_ref, 2), via1 = _ref2[0], via2 = _ref2[1];
          return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);
        }
        /** @inheritdoc */
      }, {
        key: "getPoint",
        value: function getPoint(position) {
          var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates(), _ref4 = slicedToArray(_ref3, 2), via1 = _ref4[0], via2 = _ref4[1];
          var t = position;
          var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];
          var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
          var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;
          return {
            x,
            y
          };
        }
      }]);
      return CubicBezierEdge2;
    }(CubicBezierEdgeBase);
    StraightEdge = function(_EdgeBase) {
      inherits(StraightEdge2, _EdgeBase);
      var _super = _createSuper$p(StraightEdge2);
      function StraightEdge2(options2, body, labelModule) {
        classCallCheck(this, StraightEdge2);
        return _super.call(this, options2, body, labelModule);
      }
      createClass(StraightEdge2, [{
        key: "_line",
        value: function _line(ctx, values3) {
          ctx.beginPath();
          ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
          this.enableShadow(ctx, values3);
          ctx.stroke();
          this.disableShadow(ctx, values3);
        }
        /** @inheritdoc */
      }, {
        key: "getViaNode",
        value: function getViaNode() {
          return void 0;
        }
        /** @inheritdoc */
      }, {
        key: "getPoint",
        value: function getPoint(position) {
          return {
            x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,
            y: (1 - position) * this.fromPoint.y + position * this.toPoint.y
          };
        }
        /** @inheritdoc */
      }, {
        key: "_findBorderPosition",
        value: function _findBorderPosition(nearNode, ctx) {
          var node1 = this.to;
          var node2 = this.from;
          if (nearNode.id === this.from.id) {
            node1 = this.from;
            node2 = this.to;
          }
          var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
          var dx = node1.x - node2.x;
          var dy = node1.y - node2.y;
          var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
          var toBorderDist = nearNode.distanceToBorder(ctx, angle);
          var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;
          return {
            x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,
            y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,
            t: 0
          };
        }
        /** @inheritdoc */
      }, {
        key: "_getDistanceToEdge",
        value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
          return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
        }
      }]);
      return StraightEdge2;
    }(EdgeBase);
    Edge = function() {
      function Edge2(options2, body, imagelist, globalOptions, defaultOptions) {
        classCallCheck(this, Edge2);
        if (body === void 0) {
          throw new Error("No body provided");
        }
        this.options = bridgeObject(globalOptions);
        this.globalOptions = globalOptions;
        this.defaultOptions = defaultOptions;
        this.body = body;
        this.imagelist = imagelist;
        this.id = void 0;
        this.fromId = void 0;
        this.toId = void 0;
        this.selected = false;
        this.hover = false;
        this.labelDirty = true;
        this.baseWidth = this.options.width;
        this.baseFontSize = this.options.font.size;
        this.from = void 0;
        this.to = void 0;
        this.edgeType = void 0;
        this.connected = false;
        this.labelModule = new Label(
          this.body,
          this.options,
          true
          /* It's an edge label */
        );
        this.setOptions(options2);
      }
      createClass(Edge2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          if (!options2) {
            return;
          }
          var affectsLayout = typeof options2.physics !== "undefined" && this.options.physics !== options2.physics || typeof options2.hidden !== "undefined" && (this.options.hidden || false) !== (options2.hidden || false) || typeof options2.from !== "undefined" && this.options.from !== options2.from || typeof options2.to !== "undefined" && this.options.to !== options2.to;
          Edge2.parseOptions(this.options, options2, true, this.globalOptions);
          if (options2.id !== void 0) {
            this.id = options2.id;
          }
          if (options2.from !== void 0) {
            this.fromId = options2.from;
          }
          if (options2.to !== void 0) {
            this.toId = options2.to;
          }
          if (options2.title !== void 0) {
            this.title = options2.title;
          }
          if (options2.value !== void 0) {
            options2.value = _parseFloat$2(options2.value);
          }
          var pile = [options2, this.options, this.defaultOptions];
          this.chooser = choosify("edge", pile);
          this.updateLabelModule(options2);
          affectsLayout = this.updateEdgeType() || affectsLayout;
          this._setInteractionWidths();
          this.connect();
          return affectsLayout;
        }
        /**
         *
         * @param {Object} parentOptions
         * @param {Object} newOptions
         * @param {boolean} [allowDeletion=false]
         * @param {Object} [globalOptions={}]
         * @param {boolean} [copyFromGlobals=false]
         */
      }, {
        key: "getFormattingValues",
        /**
         *
         * @returns {ArrowOptions}
         */
        value: function getFormattingValues() {
          var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
          var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
          var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
          var inheritsColor = this.options.color.inherit;
          var values3 = {
            toArrow,
            toArrowScale: this.options.arrows.to.scaleFactor,
            toArrowType: this.options.arrows.to.type,
            toArrowSrc: this.options.arrows.to.src,
            toArrowImageWidth: this.options.arrows.to.imageWidth,
            toArrowImageHeight: this.options.arrows.to.imageHeight,
            middleArrow,
            middleArrowScale: this.options.arrows.middle.scaleFactor,
            middleArrowType: this.options.arrows.middle.type,
            middleArrowSrc: this.options.arrows.middle.src,
            middleArrowImageWidth: this.options.arrows.middle.imageWidth,
            middleArrowImageHeight: this.options.arrows.middle.imageHeight,
            fromArrow,
            fromArrowScale: this.options.arrows.from.scaleFactor,
            fromArrowType: this.options.arrows.from.type,
            fromArrowSrc: this.options.arrows.from.src,
            fromArrowImageWidth: this.options.arrows.from.imageWidth,
            fromArrowImageHeight: this.options.arrows.from.imageHeight,
            arrowStrikethrough: this.options.arrowStrikethrough,
            color: inheritsColor ? void 0 : this.options.color.color,
            inheritsColor,
            opacity: this.options.color.opacity,
            hidden: this.options.hidden,
            length: this.options.length,
            shadow: this.options.shadow.enabled,
            shadowColor: this.options.shadow.color,
            shadowSize: this.options.shadow.size,
            shadowX: this.options.shadow.x,
            shadowY: this.options.shadow.y,
            dashes: this.options.dashes,
            width: this.options.width,
            background: this.options.background.enabled,
            backgroundColor: this.options.background.color,
            backgroundSize: this.options.background.size,
            backgroundDashes: this.options.background.dashes
          };
          if (this.selected || this.hover) {
            if (this.chooser === true) {
              if (this.selected) {
                var selectedWidth = this.options.selectionWidth;
                if (typeof selectedWidth === "function") {
                  values3.width = selectedWidth(values3.width);
                } else if (typeof selectedWidth === "number") {
                  values3.width += selectedWidth;
                }
                values3.width = Math.max(values3.width, 0.3 / this.body.view.scale);
                values3.color = this.options.color.highlight;
                values3.shadow = this.options.shadow.enabled;
              } else if (this.hover) {
                var hoverWidth = this.options.hoverWidth;
                if (typeof hoverWidth === "function") {
                  values3.width = hoverWidth(values3.width);
                } else if (typeof hoverWidth === "number") {
                  values3.width += hoverWidth;
                }
                values3.width = Math.max(values3.width, 0.3 / this.body.view.scale);
                values3.color = this.options.color.hover;
                values3.shadow = this.options.shadow.enabled;
              }
            } else if (typeof this.chooser === "function") {
              this.chooser(values3, this.options.id, this.selected, this.hover);
              if (values3.color !== void 0) {
                values3.inheritsColor = false;
              }
              if (values3.shadow === false) {
                if (values3.shadowColor !== this.options.shadow.color || values3.shadowSize !== this.options.shadow.size || values3.shadowX !== this.options.shadow.x || values3.shadowY !== this.options.shadow.y) {
                  values3.shadow = true;
                }
              }
            }
          } else {
            values3.shadow = this.options.shadow.enabled;
            values3.width = Math.max(values3.width, 0.3 / this.body.view.scale);
          }
          return values3;
        }
        /**
         * update the options in the label module
         *
         * @param {Object} options
         */
      }, {
        key: "updateLabelModule",
        value: function updateLabelModule(options2) {
          var pile = [
            options2,
            this.options,
            this.globalOptions,
            // Currently set global edge options
            this.defaultOptions
          ];
          this.labelModule.update(this.options, pile);
          if (this.labelModule.baseSize !== void 0) {
            this.baseFontSize = this.labelModule.baseSize;
          }
        }
        /**
         * update the edge type, set the options
         * @returns {boolean}
         */
      }, {
        key: "updateEdgeType",
        value: function updateEdgeType() {
          var smooth = this.options.smooth;
          var dataChanged = false;
          var changeInType = true;
          if (this.edgeType !== void 0) {
            if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === "dynamic" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === "cubicBezier" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== "dynamic" && smooth.type !== "cubicBezier" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
              changeInType = false;
            }
            if (changeInType === true) {
              dataChanged = this.cleanup();
            }
          }
          if (changeInType === true) {
            if (smooth.enabled === true) {
              if (smooth.type === "dynamic") {
                dataChanged = true;
                this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
              } else if (smooth.type === "cubicBezier") {
                this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
              } else {
                this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
              }
            } else {
              this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
            }
          } else {
            this.edgeType.setOptions(this.options);
          }
          return dataChanged;
        }
        /**
         * Connect an edge to its nodes
         */
      }, {
        key: "connect",
        value: function connect() {
          this.disconnect();
          this.from = this.body.nodes[this.fromId] || void 0;
          this.to = this.body.nodes[this.toId] || void 0;
          this.connected = this.from !== void 0 && this.to !== void 0;
          if (this.connected === true) {
            this.from.attachEdge(this);
            this.to.attachEdge(this);
          } else {
            if (this.from) {
              this.from.detachEdge(this);
            }
            if (this.to) {
              this.to.detachEdge(this);
            }
          }
          this.edgeType.connect();
        }
        /**
         * Disconnect an edge from its nodes
         */
      }, {
        key: "disconnect",
        value: function disconnect() {
          if (this.from) {
            this.from.detachEdge(this);
            this.from = void 0;
          }
          if (this.to) {
            this.to.detachEdge(this);
            this.to = void 0;
          }
          this.connected = false;
        }
        /**
         * get the title of this edge.
         * @return {string} title    The title of the edge, or undefined when no title
         *                           has been set.
         */
      }, {
        key: "getTitle",
        value: function getTitle() {
          return this.title;
        }
        /**
         * check if this node is selecte
         * @return {boolean} selected   True if node is selected, else false
         */
      }, {
        key: "isSelected",
        value: function isSelected() {
          return this.selected;
        }
        /**
         * Retrieve the value of the edge. Can be undefined
         * @return {number} value
         */
      }, {
        key: "getValue",
        value: function getValue() {
          return this.options.value;
        }
        /**
         * Adjust the value range of the edge. The edge will adjust it's width
         * based on its value.
         * @param {number} min
         * @param {number} max
         * @param {number} total
         */
      }, {
        key: "setValueRange",
        value: function setValueRange(min2, max2, total) {
          if (this.options.value !== void 0) {
            var scale = this.options.scaling.customScalingFunction(min2, max2, total, this.options.value);
            var widthDiff = this.options.scaling.max - this.options.scaling.min;
            if (this.options.scaling.label.enabled === true) {
              var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
              this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
            }
            this.options.width = this.options.scaling.min + scale * widthDiff;
          } else {
            this.options.width = this.baseWidth;
            this.options.font.size = this.baseFontSize;
          }
          this._setInteractionWidths();
          this.updateLabelModule();
        }
        /**
         *
         * @private
         */
      }, {
        key: "_setInteractionWidths",
        value: function _setInteractionWidths() {
          if (typeof this.options.hoverWidth === "function") {
            this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
          } else {
            this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
          }
          if (typeof this.options.selectionWidth === "function") {
            this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
          } else {
            this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
          }
        }
        /**
         * Redraw a edge
         * Draw this edge in the given canvas
         * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
         * @param {CanvasRenderingContext2D}   ctx
         */
      }, {
        key: "draw",
        value: function draw(ctx) {
          var values3 = this.getFormattingValues();
          if (values3.hidden) {
            return;
          }
          var viaNode = this.edgeType.getViaNode();
          this.edgeType.drawLine(ctx, values3, this.selected, this.hover, viaNode);
          this.drawLabel(ctx, viaNode);
        }
        /**
        * Redraw arrows
        * Draw this arrows in the given canvas
        * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
        * @param {CanvasRenderingContext2D}   ctx
        */
      }, {
        key: "drawArrows",
        value: function drawArrows(ctx) {
          var values3 = this.getFormattingValues();
          if (values3.hidden) {
            return;
          }
          var viaNode = this.edgeType.getViaNode();
          var arrowData = {};
          this.edgeType.fromPoint = this.edgeType.from;
          this.edgeType.toPoint = this.edgeType.to;
          if (values3.fromArrow) {
            arrowData.from = this.edgeType.getArrowData(ctx, "from", viaNode, this.selected, this.hover, values3);
            if (values3.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;
            if (values3.fromArrowSrc) {
              arrowData.from.image = this.imagelist.load(values3.fromArrowSrc);
            }
            if (values3.fromArrowImageWidth) {
              arrowData.from.imageWidth = values3.fromArrowImageWidth;
            }
            if (values3.fromArrowImageHeight) {
              arrowData.from.imageHeight = values3.fromArrowImageHeight;
            }
          }
          if (values3.toArrow) {
            arrowData.to = this.edgeType.getArrowData(ctx, "to", viaNode, this.selected, this.hover, values3);
            if (values3.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;
            if (values3.toArrowSrc) {
              arrowData.to.image = this.imagelist.load(values3.toArrowSrc);
            }
            if (values3.toArrowImageWidth) {
              arrowData.to.imageWidth = values3.toArrowImageWidth;
            }
            if (values3.toArrowImageHeight) {
              arrowData.to.imageHeight = values3.toArrowImageHeight;
            }
          }
          if (values3.middleArrow) {
            arrowData.middle = this.edgeType.getArrowData(ctx, "middle", viaNode, this.selected, this.hover, values3);
            if (values3.middleArrowSrc) {
              arrowData.middle.image = this.imagelist.load(values3.middleArrowSrc);
            }
            if (values3.middleArrowImageWidth) {
              arrowData.middle.imageWidth = values3.middleArrowImageWidth;
            }
            if (values3.middleArrowImageHeight) {
              arrowData.middle.imageHeight = values3.middleArrowImageHeight;
            }
          }
          if (values3.fromArrow) {
            this.edgeType.drawArrowHead(ctx, values3, this.selected, this.hover, arrowData.from);
          }
          if (values3.middleArrow) {
            this.edgeType.drawArrowHead(ctx, values3, this.selected, this.hover, arrowData.middle);
          }
          if (values3.toArrow) {
            this.edgeType.drawArrowHead(ctx, values3, this.selected, this.hover, arrowData.to);
          }
        }
        /**
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {Node} viaNode
         */
      }, {
        key: "drawLabel",
        value: function drawLabel(ctx, viaNode) {
          if (this.options.label !== void 0) {
            var node1 = this.from;
            var node2 = this.to;
            if (this.labelModule.differentState(this.selected, this.hover)) {
              this.labelModule.getTextSize(ctx, this.selected, this.hover);
            }
            var point;
            if (node1.id != node2.id) {
              this.labelModule.pointToSelf = false;
              point = this.edgeType.getPoint(0.5, viaNode);
              ctx.save();
              var rotationPoint = this._getRotation(ctx);
              if (rotationPoint.angle != 0) {
                ctx.translate(rotationPoint.x, rotationPoint.y);
                ctx.rotate(rotationPoint.angle);
              }
              this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
              ctx.restore();
            } else {
              this.labelModule.pointToSelf = true;
              var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);
              point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);
              this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
            }
          }
        }
        /**
         * Determine all visual elements of this edge instance, in which the given
         * point falls within the bounding shape.
         *
         * @param {point} point
         * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
         */
      }, {
        key: "getItemsOnPoint",
        value: function getItemsOnPoint(point) {
          var ret = [];
          if (this.labelModule.visible()) {
            var rotationPoint = this._getRotation();
            if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
              ret.push({
                edgeId: this.id,
                labelId: 0
              });
            }
          }
          var obj = {
            left: point.x,
            top: point.y
          };
          if (this.isOverlappingWith(obj)) {
            ret.push({
              edgeId: this.id
            });
          }
          return ret;
        }
        /**
         * Check if this object is overlapping with the provided object
         * @param {Object} obj   an object with parameters left, top
         * @return {boolean}     True if location is located on the edge
         */
      }, {
        key: "isOverlappingWith",
        value: function isOverlappingWith(obj) {
          if (this.connected) {
            var distMax = 10;
            var xFrom = this.from.x;
            var yFrom = this.from.y;
            var xTo = this.to.x;
            var yTo = this.to.y;
            var xObj = obj.left;
            var yObj = obj.top;
            var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);
            return dist < distMax;
          } else {
            return false;
          }
        }
        /** 
         * Determine the rotation point, if any.
         *
         * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
         * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
         * @private
         */
      }, {
        key: "_getRotation",
        value: function _getRotation(ctx) {
          var viaNode = this.edgeType.getViaNode();
          var point = this.edgeType.getPoint(0.5, viaNode);
          if (ctx !== void 0) {
            this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
          }
          var ret = {
            x: point.x,
            y: this.labelModule.size.yLine,
            angle: 0
          };
          if (!this.labelModule.visible()) {
            return ret;
          }
          if (this.options.font.align === "horizontal") {
            return ret;
          }
          var dy = this.from.y - this.to.y;
          var dx = this.from.x - this.to.x;
          var angle = Math.atan2(dy, dx);
          if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
            angle += Math.PI;
          }
          ret.angle = angle;
          return ret;
        }
        /**
         * Get a point on a circle
         * @param {number} x
         * @param {number} y
         * @param {number} radius
         * @param {number} angle 
         * @return {Object} point
         * @private
         */
      }, {
        key: "_pointOnCircle",
        value: function _pointOnCircle(x, y, radius, angle) {
          return {
            x: x + radius * Math.cos(angle),
            y: y - radius * Math.sin(angle)
          };
        }
        /**
         * Sets selected state to true
         */
      }, {
        key: "select",
        value: function select() {
          this.selected = true;
        }
        /**
         * Sets selected state to false
         */
      }, {
        key: "unselect",
        value: function unselect() {
          this.selected = false;
        }
        /**
         * cleans all required things on delete
         * @returns {*}
         */
      }, {
        key: "cleanup",
        value: function cleanup() {
          return this.edgeType.cleanup();
        }
        /**
         * Remove edge from the list and perform necessary cleanup.
         */
      }, {
        key: "remove",
        value: function remove() {
          this.cleanup();
          this.disconnect();
          delete this.body.edges[this.id];
        }
        /**
         * Check if both connecting nodes exist
         * @returns {boolean}
         */
      }, {
        key: "endPointsValid",
        value: function endPointsValid() {
          return this.body.nodes[this.fromId] !== void 0 && this.body.nodes[this.toId] !== void 0;
        }
      }], [{
        key: "parseOptions",
        value: function parseOptions(parentOptions, newOptions) {
          var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var copyFromGlobals = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
          var fields = ["endPointOffset", "arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "selfReference", "to", "title", "value", "width", "font", "chosen", "widthConstraint"];
          selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);
          if (newOptions.endPointOffset !== void 0 && newOptions.endPointOffset.from !== void 0) {
            if (_isFinite$2(newOptions.endPointOffset.from)) {
              parentOptions.endPointOffset.from = newOptions.endPointOffset.from;
            } else {
              parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== void 0 ? globalOptions.endPointOffset.from : 0;
              console.error("endPointOffset.from is not a valid number");
            }
          }
          if (newOptions.endPointOffset !== void 0 && newOptions.endPointOffset.to !== void 0) {
            if (_isFinite$2(newOptions.endPointOffset.to)) {
              parentOptions.endPointOffset.to = newOptions.endPointOffset.to;
            } else {
              parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== void 0 ? globalOptions.endPointOffset.to : 0;
              console.error("endPointOffset.to is not a valid number");
            }
          }
          if (isValidLabel(newOptions.label)) {
            parentOptions.label = newOptions.label;
          } else if (!isValidLabel(parentOptions.label)) {
            parentOptions.label = void 0;
          }
          mergeOptions(parentOptions, newOptions, "smooth", globalOptions);
          mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
          mergeOptions(parentOptions, newOptions, "background", globalOptions);
          if (newOptions.dashes !== void 0 && newOptions.dashes !== null) {
            parentOptions.dashes = newOptions.dashes;
          } else if (allowDeletion === true && newOptions.dashes === null) {
            parentOptions.dashes = create$2(globalOptions.dashes);
          }
          if (newOptions.scaling !== void 0 && newOptions.scaling !== null) {
            if (newOptions.scaling.min !== void 0) {
              parentOptions.scaling.min = newOptions.scaling.min;
            }
            if (newOptions.scaling.max !== void 0) {
              parentOptions.scaling.max = newOptions.scaling.max;
            }
            mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
          } else if (allowDeletion === true && newOptions.scaling === null) {
            parentOptions.scaling = create$2(globalOptions.scaling);
          }
          if (newOptions.arrows !== void 0 && newOptions.arrows !== null) {
            if (typeof newOptions.arrows === "string") {
              var arrows = newOptions.arrows.toLowerCase();
              parentOptions.arrows.to.enabled = indexOf$3(arrows).call(arrows, "to") != -1;
              parentOptions.arrows.middle.enabled = indexOf$3(arrows).call(arrows, "middle") != -1;
              parentOptions.arrows.from.enabled = indexOf$3(arrows).call(arrows, "from") != -1;
            } else if (_typeof_1(newOptions.arrows) === "object") {
              mergeOptions(parentOptions.arrows, newOptions.arrows, "to", globalOptions.arrows);
              mergeOptions(parentOptions.arrows, newOptions.arrows, "middle", globalOptions.arrows);
              mergeOptions(parentOptions.arrows, newOptions.arrows, "from", globalOptions.arrows);
            } else {
              throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + stringify$2(newOptions.arrows));
            }
          } else if (allowDeletion === true && newOptions.arrows === null) {
            parentOptions.arrows = create$2(globalOptions.arrows);
          }
          if (newOptions.color !== void 0 && newOptions.color !== null) {
            var fromColor = isString(newOptions.color) ? {
              color: newOptions.color,
              highlight: newOptions.color,
              hover: newOptions.color,
              inherit: false,
              opacity: 1
            } : newOptions.color;
            var toColor = parentOptions.color;
            if (copyFromGlobals) {
              deepExtend(toColor, globalOptions.color, false, allowDeletion);
            } else {
              for (var i in toColor) {
                if (Object.prototype.hasOwnProperty.call(toColor, i)) {
                  delete toColor[i];
                }
              }
            }
            if (isString(toColor)) {
              toColor.color = toColor;
              toColor.highlight = toColor;
              toColor.hover = toColor;
              toColor.inherit = false;
              if (fromColor.opacity === void 0) {
                toColor.opacity = 1;
              }
            } else {
              var colorsDefined = false;
              if (fromColor.color !== void 0) {
                toColor.color = fromColor.color;
                colorsDefined = true;
              }
              if (fromColor.highlight !== void 0) {
                toColor.highlight = fromColor.highlight;
                colorsDefined = true;
              }
              if (fromColor.hover !== void 0) {
                toColor.hover = fromColor.hover;
                colorsDefined = true;
              }
              if (fromColor.inherit !== void 0) {
                toColor.inherit = fromColor.inherit;
              }
              if (fromColor.opacity !== void 0) {
                toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
              }
              if (colorsDefined === true) {
                toColor.inherit = false;
              } else {
                if (toColor.inherit === void 0) {
                  toColor.inherit = "from";
                }
              }
            }
          } else if (allowDeletion === true && newOptions.color === null) {
            parentOptions.color = bridgeObject(globalOptions.color);
          }
          if (allowDeletion === true && newOptions.font === null) {
            parentOptions.font = bridgeObject(globalOptions.font);
          }
          if (Object.prototype.hasOwnProperty.call(newOptions, "selfReferenceSize")) {
            console.log("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}");
            parentOptions.selfReference.size = newOptions.selfReferenceSize;
          }
        }
      }]);
      return Edge2;
    }();
    EdgesHandler = function() {
      function EdgesHandler2(body, images, groups) {
        var _context, _this = this;
        classCallCheck(this, EdgesHandler2);
        this.body = body;
        this.images = images;
        this.groups = groups;
        this.body.functions.createEdge = bind$2(_context = this.create).call(_context, this);
        this.edgesListeners = {
          add: function add(event, params) {
            _this.add(params.items);
          },
          update: function update(event, params) {
            _this.update(params.items);
          },
          remove: function remove(event, params) {
            _this.remove(params.items);
          }
        };
        this.options = {};
        this.defaultOptions = {
          arrows: {
            to: {
              enabled: false,
              scaleFactor: 1,
              type: "arrow"
            },
            // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
            middle: {
              enabled: false,
              scaleFactor: 1,
              type: "arrow"
            },
            from: {
              enabled: false,
              scaleFactor: 1,
              type: "arrow"
            }
          },
          endPointOffset: {
            from: 0,
            to: 0
          },
          arrowStrikethrough: true,
          color: {
            color: "#848484",
            highlight: "#848484",
            hover: "#848484",
            inherit: "from",
            opacity: 1
          },
          dashes: false,
          font: {
            color: "#343434",
            size: 14,
            // px
            face: "arial",
            background: "none",
            strokeWidth: 2,
            // px
            strokeColor: "#ffffff",
            align: "horizontal",
            multi: false,
            vadjust: 0,
            bold: {
              mod: "bold"
            },
            boldital: {
              mod: "bold italic"
            },
            ital: {
              mod: "italic"
            },
            mono: {
              mod: "",
              size: 15,
              // px
              face: "courier new",
              vadjust: 2
            }
          },
          hidden: false,
          hoverWidth: 1.5,
          label: void 0,
          labelHighlightBold: true,
          length: void 0,
          physics: true,
          scaling: {
            min: 1,
            max: 15,
            label: {
              enabled: true,
              min: 14,
              max: 30,
              maxVisible: 30,
              drawThreshold: 5
            },
            customScalingFunction: function customScalingFunction(min2, max2, total, value) {
              if (max2 === min2) {
                return 0.5;
              } else {
                var scale = 1 / (max2 - min2);
                return Math.max(0, (value - min2) * scale);
              }
            }
          },
          selectionWidth: 1.5,
          selfReference: {
            size: 20,
            angle: Math.PI / 4,
            renderBehindTheNode: true
          },
          shadow: {
            enabled: false,
            color: "rgba(0,0,0,0.5)",
            size: 10,
            x: 5,
            y: 5
          },
          background: {
            enabled: false,
            color: "rgba(111,111,111,1)",
            size: 10,
            dashes: false
          },
          smooth: {
            enabled: true,
            type: "dynamic",
            forceDirection: "none",
            roundness: 0.5
          },
          title: void 0,
          width: 1,
          value: void 0
        };
        deepExtend(this.options, this.defaultOptions);
        this.bindEventListeners();
      }
      createClass(EdgesHandler2, [{
        key: "bindEventListeners",
        value: function bindEventListeners() {
          var _this2 = this, _context2, _context3;
          this.body.emitter.on("_forceDisableDynamicCurves", function(type) {
            var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            if (type === "dynamic") {
              type = "continuous";
            }
            var dataChanged = false;
            for (var edgeId in _this2.body.edges) {
              if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {
                var edge = _this2.body.edges[edgeId];
                var edgeData = _this2.body.data.edges.get(edgeId);
                if (edgeData != null) {
                  var smoothOptions = edgeData.smooth;
                  if (smoothOptions !== void 0) {
                    if (smoothOptions.enabled === true && smoothOptions.type === "dynamic") {
                      if (type === void 0) {
                        edge.setOptions({
                          smooth: false
                        });
                      } else {
                        edge.setOptions({
                          smooth: {
                            type
                          }
                        });
                      }
                      dataChanged = true;
                    }
                  }
                }
              }
            }
            if (emit === true && dataChanged === true) {
              _this2.body.emitter.emit("_dataChanged");
            }
          });
          this.body.emitter.on("_dataUpdated", function() {
            _this2.reconnectEdges();
          });
          this.body.emitter.on("refreshEdges", bind$2(_context2 = this.refresh).call(_context2, this));
          this.body.emitter.on("refresh", bind$2(_context3 = this.refresh).call(_context3, this));
          this.body.emitter.on("destroy", function() {
            forEach$3(_this2.edgesListeners, function(callback, event) {
              if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
            });
            delete _this2.body.functions.createEdge;
            delete _this2.edgesListeners.add;
            delete _this2.edgesListeners.update;
            delete _this2.edgesListeners.remove;
            delete _this2.edgesListeners;
          });
        }
        /**
         *
         * @param {Object} options
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            Edge.parseOptions(this.options, options2, true, this.defaultOptions, true);
            var dataChanged = false;
            if (options2.smooth !== void 0) {
              for (var edgeId in this.body.edges) {
                if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {
                  dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
                }
              }
            }
            if (options2.font !== void 0) {
              for (var _edgeId in this.body.edges) {
                if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {
                  this.body.edges[_edgeId].updateLabelModule();
                }
              }
            }
            if (options2.hidden !== void 0 || options2.physics !== void 0 || dataChanged === true) {
              this.body.emitter.emit("_dataChanged");
            }
          }
        }
        /**
         * Load edges by reading the data table
         * @param {Array | DataSet | DataView} edges    The data containing the edges.
         * @param {boolean} [doNotEmit=false]
         * @private
         */
      }, {
        key: "setData",
        value: function setData(edges) {
          var _this3 = this;
          var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var oldEdgesData = this.body.data.edges;
          if (edges instanceof DataSet || edges instanceof DataView) {
            this.body.data.edges = edges;
          } else if (isArray$5(edges)) {
            this.body.data.edges = new DataSet();
            this.body.data.edges.add(edges);
          } else if (!edges) {
            this.body.data.edges = new DataSet();
          } else {
            throw new TypeError("Array or DataSet expected");
          }
          if (oldEdgesData) {
            forEach$3(this.edgesListeners, function(callback, event) {
              oldEdgesData.off(event, callback);
            });
          }
          this.body.edges = {};
          if (this.body.data.edges) {
            forEach$3(this.edgesListeners, function(callback, event) {
              _this3.body.data.edges.on(event, callback);
            });
            var ids = this.body.data.edges.getIds();
            this.add(ids, true);
          }
          this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
          if (doNotEmit === false) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         * Add edges
         * @param {number[] | string[]} ids
         * @param {boolean} [doNotEmit=false]
         * @private
         */
      }, {
        key: "add",
        value: function add(ids) {
          var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var edges = this.body.edges;
          var edgesData = this.body.data.edges;
          for (var i = 0; i < ids.length; i++) {
            var id2 = ids[i];
            var oldEdge = edges[id2];
            if (oldEdge) {
              oldEdge.disconnect();
            }
            var data2 = edgesData.get(id2, {
              "showInternalIds": true
            });
            edges[id2] = this.create(data2);
          }
          this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
          if (doNotEmit === false) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         * Update existing edges, or create them when not yet existing
         * @param {number[] | string[]} ids
         * @private
         */
      }, {
        key: "update",
        value: function update(ids) {
          var edges = this.body.edges;
          var edgesData = this.body.data.edges;
          var dataChanged = false;
          for (var i = 0; i < ids.length; i++) {
            var id2 = ids[i];
            var data2 = edgesData.get(id2);
            var edge = edges[id2];
            if (edge !== void 0) {
              edge.disconnect();
              dataChanged = edge.setOptions(data2) || dataChanged;
              edge.connect();
            } else {
              this.body.edges[id2] = this.create(data2);
              dataChanged = true;
            }
          }
          if (dataChanged === true) {
            this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
            this.body.emitter.emit("_dataChanged");
          } else {
            this.body.emitter.emit("_dataUpdated");
          }
        }
        /**
         * Remove existing edges. Non existing ids will be ignored
         * @param {number[] | string[]} ids
         * @param {boolean} [emit=true]
         * @private
         */
      }, {
        key: "remove",
        value: function remove(ids) {
          var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (ids.length === 0) return;
          var edges = this.body.edges;
          forEach$3(ids, function(id2) {
            var edge = edges[id2];
            if (edge !== void 0) {
              edge.remove();
            }
          });
          if (emit) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         * Refreshes Edge Handler
         */
      }, {
        key: "refresh",
        value: function refresh() {
          var _this4 = this;
          forEach$3(this.body.edges, function(edge, edgeId) {
            var data2 = _this4.body.data.edges.get(edgeId);
            if (data2 !== void 0) {
              edge.setOptions(data2);
            }
          });
        }
        /**
         *
         * @param {Object} properties
         * @returns {Edge}
         */
      }, {
        key: "create",
        value: function create5(properties) {
          return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);
        }
        /**
         * Reconnect all edges
         * @private
         */
      }, {
        key: "reconnectEdges",
        value: function reconnectEdges() {
          var id2;
          var nodes = this.body.nodes;
          var edges = this.body.edges;
          for (id2 in nodes) {
            if (Object.prototype.hasOwnProperty.call(nodes, id2)) {
              nodes[id2].edges = [];
            }
          }
          for (id2 in edges) {
            if (Object.prototype.hasOwnProperty.call(edges, id2)) {
              var edge = edges[id2];
              edge.from = null;
              edge.to = null;
              edge.connect();
            }
          }
        }
        /**
         *
         * @param {Edge.id} edgeId
         * @returns {Array}
         */
      }, {
        key: "getConnectedNodes",
        value: function getConnectedNodes(edgeId) {
          var nodeList = [];
          if (this.body.edges[edgeId] !== void 0) {
            var edge = this.body.edges[edgeId];
            if (edge.fromId !== void 0) {
              nodeList.push(edge.fromId);
            }
            if (edge.toId !== void 0) {
              nodeList.push(edge.toId);
            }
          }
          return nodeList;
        }
        /**
         * There is no direct relation between the nodes and the edges DataSet,
         * so the right place to do call this is in the handler for event `_dataUpdated`.
         */
      }, {
        key: "_updateState",
        value: function _updateState() {
          this._addMissingEdges();
          this._removeInvalidEdges();
        }
        /**
         * Scan for missing nodes and remove corresponding edges, if any.
         * @private
         */
      }, {
        key: "_removeInvalidEdges",
        value: function _removeInvalidEdges() {
          var _this5 = this;
          var edgesToDelete = [];
          forEach$3(this.body.edges, function(edge, id2) {
            var toNode = _this5.body.nodes[edge.toId];
            var fromNode = _this5.body.nodes[edge.fromId];
            if (toNode !== void 0 && toNode.isCluster === true || fromNode !== void 0 && fromNode.isCluster === true) {
              return;
            }
            if (toNode === void 0 || fromNode === void 0) {
              edgesToDelete.push(id2);
            }
          });
          this.remove(edgesToDelete, false);
        }
        /**
         * add all edges from dataset that are not in the cached state
         * @private
         */
      }, {
        key: "_addMissingEdges",
        value: function _addMissingEdges() {
          var edgesData = this.body.data.edges;
          if (edgesData === void 0 || edgesData === null) {
            return;
          }
          var edges = this.body.edges;
          var addIds = [];
          forEach$2(edgesData).call(edgesData, function(edgeData, edgeId) {
            var edge = edges[edgeId];
            if (edge === void 0) {
              addIds.push(edgeId);
            }
          });
          this.add(addIds, true);
        }
      }]);
      return EdgesHandler2;
    }();
    BarnesHutSolver = function() {
      function BarnesHutSolver2(body, physicsBody, options2) {
        classCallCheck(this, BarnesHutSolver2);
        this.body = body;
        this.physicsBody = physicsBody;
        this.barnesHutTree;
        this.setOptions(options2);
        this._rng = Alea("BARNES HUT SOLVER");
      }
      createClass(BarnesHutSolver2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
          this.thetaInversed = 1 / this.options.theta;
          this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
        }
        /**
         * This function calculates the forces the nodes apply on each other based on a gravitational model.
         * The Barnes Hut method is used to speed up this N-body simulation.
         *
         * @private
         */
      }, {
        key: "solve",
        value: function solve() {
          if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
            var node;
            var nodes = this.body.nodes;
            var nodeIndices = this.physicsBody.physicsNodeIndices;
            var nodeCount = nodeIndices.length;
            var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);
            this.barnesHutTree = barnesHutTree;
            for (var i = 0; i < nodeCount; i++) {
              node = nodes[nodeIndices[i]];
              if (node.options.mass > 0) {
                this._getForceContributions(barnesHutTree.root, node);
              }
            }
          }
        }
        /**
         * @param {Object} parentBranch
         * @param {Node} node
         * @private
         */
      }, {
        key: "_getForceContributions",
        value: function _getForceContributions(parentBranch, node) {
          this._getForceContribution(parentBranch.children.NW, node);
          this._getForceContribution(parentBranch.children.NE, node);
          this._getForceContribution(parentBranch.children.SW, node);
          this._getForceContribution(parentBranch.children.SE, node);
        }
        /**
         * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
         * If a region contains a single node, we check if it is not itself, then we apply the force.
         *
         * @param {Object} parentBranch
         * @param {Node} node
         * @private
         */
      }, {
        key: "_getForceContribution",
        value: function _getForceContribution(parentBranch, node) {
          if (parentBranch.childrenCount > 0) {
            var dx = parentBranch.centerOfMass.x - node.x;
            var dy = parentBranch.centerOfMass.y - node.y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            if (distance * parentBranch.calcSize > this.thetaInversed) {
              this._calculateForces(distance, dx, dy, node, parentBranch);
            } else {
              if (parentBranch.childrenCount === 4) {
                this._getForceContributions(parentBranch, node);
              } else {
                if (parentBranch.children.data.id != node.id) {
                  this._calculateForces(distance, dx, dy, node, parentBranch);
                }
              }
            }
          }
        }
        /**
         * Calculate the forces based on the distance.
         *
         * @param {number} distance
         * @param {number} dx
         * @param {number} dy
         * @param {Node} node
         * @param {Object} parentBranch
         * @private
         */
      }, {
        key: "_calculateForces",
        value: function _calculateForces(distance, dx, dy, node, parentBranch) {
          if (distance === 0) {
            distance = 0.1;
            dx = distance;
          }
          if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
            distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
          }
          var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
          var fx = dx * gravityForce;
          var fy = dy * gravityForce;
          this.physicsBody.forces[node.id].x += fx;
          this.physicsBody.forces[node.id].y += fy;
        }
        /**
         * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
         *
         * @param {Array.<Node>} nodes
         * @param {Array.<number>} nodeIndices
         * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
         * @private
         */
      }, {
        key: "_formBarnesHutTree",
        value: function _formBarnesHutTree(nodes, nodeIndices) {
          var node;
          var nodeCount = nodeIndices.length;
          var minX = nodes[nodeIndices[0]].x;
          var minY = nodes[nodeIndices[0]].y;
          var maxX = nodes[nodeIndices[0]].x;
          var maxY = nodes[nodeIndices[0]].y;
          for (var i = 1; i < nodeCount; i++) {
            var _node = nodes[nodeIndices[i]];
            var x = _node.x;
            var y = _node.y;
            if (_node.options.mass > 0) {
              if (x < minX) {
                minX = x;
              }
              if (x > maxX) {
                maxX = x;
              }
              if (y < minY) {
                minY = y;
              }
              if (y > maxY) {
                maxY = y;
              }
            }
          }
          var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY);
          if (sizeDiff > 0) {
            minY -= 0.5 * sizeDiff;
            maxY += 0.5 * sizeDiff;
          } else {
            minX += 0.5 * sizeDiff;
            maxX -= 0.5 * sizeDiff;
          }
          var minimumTreeSize = 1e-5;
          var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
          var halfRootSize = 0.5 * rootSize;
          var centerX = 0.5 * (minX + maxX), centerY = 0.5 * (minY + maxY);
          var barnesHutTree = {
            root: {
              centerOfMass: {
                x: 0,
                y: 0
              },
              mass: 0,
              range: {
                minX: centerX - halfRootSize,
                maxX: centerX + halfRootSize,
                minY: centerY - halfRootSize,
                maxY: centerY + halfRootSize
              },
              size: rootSize,
              calcSize: 1 / rootSize,
              children: {
                data: null
              },
              maxWidth: 0,
              level: 0,
              childrenCount: 4
            }
          };
          this._splitBranch(barnesHutTree.root);
          for (var _i = 0; _i < nodeCount; _i++) {
            node = nodes[nodeIndices[_i]];
            if (node.options.mass > 0) {
              this._placeInTree(barnesHutTree.root, node);
            }
          }
          return barnesHutTree;
        }
        /**
         * this updates the mass of a branch. this is increased by adding a node.
         *
         * @param {Object} parentBranch
         * @param {Node} node
         * @private
         */
      }, {
        key: "_updateBranchMass",
        value: function _updateBranchMass(parentBranch, node) {
          var centerOfMass = parentBranch.centerOfMass;
          var totalMass = parentBranch.mass + node.options.mass;
          var totalMassInv = 1 / totalMass;
          centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
          centerOfMass.x *= totalMassInv;
          centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
          centerOfMass.y *= totalMassInv;
          parentBranch.mass = totalMass;
          var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
          parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
        }
        /**
         * determine in which branch the node will be placed.
         *
         * @param {Object} parentBranch
         * @param {Node} node
         * @param {boolean} skipMassUpdate
         * @private
         */
      }, {
        key: "_placeInTree",
        value: function _placeInTree(parentBranch, node, skipMassUpdate) {
          if (skipMassUpdate != true || skipMassUpdate === void 0) {
            this._updateBranchMass(parentBranch, node);
          }
          var range = parentBranch.children.NW.range;
          var region;
          if (range.maxX > node.x) {
            if (range.maxY > node.y) {
              region = "NW";
            } else {
              region = "SW";
            }
          } else {
            if (range.maxY > node.y) {
              region = "NE";
            } else {
              region = "SE";
            }
          }
          this._placeInRegion(parentBranch, node, region);
        }
        /**
         * actually place the node in a region (or branch)
         *
         * @param {Object} parentBranch
         * @param {Node} node
         * @param {'NW'| 'NE' | 'SW' | 'SE'} region
         * @private
         */
      }, {
        key: "_placeInRegion",
        value: function _placeInRegion(parentBranch, node, region) {
          var children = parentBranch.children[region];
          switch (children.childrenCount) {
            case 0:
              children.children.data = node;
              children.childrenCount = 1;
              this._updateBranchMass(children, node);
              break;
            case 1:
              if (children.children.data.x === node.x && children.children.data.y === node.y) {
                node.x += this._rng();
                node.y += this._rng();
              } else {
                this._splitBranch(children);
                this._placeInTree(children, node);
              }
              break;
            case 4:
              this._placeInTree(children, node);
              break;
          }
        }
        /**
         * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
         * after the split is complete.
         *
         * @param {Object} parentBranch
         * @private
         */
      }, {
        key: "_splitBranch",
        value: function _splitBranch(parentBranch) {
          var containedNode = null;
          if (parentBranch.childrenCount === 1) {
            containedNode = parentBranch.children.data;
            parentBranch.mass = 0;
            parentBranch.centerOfMass.x = 0;
            parentBranch.centerOfMass.y = 0;
          }
          parentBranch.childrenCount = 4;
          parentBranch.children.data = null;
          this._insertRegion(parentBranch, "NW");
          this._insertRegion(parentBranch, "NE");
          this._insertRegion(parentBranch, "SW");
          this._insertRegion(parentBranch, "SE");
          if (containedNode != null) {
            this._placeInTree(parentBranch, containedNode);
          }
        }
        /**
         * This function subdivides the region into four new segments.
         * Specifically, this inserts a single new segment.
         * It fills the children section of the parentBranch
         *
         * @param {Object} parentBranch
         * @param {'NW'| 'NE' | 'SW' | 'SE'} region
         * @private
         */
      }, {
        key: "_insertRegion",
        value: function _insertRegion(parentBranch, region) {
          var minX, maxX, minY, maxY;
          var childSize = 0.5 * parentBranch.size;
          switch (region) {
            case "NW":
              minX = parentBranch.range.minX;
              maxX = parentBranch.range.minX + childSize;
              minY = parentBranch.range.minY;
              maxY = parentBranch.range.minY + childSize;
              break;
            case "NE":
              minX = parentBranch.range.minX + childSize;
              maxX = parentBranch.range.maxX;
              minY = parentBranch.range.minY;
              maxY = parentBranch.range.minY + childSize;
              break;
            case "SW":
              minX = parentBranch.range.minX;
              maxX = parentBranch.range.minX + childSize;
              minY = parentBranch.range.minY + childSize;
              maxY = parentBranch.range.maxY;
              break;
            case "SE":
              minX = parentBranch.range.minX + childSize;
              maxX = parentBranch.range.maxX;
              minY = parentBranch.range.minY + childSize;
              maxY = parentBranch.range.maxY;
              break;
          }
          parentBranch.children[region] = {
            centerOfMass: {
              x: 0,
              y: 0
            },
            mass: 0,
            range: {
              minX,
              maxX,
              minY,
              maxY
            },
            size: 0.5 * parentBranch.size,
            calcSize: 2 * parentBranch.calcSize,
            children: {
              data: null
            },
            maxWidth: 0,
            level: parentBranch.level + 1,
            childrenCount: 0
          };
        }
        //---------------------------  DEBUGGING BELOW  ---------------------------//
        /**
         * This function is for debugging purposed, it draws the tree.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {string} color
         * @private
         */
      }, {
        key: "_debug",
        value: function _debug(ctx, color) {
          if (this.barnesHutTree !== void 0) {
            ctx.lineWidth = 1;
            this._drawBranch(this.barnesHutTree.root, ctx, color);
          }
        }
        /**
         * This function is for debugging purposes. It draws the branches recursively.
         *
         * @param {Object} branch
         * @param {CanvasRenderingContext2D} ctx
         * @param {string} color
         * @private
         */
      }, {
        key: "_drawBranch",
        value: function _drawBranch(branch, ctx, color) {
          if (color === void 0) {
            color = "#FF0000";
          }
          if (branch.childrenCount === 4) {
            this._drawBranch(branch.children.NW, ctx);
            this._drawBranch(branch.children.NE, ctx);
            this._drawBranch(branch.children.SE, ctx);
            this._drawBranch(branch.children.SW, ctx);
          }
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(branch.range.minX, branch.range.minY);
          ctx.lineTo(branch.range.maxX, branch.range.minY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(branch.range.maxX, branch.range.minY);
          ctx.lineTo(branch.range.maxX, branch.range.maxY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(branch.range.maxX, branch.range.maxY);
          ctx.lineTo(branch.range.minX, branch.range.maxY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(branch.range.minX, branch.range.maxY);
          ctx.lineTo(branch.range.minX, branch.range.minY);
          ctx.stroke();
        }
      }]);
      return BarnesHutSolver2;
    }();
    RepulsionSolver = function() {
      function RepulsionSolver2(body, physicsBody, options2) {
        classCallCheck(this, RepulsionSolver2);
        this._rng = Alea("REPULSION SOLVER");
        this.body = body;
        this.physicsBody = physicsBody;
        this.setOptions(options2);
      }
      createClass(RepulsionSolver2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
        }
        /**
         * Calculate the forces the nodes apply on each other based on a repulsion field.
         * This field is linearly approximated.
         *
         * @private
         */
      }, {
        key: "solve",
        value: function solve() {
          var dx, dy, distance, fx, fy, repulsingForce, node1, node2;
          var nodes = this.body.nodes;
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var forces = this.physicsBody.forces;
          var nodeDistance = this.options.nodeDistance;
          var a = -2 / 3 / nodeDistance;
          var b = 4 / 3;
          for (var i = 0; i < nodeIndices.length - 1; i++) {
            node1 = nodes[nodeIndices[i]];
            for (var j = i + 1; j < nodeIndices.length; j++) {
              node2 = nodes[nodeIndices[j]];
              dx = node2.x - node1.x;
              dy = node2.y - node1.y;
              distance = Math.sqrt(dx * dx + dy * dy);
              if (distance === 0) {
                distance = 0.1 * this._rng();
                dx = distance;
              }
              if (distance < 2 * nodeDistance) {
                if (distance < 0.5 * nodeDistance) {
                  repulsingForce = 1;
                } else {
                  repulsingForce = a * distance + b;
                }
                repulsingForce = repulsingForce / distance;
                fx = dx * repulsingForce;
                fy = dy * repulsingForce;
                forces[node1.id].x -= fx;
                forces[node1.id].y -= fy;
                forces[node2.id].x += fx;
                forces[node2.id].y += fy;
              }
            }
          }
        }
      }]);
      return RepulsionSolver2;
    }();
    HierarchicalRepulsionSolver = function() {
      function HierarchicalRepulsionSolver2(body, physicsBody, options2) {
        classCallCheck(this, HierarchicalRepulsionSolver2);
        this.body = body;
        this.physicsBody = physicsBody;
        this.setOptions(options2);
      }
      createClass(HierarchicalRepulsionSolver2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
          this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));
        }
        /**
         * Calculate the forces the nodes apply on each other based on a repulsion field.
         * This field is linearly approximated.
         *
         * @private
         */
      }, {
        key: "solve",
        value: function solve() {
          var nodes = this.body.nodes;
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var forces = this.physicsBody.forces;
          var nodeDistance = this.options.nodeDistance;
          for (var i = 0; i < nodeIndices.length - 1; i++) {
            var node1 = nodes[nodeIndices[i]];
            for (var j = i + 1; j < nodeIndices.length; j++) {
              var node2 = nodes[nodeIndices[j]];
              if (node1.level === node2.level) {
                var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);
                var dx = node2.x - node1.x;
                var dy = node2.y - node1.y;
                var distance = Math.sqrt(dx * dx + dy * dy);
                var steepness = 0.05;
                var repulsingForce = void 0;
                if (distance < theseNodesDistance) {
                  repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);
                } else {
                  repulsingForce = 0;
                }
                if (distance !== 0) {
                  repulsingForce = repulsingForce / distance;
                }
                var fx = dx * repulsingForce;
                var fy = dy * repulsingForce;
                forces[node1.id].x -= fx;
                forces[node1.id].y -= fy;
                forces[node2.id].x += fx;
                forces[node2.id].y += fy;
              }
            }
          }
        }
      }]);
      return HierarchicalRepulsionSolver2;
    }();
    SpringSolver = function() {
      function SpringSolver2(body, physicsBody, options2) {
        classCallCheck(this, SpringSolver2);
        this.body = body;
        this.physicsBody = physicsBody;
        this.setOptions(options2);
      }
      createClass(SpringSolver2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
        }
        /**
         * This function calculates the springforces on the nodes, accounting for the support nodes.
         *
         * @private
         */
      }, {
        key: "solve",
        value: function solve() {
          var edgeLength, edge;
          var edgeIndices = this.physicsBody.physicsEdgeIndices;
          var edges = this.body.edges;
          var node1, node2, node3;
          for (var i = 0; i < edgeIndices.length; i++) {
            edge = edges[edgeIndices[i]];
            if (edge.connected === true && edge.toId !== edge.fromId) {
              if (this.body.nodes[edge.toId] !== void 0 && this.body.nodes[edge.fromId] !== void 0) {
                if (edge.edgeType.via !== void 0) {
                  edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
                  node1 = edge.to;
                  node2 = edge.edgeType.via;
                  node3 = edge.from;
                  this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
                  this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
                } else {
                  edgeLength = edge.options.length === void 0 ? this.options.springLength * 1.5 : edge.options.length;
                  this._calculateSpringForce(edge.from, edge.to, edgeLength);
                }
              }
            }
          }
        }
        /**
         * This is the code actually performing the calculation for the function above.
         *
         * @param {Node} node1
         * @param {Node} node2
         * @param {number} edgeLength
         * @private
         */
      }, {
        key: "_calculateSpringForce",
        value: function _calculateSpringForce(node1, node2, edgeLength) {
          var dx = node1.x - node2.x;
          var dy = node1.y - node2.y;
          var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);
          var springForce = this.options.springConstant * (edgeLength - distance) / distance;
          var fx = dx * springForce;
          var fy = dy * springForce;
          if (this.physicsBody.forces[node1.id] !== void 0) {
            this.physicsBody.forces[node1.id].x += fx;
            this.physicsBody.forces[node1.id].y += fy;
          }
          if (this.physicsBody.forces[node2.id] !== void 0) {
            this.physicsBody.forces[node2.id].x -= fx;
            this.physicsBody.forces[node2.id].y -= fy;
          }
        }
      }]);
      return SpringSolver2;
    }();
    HierarchicalSpringSolver = function() {
      function HierarchicalSpringSolver2(body, physicsBody, options2) {
        classCallCheck(this, HierarchicalSpringSolver2);
        this.body = body;
        this.physicsBody = physicsBody;
        this.setOptions(options2);
      }
      createClass(HierarchicalSpringSolver2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
        }
        /**
         * This function calculates the springforces on the nodes, accounting for the support nodes.
         *
         * @private
         */
      }, {
        key: "solve",
        value: function solve() {
          var edgeLength, edge;
          var dx, dy, fx, fy, springForce, distance;
          var edges = this.body.edges;
          var factor = 0.5;
          var edgeIndices = this.physicsBody.physicsEdgeIndices;
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var forces = this.physicsBody.forces;
          for (var i = 0; i < nodeIndices.length; i++) {
            var nodeId = nodeIndices[i];
            forces[nodeId].springFx = 0;
            forces[nodeId].springFy = 0;
          }
          for (var _i = 0; _i < edgeIndices.length; _i++) {
            edge = edges[edgeIndices[_i]];
            if (edge.connected === true) {
              edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
              dx = edge.from.x - edge.to.x;
              dy = edge.from.y - edge.to.y;
              distance = Math.sqrt(dx * dx + dy * dy);
              distance = distance === 0 ? 0.01 : distance;
              springForce = this.options.springConstant * (edgeLength - distance) / distance;
              fx = dx * springForce;
              fy = dy * springForce;
              if (edge.to.level != edge.from.level) {
                if (forces[edge.toId] !== void 0) {
                  forces[edge.toId].springFx -= fx;
                  forces[edge.toId].springFy -= fy;
                }
                if (forces[edge.fromId] !== void 0) {
                  forces[edge.fromId].springFx += fx;
                  forces[edge.fromId].springFy += fy;
                }
              } else {
                if (forces[edge.toId] !== void 0) {
                  forces[edge.toId].x -= factor * fx;
                  forces[edge.toId].y -= factor * fy;
                }
                if (forces[edge.fromId] !== void 0) {
                  forces[edge.fromId].x += factor * fx;
                  forces[edge.fromId].y += factor * fy;
                }
              }
            }
          }
          springForce = 1;
          var springFx, springFy;
          for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
            var _nodeId = nodeIndices[_i2];
            springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
            springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));
            forces[_nodeId].x += springFx;
            forces[_nodeId].y += springFy;
          }
          var totalFx = 0;
          var totalFy = 0;
          for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
            var _nodeId2 = nodeIndices[_i3];
            totalFx += forces[_nodeId2].x;
            totalFy += forces[_nodeId2].y;
          }
          var correctionFx = totalFx / nodeIndices.length;
          var correctionFy = totalFy / nodeIndices.length;
          for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
            var _nodeId3 = nodeIndices[_i4];
            forces[_nodeId3].x -= correctionFx;
            forces[_nodeId3].y -= correctionFy;
          }
        }
      }]);
      return HierarchicalSpringSolver2;
    }();
    CentralGravitySolver = function() {
      function CentralGravitySolver2(body, physicsBody, options2) {
        classCallCheck(this, CentralGravitySolver2);
        this.body = body;
        this.physicsBody = physicsBody;
        this.setOptions(options2);
      }
      createClass(CentralGravitySolver2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          this.options = options2;
        }
        /**
         * Calculates forces for each node
         */
      }, {
        key: "solve",
        value: function solve() {
          var dx, dy, distance, node;
          var nodes = this.body.nodes;
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var forces = this.physicsBody.forces;
          for (var i = 0; i < nodeIndices.length; i++) {
            var nodeId = nodeIndices[i];
            node = nodes[nodeId];
            dx = -node.x;
            dy = -node.y;
            distance = Math.sqrt(dx * dx + dy * dy);
            this._calculateForces(distance, dx, dy, forces, node);
          }
        }
        /**
         * Calculate the forces based on the distance.
         * @param {number} distance
         * @param {number} dx
         * @param {number} dy
         * @param {Object<Node.id, vis.Node>} forces
         * @param {Node} node
         * @private
         */
      }, {
        key: "_calculateForces",
        value: function _calculateForces(distance, dx, dy, forces, node) {
          var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
          forces[node.id].x = dx * gravityForce;
          forces[node.id].y = dy * gravityForce;
        }
      }]);
      return CentralGravitySolver2;
    }();
    ForceAtlas2BasedRepulsionSolver = function(_BarnesHutSolver) {
      inherits(ForceAtlas2BasedRepulsionSolver2, _BarnesHutSolver);
      var _super = _createSuper$q(ForceAtlas2BasedRepulsionSolver2);
      function ForceAtlas2BasedRepulsionSolver2(body, physicsBody, options2) {
        var _this;
        classCallCheck(this, ForceAtlas2BasedRepulsionSolver2);
        _this = _super.call(this, body, physicsBody, options2);
        _this._rng = Alea("FORCE ATLAS 2 BASED REPULSION SOLVER");
        return _this;
      }
      createClass(ForceAtlas2BasedRepulsionSolver2, [{
        key: "_calculateForces",
        value: function _calculateForces(distance, dx, dy, node, parentBranch) {
          if (distance === 0) {
            distance = 0.1 * this._rng();
            dx = distance;
          }
          if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
            distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
          }
          var degree = node.edges.length + 1;
          var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
          var fx = dx * gravityForce;
          var fy = dy * gravityForce;
          this.physicsBody.forces[node.id].x += fx;
          this.physicsBody.forces[node.id].y += fy;
        }
      }]);
      return ForceAtlas2BasedRepulsionSolver2;
    }(BarnesHutSolver);
    ForceAtlas2BasedCentralGravitySolver = function(_CentralGravitySolver) {
      inherits(ForceAtlas2BasedCentralGravitySolver2, _CentralGravitySolver);
      var _super = _createSuper$r(ForceAtlas2BasedCentralGravitySolver2);
      function ForceAtlas2BasedCentralGravitySolver2(body, physicsBody, options2) {
        classCallCheck(this, ForceAtlas2BasedCentralGravitySolver2);
        return _super.call(this, body, physicsBody, options2);
      }
      createClass(ForceAtlas2BasedCentralGravitySolver2, [{
        key: "_calculateForces",
        value: function _calculateForces(distance, dx, dy, forces, node) {
          if (distance > 0) {
            var degree = node.edges.length + 1;
            var gravityForce = this.options.centralGravity * degree * node.options.mass;
            forces[node.id].x = dx * gravityForce;
            forces[node.id].y = dy * gravityForce;
          }
        }
      }]);
      return ForceAtlas2BasedCentralGravitySolver2;
    }(CentralGravitySolver);
    PhysicsEngine = function() {
      function PhysicsEngine2(body) {
        classCallCheck(this, PhysicsEngine2);
        this.body = body;
        this.physicsBody = {
          physicsNodeIndices: [],
          physicsEdgeIndices: [],
          forces: {},
          velocities: {}
        };
        this.physicsEnabled = true;
        this.simulationInterval = 1e3 / 60;
        this.requiresTimeout = true;
        this.previousStates = {};
        this.referenceState = {};
        this.freezeCache = {};
        this.renderTimer = void 0;
        this.adaptiveTimestep = false;
        this.adaptiveTimestepEnabled = false;
        this.adaptiveCounter = 0;
        this.adaptiveInterval = 3;
        this.stabilized = false;
        this.startedStabilization = false;
        this.stabilizationIterations = 0;
        this.ready = false;
        this.options = {};
        this.defaultOptions = {
          enabled: true,
          barnesHut: {
            theta: 0.5,
            gravitationalConstant: -2e3,
            centralGravity: 0.3,
            springLength: 95,
            springConstant: 0.04,
            damping: 0.09,
            avoidOverlap: 0
          },
          forceAtlas2Based: {
            theta: 0.5,
            gravitationalConstant: -50,
            centralGravity: 0.01,
            springConstant: 0.08,
            springLength: 100,
            damping: 0.4,
            avoidOverlap: 0
          },
          repulsion: {
            centralGravity: 0.2,
            springLength: 200,
            springConstant: 0.05,
            nodeDistance: 100,
            damping: 0.09,
            avoidOverlap: 0
          },
          hierarchicalRepulsion: {
            centralGravity: 0,
            springLength: 100,
            springConstant: 0.01,
            nodeDistance: 120,
            damping: 0.09
          },
          maxVelocity: 50,
          minVelocity: 0.75,
          // px/s
          solver: "barnesHut",
          stabilization: {
            enabled: true,
            iterations: 1e3,
            // maximum number of iteration to stabilize
            updateInterval: 50,
            onlyDynamicEdges: false,
            fit: true
          },
          timestep: 0.5,
          adaptiveTimestep: true,
          wind: {
            x: 0,
            y: 0
          }
        };
        assign$2(this.options, this.defaultOptions);
        this.timestep = 0.5;
        this.layoutFailed = false;
        this.bindEventListeners();
      }
      createClass(PhysicsEngine2, [{
        key: "bindEventListeners",
        value: function bindEventListeners() {
          var _this = this;
          this.body.emitter.on("initPhysics", function() {
            _this.initPhysics();
          });
          this.body.emitter.on("_layoutFailed", function() {
            _this.layoutFailed = true;
          });
          this.body.emitter.on("resetPhysics", function() {
            _this.stopSimulation();
            _this.ready = false;
          });
          this.body.emitter.on("disablePhysics", function() {
            _this.physicsEnabled = false;
            _this.stopSimulation();
          });
          this.body.emitter.on("restorePhysics", function() {
            _this.setOptions(_this.options);
            if (_this.ready === true) {
              _this.startSimulation();
            }
          });
          this.body.emitter.on("startSimulation", function() {
            if (_this.ready === true) {
              _this.startSimulation();
            }
          });
          this.body.emitter.on("stopSimulation", function() {
            _this.stopSimulation();
          });
          this.body.emitter.on("destroy", function() {
            _this.stopSimulation(false);
            _this.body.emitter.off();
          });
          this.body.emitter.on("_dataChanged", function() {
            _this.updatePhysicsData();
          });
        }
        /**
         * set the physics options
         * @param {Object} options
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            if (options2 === false) {
              this.options.enabled = false;
              this.physicsEnabled = false;
              this.stopSimulation();
            } else if (options2 === true) {
              this.options.enabled = true;
              this.physicsEnabled = true;
              this.startSimulation();
            } else {
              this.physicsEnabled = true;
              selectiveNotDeepExtend(["stabilization"], this.options, options2);
              mergeOptions(this.options, options2, "stabilization");
              if (options2.enabled === void 0) {
                this.options.enabled = true;
              }
              if (this.options.enabled === false) {
                this.physicsEnabled = false;
                this.stopSimulation();
              }
              var wind = this.options.wind;
              if (wind) {
                if (typeof wind.x !== "number" || isNan$2(wind.x)) {
                  wind.x = 0;
                }
                if (typeof wind.y !== "number" || isNan$2(wind.y)) {
                  wind.y = 0;
                }
              }
              this.timestep = this.options.timestep;
            }
          }
          this.init();
        }
        /**
         * configure the engine.
         */
      }, {
        key: "init",
        value: function init() {
          var options2;
          if (this.options.solver === "forceAtlas2Based") {
            options2 = this.options.forceAtlas2Based;
            this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options2);
            this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options2);
            this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options2);
          } else if (this.options.solver === "repulsion") {
            options2 = this.options.repulsion;
            this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options2);
            this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options2);
            this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options2);
          } else if (this.options.solver === "hierarchicalRepulsion") {
            options2 = this.options.hierarchicalRepulsion;
            this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options2);
            this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options2);
            this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options2);
          } else {
            options2 = this.options.barnesHut;
            this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options2);
            this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options2);
            this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options2);
          }
          this.modelOptions = options2;
        }
        /**
         * initialize the engine
         */
      }, {
        key: "initPhysics",
        value: function initPhysics() {
          if (this.physicsEnabled === true && this.options.enabled === true) {
            if (this.options.stabilization.enabled === true) {
              this.stabilize();
            } else {
              this.stabilized = false;
              this.ready = true;
              this.body.emitter.emit("fit", {}, this.layoutFailed);
              this.startSimulation();
            }
          } else {
            this.ready = true;
            this.body.emitter.emit("fit");
          }
        }
        /**
         * Start the simulation
         */
      }, {
        key: "startSimulation",
        value: function startSimulation() {
          if (this.physicsEnabled === true && this.options.enabled === true) {
            this.stabilized = false;
            this.adaptiveTimestep = false;
            this.body.emitter.emit("_resizeNodes");
            if (this.viewFunction === void 0) {
              var _context;
              this.viewFunction = bind$2(_context = this.simulationStep).call(_context, this);
              this.body.emitter.on("initRedraw", this.viewFunction);
              this.body.emitter.emit("_startRendering");
            }
          } else {
            this.body.emitter.emit("_redraw");
          }
        }
        /**
         * Stop the simulation, force stabilization.
         * @param {boolean} [emit=true]
         */
      }, {
        key: "stopSimulation",
        value: function stopSimulation() {
          var emit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          this.stabilized = true;
          if (emit === true) {
            this._emitStabilized();
          }
          if (this.viewFunction !== void 0) {
            this.body.emitter.off("initRedraw", this.viewFunction);
            this.viewFunction = void 0;
            if (emit === true) {
              this.body.emitter.emit("_stopRendering");
            }
          }
        }
        /**
         * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
         *
         */
      }, {
        key: "simulationStep",
        value: function simulationStep() {
          var startTime = now$2();
          this.physicsTick();
          var physicsTime = now$2() - startTime;
          if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
            this.physicsTick();
            this.runDoubleSpeed = true;
          }
          if (this.stabilized === true) {
            this.stopSimulation();
          }
        }
        /**
         * trigger the stabilized event.
         *
         * @param {number} [amountOfIterations=this.stabilizationIterations]
         * @private
         */
      }, {
        key: "_emitStabilized",
        value: function _emitStabilized() {
          var _this2 = this;
          var amountOfIterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.stabilizationIterations;
          if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
            setTimeout$2(function() {
              _this2.body.emitter.emit("stabilized", {
                iterations: amountOfIterations
              });
              _this2.startedStabilization = false;
              _this2.stabilizationIterations = 0;
            }, 0);
          }
        }
        /**
         * Calculate the forces for one physics iteration and move the nodes.
         * @private
         */
      }, {
        key: "physicsStep",
        value: function physicsStep() {
          this.gravitySolver.solve();
          this.nodesSolver.solve();
          this.edgesSolver.solve();
          this.moveNodes();
        }
        /**
         * Make dynamic adjustments to the timestep, based on current state.
         *
         * Helper function for physicsTick().
         * @private
         */
      }, {
        key: "adjustTimeStep",
        value: function adjustTimeStep() {
          var factor = 1.2;
          if (this._evaluateStepQuality() === true) {
            this.timestep = factor * this.timestep;
          } else {
            if (this.timestep / factor < this.options.timestep) {
              this.timestep = this.options.timestep;
            } else {
              this.adaptiveCounter = -1;
              this.timestep = Math.max(this.options.timestep, this.timestep / factor);
            }
          }
        }
        /**
         * A single simulation step (or 'tick') in the physics simulation
         *
         * @private
         */
      }, {
        key: "physicsTick",
        value: function physicsTick() {
          this._startStabilizing();
          if (this.stabilized === true) return;
          if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
            var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;
            if (doAdaptive) {
              this.timestep = 2 * this.timestep;
              this.physicsStep();
              this.revert();
              this.timestep = 0.5 * this.timestep;
              this.physicsStep();
              this.physicsStep();
              this.adjustTimeStep();
            } else {
              this.physicsStep();
            }
            this.adaptiveCounter += 1;
          } else {
            this.timestep = this.options.timestep;
            this.physicsStep();
          }
          if (this.stabilized === true) this.revert();
          this.stabilizationIterations++;
        }
        /**
         * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
         *
         * @private
         */
      }, {
        key: "updatePhysicsData",
        value: function updatePhysicsData() {
          this.physicsBody.forces = {};
          this.physicsBody.physicsNodeIndices = [];
          this.physicsBody.physicsEdgeIndices = [];
          var nodes = this.body.nodes;
          var edges = this.body.edges;
          for (var nodeId in nodes) {
            if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
              if (nodes[nodeId].options.physics === true) {
                this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
              }
            }
          }
          for (var edgeId in edges) {
            if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
              if (edges[edgeId].options.physics === true) {
                this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
              }
            }
          }
          for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
            var _nodeId = this.physicsBody.physicsNodeIndices[i];
            this.physicsBody.forces[_nodeId] = {
              x: 0,
              y: 0
            };
            if (this.physicsBody.velocities[_nodeId] === void 0) {
              this.physicsBody.velocities[_nodeId] = {
                x: 0,
                y: 0
              };
            }
          }
          for (var _nodeId2 in this.physicsBody.velocities) {
            if (nodes[_nodeId2] === void 0) {
              delete this.physicsBody.velocities[_nodeId2];
            }
          }
        }
        /**
         * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
         */
      }, {
        key: "revert",
        value: function revert() {
          var nodeIds = keys$3(this.previousStates);
          var nodes = this.body.nodes;
          var velocities = this.physicsBody.velocities;
          this.referenceState = {};
          for (var i = 0; i < nodeIds.length; i++) {
            var nodeId = nodeIds[i];
            if (nodes[nodeId] !== void 0) {
              if (nodes[nodeId].options.physics === true) {
                this.referenceState[nodeId] = {
                  positions: {
                    x: nodes[nodeId].x,
                    y: nodes[nodeId].y
                  }
                };
                velocities[nodeId].x = this.previousStates[nodeId].vx;
                velocities[nodeId].y = this.previousStates[nodeId].vy;
                nodes[nodeId].x = this.previousStates[nodeId].x;
                nodes[nodeId].y = this.previousStates[nodeId].y;
              }
            } else {
              delete this.previousStates[nodeId];
            }
          }
        }
        /**
         * This compares the reference state to the current state
         *
         * @returns {boolean}
         * @private
         */
      }, {
        key: "_evaluateStepQuality",
        value: function _evaluateStepQuality() {
          var dx, dy, dpos;
          var nodes = this.body.nodes;
          var reference = this.referenceState;
          var posThreshold = 0.3;
          for (var nodeId in this.referenceState) {
            if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== void 0) {
              dx = nodes[nodeId].x - reference[nodeId].positions.x;
              dy = nodes[nodeId].y - reference[nodeId].positions.y;
              dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
              if (dpos > posThreshold) {
                return false;
              }
            }
          }
          return true;
        }
        /**
         * move the nodes one timestep and check if they are stabilized
         */
      }, {
        key: "moveNodes",
        value: function moveNodes() {
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var maxNodeVelocity = 0;
          var averageNodeVelocity = 0;
          var velocityAdaptiveThreshold = 5;
          for (var i = 0; i < nodeIndices.length; i++) {
            var nodeId = nodeIndices[i];
            var nodeVelocity = this._performStep(nodeId);
            maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
            averageNodeVelocity += nodeVelocity;
          }
          this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
          this.stabilized = maxNodeVelocity < this.options.minVelocity;
        }
        /**
         * Calculate new velocity for a coordinate direction
         *
         * @param {number} v  velocity for current coordinate
         * @param {number} f  regular force for current coordinate
         * @param {number} m  mass of current node
         * @returns {number} new velocity for current coordinate
         * @private
         */
      }, {
        key: "calculateComponentVelocity",
        value: function calculateComponentVelocity(v, f2, m) {
          var df = this.modelOptions.damping * v;
          var a = (f2 - df) / m;
          v += a * this.timestep;
          var maxV = this.options.maxVelocity || 1e9;
          if (Math.abs(v) > maxV) {
            v = v > 0 ? maxV : -maxV;
          }
          return v;
        }
        /**
         * Perform the actual step
         *
         * @param {Node.id} nodeId
         * @returns {number} the new velocity of given node
         * @private
         */
      }, {
        key: "_performStep",
        value: function _performStep(nodeId) {
          var node = this.body.nodes[nodeId];
          var force = this.physicsBody.forces[nodeId];
          if (this.options.wind) {
            force.x += this.options.wind.x;
            force.y += this.options.wind.y;
          }
          var velocity = this.physicsBody.velocities[nodeId];
          this.previousStates[nodeId] = {
            x: node.x,
            y: node.y,
            vx: velocity.x,
            vy: velocity.y
          };
          if (node.options.fixed.x === false) {
            velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);
            node.x += velocity.x * this.timestep;
          } else {
            force.x = 0;
            velocity.x = 0;
          }
          if (node.options.fixed.y === false) {
            velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);
            node.y += velocity.y * this.timestep;
          } else {
            force.y = 0;
            velocity.y = 0;
          }
          var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
          return totalVelocity;
        }
        /**
         * When initializing and stabilizing, we can freeze nodes with a predefined position.
         * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
         *
         * @private
         */
      }, {
        key: "_freezeNodes",
        value: function _freezeNodes() {
          var nodes = this.body.nodes;
          for (var id2 in nodes) {
            if (Object.prototype.hasOwnProperty.call(nodes, id2)) {
              if (nodes[id2].x && nodes[id2].y) {
                var fixed = nodes[id2].options.fixed;
                this.freezeCache[id2] = {
                  x: fixed.x,
                  y: fixed.y
                };
                fixed.x = true;
                fixed.y = true;
              }
            }
          }
        }
        /**
         * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
         *
         * @private
         */
      }, {
        key: "_restoreFrozenNodes",
        value: function _restoreFrozenNodes() {
          var nodes = this.body.nodes;
          for (var id2 in nodes) {
            if (Object.prototype.hasOwnProperty.call(nodes, id2)) {
              if (this.freezeCache[id2] !== void 0) {
                nodes[id2].options.fixed.x = this.freezeCache[id2].x;
                nodes[id2].options.fixed.y = this.freezeCache[id2].y;
              }
            }
          }
          this.freezeCache = {};
        }
        /**
         * Find a stable position for all nodes
         *
         * @param {number} [iterations=this.options.stabilization.iterations]
         */
      }, {
        key: "stabilize",
        value: function stabilize() {
          var _this3 = this;
          var iterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.stabilization.iterations;
          if (typeof iterations !== "number") {
            iterations = this.options.stabilization.iterations;
            console.log("The stabilize method needs a numeric amount of iterations. Switching to default: ", iterations);
          }
          if (this.physicsBody.physicsNodeIndices.length === 0) {
            this.ready = true;
            return;
          }
          this.adaptiveTimestep = this.options.adaptiveTimestep;
          this.body.emitter.emit("_resizeNodes");
          this.stopSimulation();
          this.stabilized = false;
          this.body.emitter.emit("_blockRedraw");
          this.targetIterations = iterations;
          if (this.options.stabilization.onlyDynamicEdges === true) {
            this._freezeNodes();
          }
          this.stabilizationIterations = 0;
          setTimeout$2(function() {
            return _this3._stabilizationBatch();
          }, 0);
        }
        /**
         * If not already stabilizing, start it and emit a start event.
         *
         * @returns {boolean} true if stabilization started with this call
         * @private
         */
      }, {
        key: "_startStabilizing",
        value: function _startStabilizing() {
          if (this.startedStabilization === true) return false;
          this.body.emitter.emit("startStabilizing");
          this.startedStabilization = true;
          return true;
        }
        /**
         * One batch of stabilization
         * @private
         */
      }, {
        key: "_stabilizationBatch",
        value: function _stabilizationBatch() {
          var _this4 = this;
          var running = function running2() {
            return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
          };
          var sendProgress = function sendProgress2() {
            _this4.body.emitter.emit("stabilizationProgress", {
              iterations: _this4.stabilizationIterations,
              total: _this4.targetIterations
            });
          };
          if (this._startStabilizing()) {
            sendProgress();
          }
          var count = 0;
          while (running() && count < this.options.stabilization.updateInterval) {
            this.physicsTick();
            count++;
          }
          sendProgress();
          if (running()) {
            var _context2;
            setTimeout$2(bind$2(_context2 = this._stabilizationBatch).call(_context2, this), 0);
          } else {
            this._finalizeStabilization();
          }
        }
        /**
         * Wrap up the stabilization, fit and emit the events.
         * @private
         */
      }, {
        key: "_finalizeStabilization",
        value: function _finalizeStabilization() {
          this.body.emitter.emit("_allowRedraw");
          if (this.options.stabilization.fit === true) {
            this.body.emitter.emit("fit");
          }
          if (this.options.stabilization.onlyDynamicEdges === true) {
            this._restoreFrozenNodes();
          }
          this.body.emitter.emit("stabilizationIterationsDone");
          this.body.emitter.emit("_requestRedraw");
          if (this.stabilized === true) {
            this._emitStabilized();
          } else {
            this.startSimulation();
          }
          this.ready = true;
        }
        //---------------------------  DEBUGGING BELOW  ---------------------------//
        /**
         * Debug function that display arrows for the forces currently active in the network.
         *
         * Use this when debugging only.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @private
         */
      }, {
        key: "_drawForces",
        value: function _drawForces(ctx) {
          for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
            var index2 = this.physicsBody.physicsNodeIndices[i];
            var node = this.body.nodes[index2];
            var force = this.physicsBody.forces[index2];
            var factor = 20;
            var colorFactor = 0.03;
            var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));
            var size = Math.min(Math.max(5, forceSize), 15);
            var arrowSize = 3 * size;
            var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);
            var point = {
              x: node.x + factor * force.x,
              y: node.y + factor * force.y
            };
            ctx.lineWidth = size;
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(node.x, node.y);
            ctx.lineTo(point.x, point.y);
            ctx.stroke();
            var angle = Math.atan2(force.y, force.x);
            ctx.fillStyle = color;
            EndPoints.draw(ctx, {
              type: "arrow",
              point,
              angle,
              length: arrowSize
            });
            fill$2(ctx).call(ctx);
          }
        }
      }]);
      return PhysicsEngine2;
    }();
    nativeReverse = [].reverse;
    test$2 = [1, 2];
    _export({
      target: "Array",
      proto: true,
      forced: String(test$2) === String(test$2.reverse())
    }, {
      reverse: function reverse() {
        if (isArray(this)) this.length = this.length;
        return nativeReverse.call(this);
      }
    });
    reverse2 = entryVirtual("Array").reverse;
    ArrayPrototype$h = Array.prototype;
    reverse_1 = function(it2) {
      var own = it2.reverse;
      return it2 === ArrayPrototype$h || it2 instanceof Array && own === ArrayPrototype$h.reverse ? reverse2 : own;
    };
    reverse$1 = reverse_1;
    reverse$2 = reverse$1;
    NetworkUtil = function() {
      function NetworkUtil2() {
        classCallCheck(this, NetworkUtil2);
      }
      createClass(NetworkUtil2, null, [{
        key: "getRange",
        value: function getRange(allNodes) {
          var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;
          if (specificNodes.length > 0) {
            for (var i = 0; i < specificNodes.length; i++) {
              node = allNodes[specificNodes[i]];
              if (minX > node.shape.boundingBox.left) {
                minX = node.shape.boundingBox.left;
              }
              if (maxX < node.shape.boundingBox.right) {
                maxX = node.shape.boundingBox.right;
              }
              if (minY > node.shape.boundingBox.top) {
                minY = node.shape.boundingBox.top;
              }
              if (maxY < node.shape.boundingBox.bottom) {
                maxY = node.shape.boundingBox.bottom;
              }
            }
          }
          if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
            minY = 0, maxY = 0, minX = 0, maxX = 0;
          }
          return {
            minX,
            maxX,
            minY,
            maxY
          };
        }
        /**
         * Find the center position of the network
         *
         * @param {Array.<Node>} allNodes
         * @param {Array.<Node>} [specificNodes=[]]
         * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
         * @static
         */
      }, {
        key: "getRangeCore",
        value: function getRangeCore(allNodes) {
          var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;
          if (specificNodes.length > 0) {
            for (var i = 0; i < specificNodes.length; i++) {
              node = allNodes[specificNodes[i]];
              if (minX > node.x) {
                minX = node.x;
              }
              if (maxX < node.x) {
                maxX = node.x;
              }
              if (minY > node.y) {
                minY = node.y;
              }
              if (maxY < node.y) {
                maxY = node.y;
              }
            }
          }
          if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
            minY = 0, maxY = 0, minX = 0, maxX = 0;
          }
          return {
            minX,
            maxX,
            minY,
            maxY
          };
        }
        /**
         * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
         * @returns {{x: number, y: number}}
         * @static
         */
      }, {
        key: "findCenter",
        value: function findCenter(range) {
          return {
            x: 0.5 * (range.maxX + range.minX),
            y: 0.5 * (range.maxY + range.minY)
          };
        }
        /**
         * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
         * @param {vis.Item} item
         * @param {'node'|undefined} type
         * @returns {{}}
         * @static
         */
      }, {
        key: "cloneOptions",
        value: function cloneOptions(item, type) {
          var clonedOptions = {};
          if (type === void 0 || type === "node") {
            deepExtend(clonedOptions, item.options, true);
            clonedOptions.x = item.x;
            clonedOptions.y = item.y;
            clonedOptions.amountOfConnections = item.edges.length;
          } else {
            deepExtend(clonedOptions, item.options, true);
          }
          return clonedOptions;
        }
      }]);
      return NetworkUtil2;
    }();
    Cluster = function(_Node) {
      inherits(Cluster2, _Node);
      var _super = _createSuper$s(Cluster2);
      function Cluster2(options2, body, imagelist, grouplist, globalOptions, defaultOptions) {
        var _this;
        classCallCheck(this, Cluster2);
        _this = _super.call(this, options2, body, imagelist, grouplist, globalOptions, defaultOptions);
        _this.isCluster = true;
        _this.containedNodes = {};
        _this.containedEdges = {};
        return _this;
      }
      createClass(Cluster2, [{
        key: "_openChildCluster",
        value: function _openChildCluster(childClusterId) {
          var _this2 = this;
          var childCluster = this.body.nodes[childClusterId];
          if (this.containedNodes[childClusterId] === void 0) {
            throw new Error("node with id: " + childClusterId + " not in current cluster");
          }
          if (!childCluster.isCluster) {
            throw new Error("node with id: " + childClusterId + " is not a cluster");
          }
          delete this.containedNodes[childClusterId];
          forEach$3(childCluster.edges, function(edge) {
            delete _this2.containedEdges[edge.id];
          });
          forEach$3(childCluster.containedNodes, function(node, nodeId) {
            _this2.containedNodes[nodeId] = node;
          });
          childCluster.containedNodes = {};
          forEach$3(childCluster.containedEdges, function(edge, edgeId) {
            _this2.containedEdges[edgeId] = edge;
          });
          childCluster.containedEdges = {};
          forEach$3(childCluster.edges, function(clusterEdge) {
            forEach$3(_this2.edges, function(parentClusterEdge) {
              var _context, _context2;
              var index2 = indexOf$3(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);
              if (index2 === -1) return;
              forEach$3(clusterEdge.clusteringEdgeReplacingIds, function(srcId) {
                parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);
                _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
              });
              splice$2(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index2, 1);
            });
          });
          childCluster.edges = [];
        }
      }]);
      return Cluster2;
    }(Node);
    ClusterEngine = function() {
      function ClusterEngine2(body) {
        var _this = this;
        classCallCheck(this, ClusterEngine2);
        this.body = body;
        this.clusteredNodes = {};
        this.clusteredEdges = {};
        this.options = {};
        this.defaultOptions = {};
        assign$2(this.options, this.defaultOptions);
        this.body.emitter.on("_resetData", function() {
          _this.clusteredNodes = {};
          _this.clusteredEdges = {};
        });
      }
      createClass(ClusterEngine2, [{
        key: "clusterByHubsize",
        value: function clusterByHubsize(hubsize, options2) {
          if (hubsize === void 0) {
            hubsize = this._getHubSize();
          } else if (_typeof_1(hubsize) === "object") {
            options2 = this._checkOptions(hubsize);
            hubsize = this._getHubSize();
          }
          var nodesToCluster = [];
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (node.edges.length >= hubsize) {
              nodesToCluster.push(node.id);
            }
          }
          for (var _i = 0; _i < nodesToCluster.length; _i++) {
            this.clusterByConnection(nodesToCluster[_i], options2, true);
          }
          this.body.emitter.emit("_dataChanged");
        }
        /**
         * loop over all nodes, check if they adhere to the condition and cluster if needed.
         * @param {Object} options
         * @param {boolean} [refreshData=true]
         */
      }, {
        key: "cluster",
        value: function cluster() {
          var _this2 = this;
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (options2.joinCondition === void 0) {
            throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
          }
          options2 = this._checkOptions(options2);
          var childNodesObj = {};
          var childEdgesObj = {};
          forEach$3(this.body.nodes, function(node, nodeId) {
            if (node.options && options2.joinCondition(node.options) === true) {
              childNodesObj[nodeId] = node;
              forEach$3(node.edges, function(edge) {
                if (_this2.clusteredEdges[edge.id] === void 0) {
                  childEdgesObj[edge.id] = edge;
                }
              });
            }
          });
          this._cluster(childNodesObj, childEdgesObj, options2, refreshData);
        }
        /**
         * Cluster all nodes in the network that have only X edges
         * @param {number} edgeCount
         * @param {Object} options
         * @param {boolean} [refreshData=true]
         */
      }, {
        key: "clusterByEdgeCount",
        value: function clusterByEdgeCount(edgeCount, options2) {
          var _this3 = this;
          var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
          options2 = this._checkOptions(options2);
          var clusters = [];
          var usedNodes = {};
          var edge, edges, relevantEdgeCount;
          var _loop = function _loop2(i2) {
            var childNodesObj = {};
            var childEdgesObj = {};
            var nodeId = _this3.body.nodeIndices[i2];
            var node = _this3.body.nodes[nodeId];
            if (usedNodes[nodeId] === void 0) {
              relevantEdgeCount = 0;
              edges = [];
              for (var j = 0; j < node.edges.length; j++) {
                edge = node.edges[j];
                if (_this3.clusteredEdges[edge.id] === void 0) {
                  if (edge.toId !== edge.fromId) {
                    relevantEdgeCount++;
                  }
                  edges.push(edge);
                }
              }
              if (relevantEdgeCount === edgeCount) {
                var checkJoinCondition = function checkJoinCondition2(node2) {
                  if (options2.joinCondition === void 0 || options2.joinCondition === null) {
                    return true;
                  }
                  var clonedOptions = NetworkUtil.cloneOptions(node2);
                  return options2.joinCondition(clonedOptions);
                };
                var gatheringSuccessful = true;
                for (var _j = 0; _j < edges.length; _j++) {
                  edge = edges[_j];
                  var childNodeId = _this3._getConnectedId(edge, nodeId);
                  if (checkJoinCondition(node)) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[nodeId] = node;
                    childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                    usedNodes[nodeId] = true;
                  } else {
                    gatheringSuccessful = false;
                    break;
                  }
                }
                if (keys$3(childNodesObj).length > 0 && keys$3(childEdgesObj).length > 0 && gatheringSuccessful === true) {
                  var findClusterData = function findClusterData2() {
                    for (var n = 0; n < clusters.length; ++n) {
                      for (var m2 in childNodesObj) {
                        if (clusters[n].nodes[m2] !== void 0) {
                          return clusters[n];
                        }
                      }
                    }
                    return void 0;
                  };
                  var foundCluster = findClusterData();
                  if (foundCluster !== void 0) {
                    for (var m in childNodesObj) {
                      if (foundCluster.nodes[m] === void 0) {
                        foundCluster.nodes[m] = childNodesObj[m];
                      }
                    }
                    for (var _m in childEdgesObj) {
                      if (foundCluster.edges[_m] === void 0) {
                        foundCluster.edges[_m] = childEdgesObj[_m];
                      }
                    }
                  } else {
                    clusters.push({
                      nodes: childNodesObj,
                      edges: childEdgesObj
                    });
                  }
                }
              }
            }
          };
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            _loop(i);
          }
          for (var _i2 = 0; _i2 < clusters.length; _i2++) {
            this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options2, false);
          }
          if (refreshData === true) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         * Cluster all nodes in the network that have only 1 edge
         * @param {Object} options
         * @param {boolean} [refreshData=true]
         */
      }, {
        key: "clusterOutliers",
        value: function clusterOutliers(options2) {
          var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          this.clusterByEdgeCount(1, options2, refreshData);
        }
        /**
         * Cluster all nodes in the network that have only 2 edge
         * @param {Object} options
         * @param {boolean} [refreshData=true]
         */
      }, {
        key: "clusterBridges",
        value: function clusterBridges(options2) {
          var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          this.clusterByEdgeCount(2, options2, refreshData);
        }
        /**
        * suck all connected nodes of a node into the node.
        * @param {Node.id} nodeId
        * @param {Object} options
        * @param {boolean} [refreshData=true]
        */
      }, {
        key: "clusterByConnection",
        value: function clusterByConnection(nodeId, options2) {
          var _context;
          var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
          if (nodeId === void 0) {
            throw new Error("No nodeId supplied to clusterByConnection!");
          }
          if (this.body.nodes[nodeId] === void 0) {
            throw new Error("The nodeId given to clusterByConnection does not exist!");
          }
          var node = this.body.nodes[nodeId];
          options2 = this._checkOptions(options2, node);
          if (options2.clusterNodeProperties.x === void 0) {
            options2.clusterNodeProperties.x = node.x;
          }
          if (options2.clusterNodeProperties.y === void 0) {
            options2.clusterNodeProperties.y = node.y;
          }
          if (options2.clusterNodeProperties.fixed === void 0) {
            options2.clusterNodeProperties.fixed = {};
            options2.clusterNodeProperties.fixed.x = node.options.fixed.x;
            options2.clusterNodeProperties.fixed.y = node.options.fixed.y;
          }
          var childNodesObj = {};
          var childEdgesObj = {};
          var parentNodeId = node.id;
          var parentClonedOptions = NetworkUtil.cloneOptions(node);
          childNodesObj[parentNodeId] = node;
          for (var i = 0; i < node.edges.length; i++) {
            var edge = node.edges[i];
            if (this.clusteredEdges[edge.id] === void 0) {
              var childNodeId = this._getConnectedId(edge, parentNodeId);
              if (this.clusteredNodes[childNodeId] === void 0) {
                if (childNodeId !== parentNodeId) {
                  if (options2.joinCondition === void 0) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                  } else {
                    var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);
                    if (options2.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                      childEdgesObj[edge.id] = edge;
                      childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                    }
                  }
                } else {
                  childEdgesObj[edge.id] = edge;
                }
              }
            }
          }
          var childNodeIDs = map$2(_context = keys$3(childNodesObj)).call(_context, function(childNode2) {
            return childNodesObj[childNode2].id;
          });
          for (var childNodeKey in childNodesObj) {
            if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey)) continue;
            var childNode = childNodesObj[childNodeKey];
            for (var y = 0; y < childNode.edges.length; y++) {
              var childEdge = childNode.edges[y];
              if (indexOf$3(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {
                childEdgesObj[childEdge.id] = childEdge;
              }
            }
          }
          this._cluster(childNodesObj, childEdgesObj, options2, refreshData);
        }
        /**
        * This function creates the edges that will be attached to the cluster
        * It looks for edges that are connected to the nodes from the "outside' of the cluster.
        *
        * @param {{Node.id: vis.Node}} childNodesObj
        * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
        * @param {Object} clusterNodeProperties
        * @param {Object} clusterEdgeProperties
        * @private
        */
      }, {
        key: "_createClusterEdges",
        value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
          var edge, childNodeId, childNode, toId, fromId, otherNodeId;
          var childKeys = keys$3(childNodesObj);
          var createEdges = [];
          for (var i = 0; i < childKeys.length; i++) {
            childNodeId = childKeys[i];
            childNode = childNodesObj[childNodeId];
            for (var j = 0; j < childNode.edges.length; j++) {
              edge = childNode.edges[j];
              if (this.clusteredEdges[edge.id] === void 0) {
                if (edge.toId == edge.fromId) {
                  childEdgesObj[edge.id] = edge;
                } else {
                  if (edge.toId == childNodeId) {
                    toId = clusterNodeProperties.id;
                    fromId = edge.fromId;
                    otherNodeId = fromId;
                  } else {
                    toId = edge.toId;
                    fromId = clusterNodeProperties.id;
                    otherNodeId = toId;
                  }
                }
                if (childNodesObj[otherNodeId] === void 0) {
                  createEdges.push({
                    edge,
                    fromId,
                    toId
                  });
                }
              }
            }
          }
          var newEdges = [];
          var getNewEdge = function getNewEdge2(createdEdge2) {
            for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
              var newEdge2 = newEdges[_j2];
              var matchToDirection = createdEdge2.fromId === newEdge2.fromId && createdEdge2.toId === newEdge2.toId;
              var matchFromDirection = createdEdge2.fromId === newEdge2.toId && createdEdge2.toId === newEdge2.fromId;
              if (matchToDirection || matchFromDirection) {
                return newEdge2;
              }
            }
            return null;
          };
          for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
            var createdEdge = createEdges[_j3];
            var _edge = createdEdge.edge;
            var newEdge = getNewEdge(createdEdge);
            if (newEdge === null) {
              newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);
              newEdges.push(newEdge);
            } else {
              newEdge.clusteringEdgeReplacingIds.push(_edge.id);
            }
            this.body.edges[_edge.id].edgeReplacedById = newEdge.id;
            this._backupEdgeOptions(_edge);
            _edge.setOptions({
              physics: false
            });
          }
        }
        /**
        * This function checks the options that can be supplied to the different cluster functions
        * for certain fields and inserts defaults if needed
        * @param {Object} options
        * @returns {*}
        * @private
        */
      }, {
        key: "_checkOptions",
        value: function _checkOptions() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (options2.clusterEdgeProperties === void 0) {
            options2.clusterEdgeProperties = {};
          }
          if (options2.clusterNodeProperties === void 0) {
            options2.clusterNodeProperties = {};
          }
          return options2;
        }
        /**
        *
        * @param {Object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
        * @param {Object}    childEdgesObj         | object with edge objects, id as keys
        * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
        * @param {boolean}   refreshData | when true, do not wrap up
        * @private
        */
      }, {
        key: "_cluster",
        value: function _cluster(childNodesObj, childEdgesObj, options2) {
          var refreshData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
          var tmpNodesToRemove = [];
          for (var nodeId in childNodesObj) {
            if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {
              if (this.clusteredNodes[nodeId] !== void 0) {
                tmpNodesToRemove.push(nodeId);
              }
            }
          }
          for (var n = 0; n < tmpNodesToRemove.length; ++n) {
            delete childNodesObj[tmpNodesToRemove[n]];
          }
          if (keys$3(childNodesObj).length == 0) {
            return;
          }
          if (keys$3(childNodesObj).length == 1 && options2.clusterNodeProperties.allowSingleNodeCluster != true) {
            return;
          }
          var clusterNodeProperties = deepExtend({}, options2.clusterNodeProperties);
          if (options2.processProperties !== void 0) {
            var childNodesOptions = [];
            for (var _nodeId in childNodesObj) {
              if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {
                var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);
                childNodesOptions.push(clonedOptions);
              }
            }
            var childEdgesOptions = [];
            for (var edgeId in childEdgesObj) {
              if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {
                if (edgeId.substr(0, 12) !== "clusterEdge:") {
                  var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], "edge");
                  childEdgesOptions.push(_clonedOptions);
                }
              }
            }
            clusterNodeProperties = options2.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
            if (!clusterNodeProperties) {
              throw new Error("The processProperties function does not return properties!");
            }
          }
          if (clusterNodeProperties.id === void 0) {
            clusterNodeProperties.id = "cluster:" + v4();
          }
          var clusterId = clusterNodeProperties.id;
          if (clusterNodeProperties.label === void 0) {
            clusterNodeProperties.label = "cluster";
          }
          var pos = void 0;
          if (clusterNodeProperties.x === void 0) {
            pos = this._getClusterPosition(childNodesObj);
            clusterNodeProperties.x = pos.x;
          }
          if (clusterNodeProperties.y === void 0) {
            if (pos === void 0) {
              pos = this._getClusterPosition(childNodesObj);
            }
            clusterNodeProperties.y = pos.y;
          }
          clusterNodeProperties.id = clusterId;
          var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
          clusterNode.containedNodes = childNodesObj;
          clusterNode.containedEdges = childEdgesObj;
          clusterNode.clusterEdgeProperties = options2.clusterEdgeProperties;
          this.body.nodes[clusterNodeProperties.id] = clusterNode;
          this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options2.clusterEdgeProperties);
          clusterNodeProperties.id = void 0;
          if (refreshData === true) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         *
         * @param {Edge} edge
         * @private
         */
      }, {
        key: "_backupEdgeOptions",
        value: function _backupEdgeOptions(edge) {
          if (this.clusteredEdges[edge.id] === void 0) {
            this.clusteredEdges[edge.id] = {
              physics: edge.options.physics
            };
          }
        }
        /**
         *
         * @param {Edge} edge
         * @private
         */
      }, {
        key: "_restoreEdge",
        value: function _restoreEdge(edge) {
          var originalOptions = this.clusteredEdges[edge.id];
          if (originalOptions !== void 0) {
            edge.setOptions({
              physics: originalOptions.physics
            });
            delete this.clusteredEdges[edge.id];
          }
        }
        /**
        * Check if a node is a cluster.
        * @param {Node.id} nodeId
        * @returns {*}
        */
      }, {
        key: "isCluster",
        value: function isCluster(nodeId) {
          if (this.body.nodes[nodeId] !== void 0) {
            return this.body.nodes[nodeId].isCluster === true;
          } else {
            console.log("Node does not exist.");
            return false;
          }
        }
        /**
        * get the position of the cluster node based on what's inside
        * @param {object} childNodesObj    | object with node objects, id as keys
        * @returns {{x: number, y: number}}
        * @private
        */
      }, {
        key: "_getClusterPosition",
        value: function _getClusterPosition(childNodesObj) {
          var childKeys = keys$3(childNodesObj);
          var minX = childNodesObj[childKeys[0]].x;
          var maxX = childNodesObj[childKeys[0]].x;
          var minY = childNodesObj[childKeys[0]].y;
          var maxY = childNodesObj[childKeys[0]].y;
          var node;
          for (var i = 1; i < childKeys.length; i++) {
            node = childNodesObj[childKeys[i]];
            minX = node.x < minX ? node.x : minX;
            maxX = node.x > maxX ? node.x : maxX;
            minY = node.y < minY ? node.y : minY;
            maxY = node.y > maxY ? node.y : maxY;
          }
          return {
            x: 0.5 * (minX + maxX),
            y: 0.5 * (minY + maxY)
          };
        }
        /**
         * Open a cluster by calling this function.
         * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
         * @param {Object} options
         * @param {boolean} refreshData | wrap up afterwards if not true
         */
      }, {
        key: "openCluster",
        value: function openCluster(clusterNodeId, options2) {
          var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
          if (clusterNodeId === void 0) {
            throw new Error("No clusterNodeId supplied to openCluster.");
          }
          var clusterNode = this.body.nodes[clusterNodeId];
          if (clusterNode === void 0) {
            throw new Error("The clusterNodeId supplied to openCluster does not exist.");
          }
          if (clusterNode.isCluster !== true || clusterNode.containedNodes === void 0 || clusterNode.containedEdges === void 0) {
            throw new Error("The node:" + clusterNodeId + " is not a valid cluster.");
          }
          var stack = this.findNode(clusterNodeId);
          var parentIndex = indexOf$3(stack).call(stack, clusterNodeId) - 1;
          if (parentIndex >= 0) {
            var parentClusterNodeId = stack[parentIndex];
            var parentClusterNode = this.body.nodes[parentClusterNodeId];
            parentClusterNode._openChildCluster(clusterNodeId);
            delete this.body.nodes[clusterNodeId];
            if (refreshData === true) {
              this.body.emitter.emit("_dataChanged");
            }
            return;
          }
          var containedNodes = clusterNode.containedNodes;
          var containedEdges = clusterNode.containedEdges;
          if (options2 !== void 0 && options2.releaseFunction !== void 0 && typeof options2.releaseFunction === "function") {
            var positions = {};
            var clusterPosition = {
              x: clusterNode.x,
              y: clusterNode.y
            };
            for (var nodeId in containedNodes) {
              if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
                var containedNode = this.body.nodes[nodeId];
                positions[nodeId] = {
                  x: containedNode.x,
                  y: containedNode.y
                };
              }
            }
            var newPositions = options2.releaseFunction(clusterPosition, positions);
            for (var _nodeId2 in containedNodes) {
              if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {
                var _containedNode = this.body.nodes[_nodeId2];
                if (newPositions[_nodeId2] !== void 0) {
                  _containedNode.x = newPositions[_nodeId2].x === void 0 ? clusterNode.x : newPositions[_nodeId2].x;
                  _containedNode.y = newPositions[_nodeId2].y === void 0 ? clusterNode.y : newPositions[_nodeId2].y;
                }
              }
            }
          } else {
            forEach$3(containedNodes, function(containedNode2) {
              if (containedNode2.options.fixed.x === false) {
                containedNode2.x = clusterNode.x;
              }
              if (containedNode2.options.fixed.y === false) {
                containedNode2.y = clusterNode.y;
              }
            });
          }
          for (var _nodeId3 in containedNodes) {
            if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {
              var _containedNode2 = this.body.nodes[_nodeId3];
              _containedNode2.vx = clusterNode.vx;
              _containedNode2.vy = clusterNode.vy;
              _containedNode2.setOptions({
                physics: true
              });
              delete this.clusteredNodes[_nodeId3];
            }
          }
          var edgesToBeDeleted = [];
          for (var i = 0; i < clusterNode.edges.length; i++) {
            edgesToBeDeleted.push(clusterNode.edges[i]);
          }
          for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {
            var edge = edgesToBeDeleted[_i3];
            var otherNodeId = this._getConnectedId(edge, clusterNodeId);
            var otherNode = this.clusteredNodes[otherNodeId];
            for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {
              var transferId = edge.clusteringEdgeReplacingIds[j];
              var transferEdge = this.body.edges[transferId];
              if (transferEdge === void 0) continue;
              if (otherNode !== void 0) {
                var otherCluster = this.body.nodes[otherNode.clusterId];
                otherCluster.containedEdges[transferEdge.id] = transferEdge;
                delete containedEdges[transferEdge.id];
                var fromId = transferEdge.fromId;
                var toId = transferEdge.toId;
                if (transferEdge.toId == otherNodeId) {
                  toId = otherNode.clusterId;
                } else {
                  fromId = otherNode.clusterId;
                }
                this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {
                  hidden: false,
                  physics: true
                });
              } else {
                this._restoreEdge(transferEdge);
              }
            }
            edge.remove();
          }
          for (var edgeId in containedEdges) {
            if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {
              this._restoreEdge(containedEdges[edgeId]);
            }
          }
          delete this.body.nodes[clusterNodeId];
          if (refreshData === true) {
            this.body.emitter.emit("_dataChanged");
          }
        }
        /**
         *
         * @param {Cluster.id} clusterId
         * @returns {Array.<Node.id>}
         */
      }, {
        key: "getNodesInCluster",
        value: function getNodesInCluster(clusterId) {
          var nodesArray = [];
          if (this.isCluster(clusterId) === true) {
            var containedNodes = this.body.nodes[clusterId].containedNodes;
            for (var nodeId in containedNodes) {
              if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
                nodesArray.push(this.body.nodes[nodeId].id);
              }
            }
          }
          return nodesArray;
        }
        /**
        * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
        *
        * If a node can't be found in the chain, return an empty array.
        *
        * @param {string|number} nodeId
        * @returns {Array}
        */
      }, {
        key: "findNode",
        value: function findNode(nodeId) {
          var stack = [];
          var max2 = 100;
          var counter = 0;
          var node;
          while (this.clusteredNodes[nodeId] !== void 0 && counter < max2) {
            node = this.body.nodes[nodeId];
            if (node === void 0) return [];
            stack.push(node.id);
            nodeId = this.clusteredNodes[nodeId].clusterId;
            counter++;
          }
          node = this.body.nodes[nodeId];
          if (node === void 0) return [];
          stack.push(node.id);
          reverse$2(stack).call(stack);
          return stack;
        }
        /**
        * Using a clustered nodeId, update with the new options
        * @param {Node.id} clusteredNodeId
        * @param {object} newOptions
        */
      }, {
        key: "updateClusteredNode",
        value: function updateClusteredNode(clusteredNodeId, newOptions) {
          if (clusteredNodeId === void 0) {
            throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
          }
          if (newOptions === void 0) {
            throw new Error("No newOptions supplied to updateClusteredNode.");
          }
          if (this.body.nodes[clusteredNodeId] === void 0) {
            throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
          }
          this.body.nodes[clusteredNodeId].setOptions(newOptions);
          this.body.emitter.emit("_dataChanged");
        }
        /**
        * Using a base edgeId, update all related clustered edges with the new options
        * @param {vis.Edge.id} startEdgeId
        * @param {object} newOptions
        */
      }, {
        key: "updateEdge",
        value: function updateEdge(startEdgeId, newOptions) {
          if (startEdgeId === void 0) {
            throw new Error("No startEdgeId supplied to updateEdge.");
          }
          if (newOptions === void 0) {
            throw new Error("No newOptions supplied to updateEdge.");
          }
          if (this.body.edges[startEdgeId] === void 0) {
            throw new Error("The startEdgeId supplied to updateEdge does not exist.");
          }
          var allEdgeIds = this.getClusteredEdges(startEdgeId);
          for (var i = 0; i < allEdgeIds.length; i++) {
            var edge = this.body.edges[allEdgeIds[i]];
            edge.setOptions(newOptions);
          }
          this.body.emitter.emit("_dataChanged");
        }
        /**
        * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
        * @param {vis.Edge.id} edgeId
        * @returns {Array.<vis.Edge.id>}
        */
      }, {
        key: "getClusteredEdges",
        value: function getClusteredEdges(edgeId) {
          var stack = [];
          var max2 = 100;
          var counter = 0;
          while (edgeId !== void 0 && this.body.edges[edgeId] !== void 0 && counter < max2) {
            stack.push(this.body.edges[edgeId].id);
            edgeId = this.body.edges[edgeId].edgeReplacedById;
            counter++;
          }
          reverse$2(stack).call(stack);
          return stack;
        }
        /**
        * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
        * @param {vis.Edge.id} clusteredEdgeId
        * @returns {vis.Edge.id} baseEdgeId
        *
        * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
        */
      }, {
        key: "getBaseEdge",
        value: function getBaseEdge(clusteredEdgeId) {
          return this.getBaseEdges(clusteredEdgeId)[0];
        }
        /**
         * Get all regular edges for this clustered edge id.
         *
         * @param {vis.Edge.id} clusteredEdgeId
         * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
         */
      }, {
        key: "getBaseEdges",
        value: function getBaseEdges(clusteredEdgeId) {
          var IdsToHandle = [clusteredEdgeId];
          var doneIds = [];
          var foundIds = [];
          var max2 = 100;
          var counter = 0;
          while (IdsToHandle.length > 0 && counter < max2) {
            var nextId = IdsToHandle.pop();
            if (nextId === void 0) continue;
            var nextEdge = this.body.edges[nextId];
            if (nextEdge === void 0) continue;
            counter++;
            var replacingIds = nextEdge.clusteringEdgeReplacingIds;
            if (replacingIds === void 0) {
              foundIds.push(nextId);
            } else {
              for (var i = 0; i < replacingIds.length; ++i) {
                var replacingId = replacingIds[i];
                if (indexOf$3(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || indexOf$3(doneIds).call(doneIds, replacingIds) !== -1) {
                  continue;
                }
                IdsToHandle.push(replacingId);
              }
            }
            doneIds.push(nextId);
          }
          return foundIds;
        }
        /**
        * Get the Id the node is connected to
        * @param {vis.Edge} edge
        * @param {Node.id} nodeId
        * @returns {*}
        * @private
        */
      }, {
        key: "_getConnectedId",
        value: function _getConnectedId(edge, nodeId) {
          if (edge.toId != nodeId) {
            return edge.toId;
          } else if (edge.fromId != nodeId) {
            return edge.fromId;
          } else {
            return edge.fromId;
          }
        }
        /**
        * We determine how many connections denote an important hub.
        * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
        *
        * @returns {number}
        * @private
        */
      }, {
        key: "_getHubSize",
        value: function _getHubSize() {
          var average = 0;
          var averageSquared = 0;
          var hubCounter = 0;
          var largestHub = 0;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (node.edges.length > largestHub) {
              largestHub = node.edges.length;
            }
            average += node.edges.length;
            averageSquared += Math.pow(node.edges.length, 2);
            hubCounter += 1;
          }
          average = average / hubCounter;
          averageSquared = averageSquared / hubCounter;
          var variance = averageSquared - Math.pow(average, 2);
          var standardDeviation = Math.sqrt(variance);
          var hubThreshold = Math.floor(average + 2 * standardDeviation);
          if (hubThreshold > largestHub) {
            hubThreshold = largestHub;
          }
          return hubThreshold;
        }
        /**
         * Create an edge for the cluster representation.
         *
         * @param {Node.id} fromId
         * @param {Node.id} toId
         * @param {vis.Edge} baseEdge
         * @param {Object} clusterEdgeProperties
         * @param {Object} extraOptions
         * @returns {Edge} newly created clustered edge
         * @private
         */
      }, {
        key: "_createClusteredEdge",
        value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
          var clonedOptions = NetworkUtil.cloneOptions(baseEdge, "edge");
          deepExtend(clonedOptions, clusterEdgeProperties);
          clonedOptions.from = fromId;
          clonedOptions.to = toId;
          clonedOptions.id = "clusterEdge:" + v4();
          if (extraOptions !== void 0) {
            deepExtend(clonedOptions, extraOptions);
          }
          var newEdge = this.body.functions.createEdge(clonedOptions);
          newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
          newEdge.connect();
          this.body.edges[newEdge.id] = newEdge;
          return newEdge;
        }
        /**
         * Add the passed child nodes and edges to the given cluster node.
         *
         * @param {Object|Node} childNodes  hash of nodes or single node to add in cluster
         * @param {Object|Edge} childEdges  hash of edges or single edge to take into account when clustering
         * @param {Node} clusterNode  cluster node to add nodes and edges to
         * @param {Object} [clusterEdgeProperties]
         * @private
         */
      }, {
        key: "_clusterEdges",
        value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
          if (childEdges instanceof Edge) {
            var edge = childEdges;
            var obj = {};
            obj[edge.id] = edge;
            childEdges = obj;
          }
          if (childNodes instanceof Node) {
            var node = childNodes;
            var _obj = {};
            _obj[node.id] = node;
            childNodes = _obj;
          }
          if (clusterNode === void 0 || clusterNode === null) {
            throw new Error("_clusterEdges: parameter clusterNode required");
          }
          if (clusterEdgeProperties === void 0) {
            clusterEdgeProperties = clusterNode.clusterEdgeProperties;
          }
          this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);
          for (var edgeId in childEdges) {
            if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {
              if (this.body.edges[edgeId] !== void 0) {
                var _edge2 = this.body.edges[edgeId];
                this._backupEdgeOptions(_edge2);
                _edge2.setOptions({
                  physics: false
                });
              }
            }
          }
          for (var nodeId in childNodes) {
            if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {
              this.clusteredNodes[nodeId] = {
                clusterId: clusterNode.id,
                node: this.body.nodes[nodeId]
              };
              this.body.nodes[nodeId].setOptions({
                physics: false
              });
            }
          }
        }
        /**
         * Determine in which cluster given nodeId resides.
         *
         * If not in cluster, return undefined.
         *
         * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
         *
         * @param {Node.id} nodeId
         * @returns {Node|undefined} Node instance for cluster, if present
         * @private
         */
      }, {
        key: "_getClusterNodeForNode",
        value: function _getClusterNodeForNode(nodeId) {
          if (nodeId === void 0) return void 0;
          var clusteredNode = this.clusteredNodes[nodeId];
          if (clusteredNode === void 0) return void 0;
          var clusterId = clusteredNode.clusterId;
          if (clusterId === void 0) return void 0;
          return this.body.nodes[clusterId];
        }
        /**
         * Internal helper function for conditionally removing items in array
         *
         * Done like this because Array.filter() is not fully supported by all IE's.
         *
         * @param {Array} arr
         * @param {function} callback
         * @returns {Array}
         * @private
         */
      }, {
        key: "_filter",
        value: function _filter(arr, callback) {
          var ret = [];
          forEach$3(arr, function(item) {
            if (callback(item)) {
              ret.push(item);
            }
          });
          return ret;
        }
        /**
         * Scan all edges for changes in clustering and adjust this if necessary.
         *
         * Call this (internally) after there has been a change in node or edge data.
         *
         * Pre: States of this.body.nodes and this.body.edges consistent
         * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
         *      of cluster nodes.
         */
      }, {
        key: "_updateState",
        value: function _updateState() {
          var _this4 = this;
          var nodeId;
          var deletedNodeIds = [];
          var deletedEdgeIds = {};
          var eachClusterNode = function eachClusterNode2(callback) {
            forEach$3(_this4.body.nodes, function(node2) {
              if (node2.isCluster === true) {
                callback(node2);
              }
            });
          };
          for (nodeId in this.clusteredNodes) {
            if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId)) continue;
            var node = this.body.nodes[nodeId];
            if (node === void 0) {
              deletedNodeIds.push(nodeId);
            }
          }
          eachClusterNode(function(clusterNode) {
            for (var n2 = 0; n2 < deletedNodeIds.length; n2++) {
              delete clusterNode.containedNodes[deletedNodeIds[n2]];
            }
          });
          for (var n = 0; n < deletedNodeIds.length; n++) {
            delete this.clusteredNodes[deletedNodeIds[n]];
          }
          forEach$3(this.clusteredEdges, function(edgeId) {
            var edge = _this4.body.edges[edgeId];
            if (edge === void 0 || !edge.endPointsValid()) {
              deletedEdgeIds[edgeId] = edgeId;
            }
          });
          eachClusterNode(function(clusterNode) {
            forEach$3(clusterNode.containedEdges, function(edge, edgeId) {
              if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {
                deletedEdgeIds[edgeId] = edgeId;
              }
            });
          });
          forEach$3(this.body.edges, function(edge, edgeId) {
            var isValid = true;
            var replacedIds = edge.clusteringEdgeReplacingIds;
            if (replacedIds !== void 0) {
              var numValid = 0;
              forEach$3(replacedIds, function(containedEdgeId) {
                var containedEdge = _this4.body.edges[containedEdgeId];
                if (containedEdge !== void 0 && containedEdge.endPointsValid()) {
                  numValid += 1;
                }
              });
              isValid = numValid > 0;
            }
            if (!edge.endPointsValid() || !isValid) {
              deletedEdgeIds[edgeId] = edgeId;
            }
          });
          eachClusterNode(function(clusterNode) {
            forEach$3(deletedEdgeIds, function(deletedEdgeId) {
              delete clusterNode.containedEdges[deletedEdgeId];
              forEach$3(clusterNode.edges, function(edge, m) {
                if (edge.id === deletedEdgeId) {
                  clusterNode.edges[m] = null;
                  return;
                }
                edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function(id2) {
                  return !deletedEdgeIds[id2];
                });
              });
              clusterNode.edges = _this4._filter(clusterNode.edges, function(item) {
                return item !== null;
              });
            });
          });
          forEach$3(deletedEdgeIds, function(edgeId) {
            delete _this4.clusteredEdges[edgeId];
          });
          forEach$3(deletedEdgeIds, function(edgeId) {
            delete _this4.body.edges[edgeId];
          });
          var ids = keys$3(this.body.edges);
          forEach$3(ids, function(edgeId) {
            var edge = _this4.body.edges[edgeId];
            var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);
            if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
              return;
            }
            if (shouldBeClustered) {
              var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);
              if (clusterFrom !== void 0) {
                _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
              }
              var clusterTo = _this4._getClusterNodeForNode(edge.toId);
              if (clusterTo !== void 0) {
                _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
              }
            } else {
              delete _this4._clusterEdges[edgeId];
              _this4._restoreEdge(edge);
            }
          });
          var changed = false;
          var continueLoop = true;
          var _loop2 = function _loop22() {
            var clustersToOpen = [];
            eachClusterNode(function(clusterNode) {
              var numNodes = keys$3(clusterNode.containedNodes).length;
              var allowSingle = clusterNode.options.allowSingleNodeCluster === true;
              if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
                clustersToOpen.push(clusterNode.id);
              }
            });
            for (var _n = 0; _n < clustersToOpen.length; ++_n) {
              _this4.openCluster(
                clustersToOpen[_n],
                {},
                false
                /* Don't refresh, we're in an refresh/update already */
              );
            }
            continueLoop = clustersToOpen.length > 0;
            changed = changed || continueLoop;
          };
          while (continueLoop) {
            _loop2();
          }
          if (changed) {
            this._updateState();
          }
        }
        /**
         * Determine if node with given id is part of a cluster.
         *
         * @param {Node.id} nodeId
         * @return {boolean} true if part of a cluster.
         */
      }, {
        key: "_isClusteredNode",
        value: function _isClusteredNode(nodeId) {
          return this.clusteredNodes[nodeId] !== void 0;
        }
        /**
         * Determine if edge with given id is not visible due to clustering.
         *
         * An edge is considered clustered if:
         * - it is directly replaced by a clustering edge
         * - any of its connecting nodes is in a cluster
         *
         * @param {vis.Edge.id} edgeId
         * @return {boolean} true if part of a cluster.
         */
      }, {
        key: "_isClusteredEdge",
        value: function _isClusteredEdge(edgeId) {
          return this.clusteredEdges[edgeId] !== void 0;
        }
      }]);
      return ClusterEngine2;
    }();
    CanvasRenderer = function() {
      function CanvasRenderer2(body, canvas) {
        classCallCheck(this, CanvasRenderer2);
        _initRequestAnimationFrame();
        this.body = body;
        this.canvas = canvas;
        this.redrawRequested = false;
        this.renderTimer = void 0;
        this.requiresTimeout = true;
        this.renderingActive = false;
        this.renderRequests = 0;
        this.allowRedraw = true;
        this.dragging = false;
        this.zooming = false;
        this.options = {};
        this.defaultOptions = {
          hideEdgesOnDrag: false,
          hideEdgesOnZoom: false,
          hideNodesOnDrag: false
        };
        assign$2(this.options, this.defaultOptions);
        this._determineBrowserMethod();
        this.bindEventListeners();
      }
      createClass(CanvasRenderer2, [{
        key: "bindEventListeners",
        value: function bindEventListeners() {
          var _this = this, _context2;
          this.body.emitter.on("dragStart", function() {
            _this.dragging = true;
          });
          this.body.emitter.on("dragEnd", function() {
            _this.dragging = false;
          });
          this.body.emitter.on("zoom", function() {
            _this.zooming = true;
            window.clearTimeout(_this.zoomTimeoutId);
            _this.zoomTimeoutId = window.setTimeout(function() {
              var _context;
              _this.zooming = false;
              bind$2(_context = _this._requestRedraw).call(_context, _this)();
            }, 250);
          });
          this.body.emitter.on("_resizeNodes", function() {
            _this._resizeNodes();
          });
          this.body.emitter.on("_redraw", function() {
            if (_this.renderingActive === false) {
              _this._redraw();
            }
          });
          this.body.emitter.on("_blockRedraw", function() {
            _this.allowRedraw = false;
          });
          this.body.emitter.on("_allowRedraw", function() {
            _this.allowRedraw = true;
            _this.redrawRequested = false;
          });
          this.body.emitter.on("_requestRedraw", bind$2(_context2 = this._requestRedraw).call(_context2, this));
          this.body.emitter.on("_startRendering", function() {
            _this.renderRequests += 1;
            _this.renderingActive = true;
            _this._startRendering();
          });
          this.body.emitter.on("_stopRendering", function() {
            _this.renderRequests -= 1;
            _this.renderingActive = _this.renderRequests > 0;
            _this.renderTimer = void 0;
          });
          this.body.emitter.on("destroy", function() {
            _this.renderRequests = 0;
            _this.allowRedraw = false;
            _this.renderingActive = false;
            if (_this.requiresTimeout === true) {
              clearTimeout(_this.renderTimer);
            } else {
              window.cancelAnimationFrame(_this.renderTimer);
            }
            _this.body.emitter.off();
          });
        }
        /**
         *
         * @param {Object} options
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag"];
            selectiveDeepExtend(fields, this.options, options2);
          }
        }
        /**
         * Prepare the drawing of the next frame.
         *
         * Calls the callback when the next frame can or will be drawn.
         *
         * @param {function} callback
         * @param {number} delay - timeout case only, wait this number of milliseconds
         * @returns {function|undefined}
         * @private
         */
      }, {
        key: "_requestNextFrame",
        value: function _requestNextFrame(callback, delay) {
          if (typeof window === "undefined") return;
          var timer;
          var myWindow = window;
          if (this.requiresTimeout === true) {
            timer = myWindow.setTimeout(callback, delay);
          } else {
            if (myWindow.requestAnimationFrame) {
              timer = myWindow.requestAnimationFrame(callback);
            }
          }
          return timer;
        }
        /**
         *
         * @private
         */
      }, {
        key: "_startRendering",
        value: function _startRendering() {
          if (this.renderingActive === true) {
            if (this.renderTimer === void 0) {
              var _context3;
              this.renderTimer = this._requestNextFrame(bind$2(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);
            }
          }
        }
        /**
         *
         * @private
         */
      }, {
        key: "_renderStep",
        value: function _renderStep() {
          if (this.renderingActive === true) {
            this.renderTimer = void 0;
            if (this.requiresTimeout === true) {
              this._startRendering();
            }
            this._redraw();
            if (this.requiresTimeout === false) {
              this._startRendering();
            }
          }
        }
        /**
         * Redraw the network with the current data
         * chart will be resized too.
         */
      }, {
        key: "redraw",
        value: function redraw() {
          this.body.emitter.emit("setSize");
          this._redraw();
        }
        /**
         * Redraw the network with the current data
         * @private
         */
      }, {
        key: "_requestRedraw",
        value: function _requestRedraw() {
          var _this2 = this;
          if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
            this.redrawRequested = true;
            this._requestNextFrame(function() {
              _this2._redraw(false);
            }, 0);
          }
        }
        /**
         * Redraw the network with the current data
         * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
         *                                   Only the nodes are drawn after which they are quickly drawn over.
         * @private
         */
      }, {
        key: "_redraw",
        value: function _redraw() {
          var hidden = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          if (this.allowRedraw === true) {
            this.body.emitter.emit("initRedraw");
            this.redrawRequested = false;
            if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
              this.canvas.setSize();
            }
            this.canvas.setTransform();
            var ctx = this.canvas.getContext();
            var w = this.canvas.frame.canvas.clientWidth;
            var h = this.canvas.frame.canvas.clientHeight;
            ctx.clearRect(0, 0, w, h);
            if (this.canvas.frame.clientWidth === 0) {
              return;
            }
            ctx.save();
            ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
            ctx.scale(this.body.view.scale, this.body.view.scale);
            ctx.beginPath();
            this.body.emitter.emit("beforeDrawing", ctx);
            ctx.closePath();
            if (hidden === false) {
              if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
                this._drawEdges(ctx);
              }
            }
            if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
              this._drawNodes(ctx, hidden);
            }
            if (hidden === false) {
              if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
                this._drawArrows(ctx);
              }
            }
            if (hidden === false) {
              this._drawSelectionBox(ctx);
            }
            ctx.beginPath();
            this.body.emitter.emit("afterDrawing", ctx);
            ctx.closePath();
            ctx.restore();
            if (hidden === true) {
              ctx.clearRect(0, 0, w, h);
            }
          }
        }
        /**
         * Redraw all nodes
         *
         * @param {CanvasRenderingContext2D}   ctx
         * @param {boolean} [alwaysShow]
         * @private
         */
      }, {
        key: "_resizeNodes",
        value: function _resizeNodes() {
          this.canvas.setTransform();
          var ctx = this.canvas.getContext();
          ctx.save();
          ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
          ctx.scale(this.body.view.scale, this.body.view.scale);
          var nodes = this.body.nodes;
          var node;
          for (var nodeId in nodes) {
            if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
              node = nodes[nodeId];
              node.resize(ctx);
              node.updateBoundingBox(ctx, node.selected);
            }
          }
          ctx.restore();
        }
        /**
         * Redraw all nodes
         *
         * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
         * @param {boolean} [alwaysShow]
         * @private
         */
      }, {
        key: "_drawNodes",
        value: function _drawNodes(ctx) {
          var alwaysShow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var nodes = this.body.nodes;
          var nodeIndices = this.body.nodeIndices;
          var node;
          var selected = [];
          var hovered = [];
          var margin = 20;
          var topLeft = this.canvas.DOMtoCanvas({
            x: -margin,
            y: -margin
          });
          var bottomRight = this.canvas.DOMtoCanvas({
            x: this.canvas.frame.canvas.clientWidth + margin,
            y: this.canvas.frame.canvas.clientHeight + margin
          });
          var viewableArea = {
            top: topLeft.y,
            left: topLeft.x,
            bottom: bottomRight.y,
            right: bottomRight.x
          };
          for (var _i = 0; _i < nodeIndices.length; _i++) {
            node = nodes[nodeIndices[_i]];
            if (node.hover) {
              hovered.push(nodeIndices[_i]);
            } else if (node.isSelected()) {
              selected.push(nodeIndices[_i]);
            } else {
              if (alwaysShow === true) {
                node.draw(ctx);
              } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
                node.draw(ctx);
              } else {
                node.updateBoundingBox(ctx, node.selected);
              }
            }
          }
          var i;
          var selectedLength = selected.length;
          var hoveredLength = hovered.length;
          for (i = 0; i < selectedLength; i++) {
            node = nodes[selected[i]];
            node.draw(ctx);
          }
          for (i = 0; i < hoveredLength; i++) {
            node = nodes[hovered[i]];
            node.draw(ctx);
          }
        }
        /**
         * Redraw all edges
         * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
         * @private
         */
      }, {
        key: "_drawEdges",
        value: function _drawEdges(ctx) {
          var edges = this.body.edges;
          var edgeIndices = this.body.edgeIndices;
          for (var i = 0; i < edgeIndices.length; i++) {
            var edge = edges[edgeIndices[i]];
            if (edge.connected === true) {
              edge.draw(ctx);
            }
          }
        }
        /**
         * Redraw all arrows
         * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
         * @private
         */
      }, {
        key: "_drawArrows",
        value: function _drawArrows(ctx) {
          var edges = this.body.edges;
          var edgeIndices = this.body.edgeIndices;
          for (var i = 0; i < edgeIndices.length; i++) {
            var edge = edges[edgeIndices[i]];
            if (edge.connected === true) {
              edge.drawArrows(ctx);
            }
          }
        }
        /**
         * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
         * some implementations (safari and IE9) did not support requestAnimationFrame
         * @private
         */
      }, {
        key: "_determineBrowserMethod",
        value: function _determineBrowserMethod() {
          if (typeof window !== "undefined") {
            var browserType = navigator.userAgent.toLowerCase();
            this.requiresTimeout = false;
            if (indexOf$3(browserType).call(browserType, "msie 9.0") != -1) {
              this.requiresTimeout = true;
            } else if (indexOf$3(browserType).call(browserType, "safari") != -1) {
              if (indexOf$3(browserType).call(browserType, "chrome") <= -1) {
                this.requiresTimeout = true;
              }
            }
          } else {
            this.requiresTimeout = true;
          }
        }
        /**
        * Redraw selection box
        * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
        * @private
        */
      }, {
        key: "_drawSelectionBox",
        value: function _drawSelectionBox(ctx) {
          if (this.body.selectionBox.show) {
            ctx.beginPath();
            var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;
            var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;
            ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
            ctx.fillStyle = "rgba(151, 194, 252, 0.2)";
            ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
            ctx.strokeStyle = "rgba(151, 194, 252, 1)";
            ctx.stroke();
          } else {
            ctx.closePath();
          }
        }
      }]);
      return CanvasRenderer2;
    }();
    setInterval = path.setInterval;
    setInterval$1 = setInterval;
    Canvas = function() {
      function Canvas2(body) {
        var _context;
        classCallCheck(this, Canvas2);
        this.body = body;
        this.pixelRatio = 1;
        this.resizeTimer = void 0;
        this.resizeFunction = bind$2(_context = this._onResize).call(_context, this);
        this.cameraState = {};
        this.initialized = false;
        this.canvasViewCenter = {};
        this.options = {};
        this.defaultOptions = {
          autoResize: true,
          height: "100%",
          width: "100%"
        };
        assign$2(this.options, this.defaultOptions);
        this.bindEventListeners();
      }
      createClass(Canvas2, [{
        key: "bindEventListeners",
        value: function bindEventListeners() {
          var _this = this, _context2;
          this.body.emitter.once("resize", function(obj) {
            if (obj.width !== 0) {
              _this.body.view.translation.x = obj.width * 0.5;
            }
            if (obj.height !== 0) {
              _this.body.view.translation.y = obj.height * 0.5;
            }
          });
          this.body.emitter.on("setSize", bind$2(_context2 = this.setSize).call(_context2, this));
          this.body.emitter.on("destroy", function() {
            _this.hammerFrame.destroy();
            _this.hammer.destroy();
            _this._cleanUp();
          });
        }
        /**
         * @param {Object} options
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          var _this2 = this;
          if (options2 !== void 0) {
            var fields = ["width", "height", "autoResize"];
            selectiveDeepExtend(fields, this.options, options2);
          }
          if (this.options.autoResize === true) {
            var _context3;
            this._cleanUp();
            this.resizeTimer = setInterval$1(function() {
              var changed = _this2.setSize();
              if (changed === true) {
                _this2.body.emitter.emit("_requestRedraw");
              }
            }, 1e3);
            this.resizeFunction = bind$2(_context3 = this._onResize).call(_context3, this);
            addEventListener(window, "resize", this.resizeFunction);
          }
        }
        /**
         * @private
         */
      }, {
        key: "_cleanUp",
        value: function _cleanUp() {
          if (this.resizeTimer !== void 0) {
            clearInterval(this.resizeTimer);
          }
          removeEventListener(window, "resize", this.resizeFunction);
          this.resizeFunction = void 0;
        }
        /**
         * @private
         */
      }, {
        key: "_onResize",
        value: function _onResize() {
          this.setSize();
          this.body.emitter.emit("_redraw");
        }
        /**
         * Get and store the cameraState
         *
         * @param {number} [pixelRatio=this.pixelRatio]
         * @private
         */
      }, {
        key: "_getCameraState",
        value: function _getCameraState() {
          var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.pixelRatio;
          if (this.initialized === true) {
            this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
            this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
            this.cameraState.scale = this.body.view.scale;
            this.cameraState.position = this.DOMtoCanvas({
              x: 0.5 * this.frame.canvas.width / pixelRatio,
              y: 0.5 * this.frame.canvas.height / pixelRatio
            });
          }
        }
        /**
         * Set the cameraState
         * @private
         */
      }, {
        key: "_setCameraState",
        value: function _setCameraState() {
          if (this.cameraState.scale !== void 0 && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {
            var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
            var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
            var newScale = this.cameraState.scale;
            if (widthRatio != 1 && heightRatio != 1) {
              newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
            } else if (widthRatio != 1) {
              newScale = this.cameraState.scale * widthRatio;
            } else if (heightRatio != 1) {
              newScale = this.cameraState.scale * heightRatio;
            }
            this.body.view.scale = newScale;
            var currentViewCenter = this.DOMtoCanvas({
              x: 0.5 * this.frame.canvas.clientWidth,
              y: 0.5 * this.frame.canvas.clientHeight
            });
            var distanceFromCenter = {
              // offset from view, distance view has to change by these x and y to center the node
              x: currentViewCenter.x - this.cameraState.position.x,
              y: currentViewCenter.y - this.cameraState.position.y
            };
            this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
            this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
          }
        }
        /**
         *
         * @param {number|string} value
         * @returns {string}
         * @private
         */
      }, {
        key: "_prepareValue",
        value: function _prepareValue(value) {
          if (typeof value === "number") {
            return value + "px";
          } else if (typeof value === "string") {
            if (indexOf$3(value).call(value, "%") !== -1 || indexOf$3(value).call(value, "px") !== -1) {
              return value;
            } else if (indexOf$3(value).call(value, "%") === -1) {
              return value + "px";
            }
          }
          throw new Error("Could not use the value supplied for width or height:" + value);
        }
        /**
         * Create the HTML
         */
      }, {
        key: "_create",
        value: function _create() {
          while (this.body.container.hasChildNodes()) {
            this.body.container.removeChild(this.body.container.firstChild);
          }
          this.frame = document.createElement("div");
          this.frame.className = "vis-network";
          this.frame.style.position = "relative";
          this.frame.style.overflow = "hidden";
          this.frame.tabIndex = 900;
          this.frame.canvas = document.createElement("canvas");
          this.frame.canvas.style.position = "relative";
          this.frame.appendChild(this.frame.canvas);
          if (!this.frame.canvas.getContext) {
            var noCanvas = document.createElement("DIV");
            noCanvas.style.color = "red";
            noCanvas.style.fontWeight = "bold";
            noCanvas.style.padding = "10px";
            noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
            this.frame.canvas.appendChild(noCanvas);
          } else {
            this._setPixelRatio();
            this.setTransform();
          }
          this.body.container.appendChild(this.frame);
          this.body.view.scale = 1;
          this.body.view.translation = {
            x: 0.5 * this.frame.canvas.clientWidth,
            y: 0.5 * this.frame.canvas.clientHeight
          };
          this._bindHammer();
        }
        /**
         * This function binds hammer, it can be repeated over and over due to the uniqueness check.
         * @private
         */
      }, {
        key: "_bindHammer",
        value: function _bindHammer() {
          var _this3 = this;
          if (this.hammer !== void 0) {
            this.hammer.destroy();
          }
          this.drag = {};
          this.pinch = {};
          this.hammer = new hammer(this.frame.canvas);
          this.hammer.get("pinch").set({
            enable: true
          });
          this.hammer.get("pan").set({
            threshold: 5,
            direction: hammer.DIRECTION_ALL
          });
          onTouch(this.hammer, function(event) {
            _this3.body.eventListeners.onTouch(event);
          });
          this.hammer.on("tap", function(event) {
            _this3.body.eventListeners.onTap(event);
          });
          this.hammer.on("doubletap", function(event) {
            _this3.body.eventListeners.onDoubleTap(event);
          });
          this.hammer.on("press", function(event) {
            _this3.body.eventListeners.onHold(event);
          });
          this.hammer.on("panstart", function(event) {
            _this3.body.eventListeners.onDragStart(event);
          });
          this.hammer.on("panmove", function(event) {
            _this3.body.eventListeners.onDrag(event);
          });
          this.hammer.on("panend", function(event) {
            _this3.body.eventListeners.onDragEnd(event);
          });
          this.hammer.on("pinch", function(event) {
            _this3.body.eventListeners.onPinch(event);
          });
          this.frame.canvas.addEventListener("wheel", function(event) {
            _this3.body.eventListeners.onMouseWheel(event);
          });
          this.frame.canvas.addEventListener("mousemove", function(event) {
            _this3.body.eventListeners.onMouseMove(event);
          });
          this.frame.canvas.addEventListener("contextmenu", function(event) {
            _this3.body.eventListeners.onContext(event);
          });
          this.hammerFrame = new hammer(this.frame);
          onRelease(this.hammerFrame, function(event) {
            _this3.body.eventListeners.onRelease(event);
          });
        }
        /**
         * Set a new size for the network
         * @param {string} width   Width in pixels or percentage (for example '800px'
         *                         or '50%')
         * @param {string} height  Height in pixels or percentage  (for example '400px'
         *                         or '30%')
         * @returns {boolean}
         */
      }, {
        key: "setSize",
        value: function setSize() {
          var width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.width;
          var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.height;
          width = this._prepareValue(width);
          height = this._prepareValue(height);
          var emitEvent = false;
          var oldWidth = this.frame.canvas.width;
          var oldHeight = this.frame.canvas.height;
          var previousRatio = this.pixelRatio;
          this._setPixelRatio();
          if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
            this._getCameraState(previousRatio);
            this.frame.style.width = width;
            this.frame.style.height = height;
            this.frame.canvas.style.width = "100%";
            this.frame.canvas.style.height = "100%";
            this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
            this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
            this.options.width = width;
            this.options.height = height;
            this.canvasViewCenter = {
              x: 0.5 * this.frame.clientWidth,
              y: 0.5 * this.frame.clientHeight
            };
            emitEvent = true;
          } else {
            var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
            var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
            if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
              this._getCameraState(previousRatio);
            }
            if (this.frame.canvas.width !== newWidth) {
              this.frame.canvas.width = newWidth;
              emitEvent = true;
            }
            if (this.frame.canvas.height !== newHeight) {
              this.frame.canvas.height = newHeight;
              emitEvent = true;
            }
          }
          if (emitEvent === true) {
            this.body.emitter.emit("resize", {
              width: Math.round(this.frame.canvas.width / this.pixelRatio),
              height: Math.round(this.frame.canvas.height / this.pixelRatio),
              oldWidth: Math.round(oldWidth / this.pixelRatio),
              oldHeight: Math.round(oldHeight / this.pixelRatio)
            });
            this._setCameraState();
          }
          this.initialized = true;
          return emitEvent;
        }
        /**
         *
         * @returns {CanvasRenderingContext2D}
         */
      }, {
        key: "getContext",
        value: function getContext() {
          return this.frame.canvas.getContext("2d");
        }
        /**
         * Determine the pixel ratio for various browsers.
         *
         * @returns {number}
         * @private
         */
      }, {
        key: "_determinePixelRatio",
        value: function _determinePixelRatio() {
          var ctx = this.getContext();
          if (ctx === void 0) {
            throw new Error("Could not get canvax context");
          }
          var numerator = 1;
          if (typeof window !== "undefined") {
            numerator = window.devicePixelRatio || 1;
          }
          var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
          return numerator / denominator;
        }
        /**
         * Lazy determination of pixel ratio.
         *
         * @private
         */
      }, {
        key: "_setPixelRatio",
        value: function _setPixelRatio() {
          this.pixelRatio = this._determinePixelRatio();
        }
        /**
         * Set the transform in the contained context, based on its pixelRatio
         */
      }, {
        key: "setTransform",
        value: function setTransform() {
          var ctx = this.getContext();
          if (ctx === void 0) {
            throw new Error("Could not get canvax context");
          }
          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        }
        /**
         * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
         * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
         * @param {number} x
         * @returns {number}
         * @private
         */
      }, {
        key: "_XconvertDOMtoCanvas",
        value: function _XconvertDOMtoCanvas(x) {
          return (x - this.body.view.translation.x) / this.body.view.scale;
        }
        /**
         * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
         * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
         * @param {number} x
         * @returns {number}
         * @private
         */
      }, {
        key: "_XconvertCanvasToDOM",
        value: function _XconvertCanvasToDOM(x) {
          return x * this.body.view.scale + this.body.view.translation.x;
        }
        /**
         * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
         * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
         * @param {number} y
         * @returns {number}
         * @private
         */
      }, {
        key: "_YconvertDOMtoCanvas",
        value: function _YconvertDOMtoCanvas(y) {
          return (y - this.body.view.translation.y) / this.body.view.scale;
        }
        /**
         * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
         * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
         * @param {number} y
         * @returns {number}
         * @private
         */
      }, {
        key: "_YconvertCanvasToDOM",
        value: function _YconvertCanvasToDOM(y) {
          return y * this.body.view.scale + this.body.view.translation.y;
        }
        /**
         * @param {point} pos
         * @returns {point}
         */
      }, {
        key: "canvasToDOM",
        value: function canvasToDOM(pos) {
          return {
            x: this._XconvertCanvasToDOM(pos.x),
            y: this._YconvertCanvasToDOM(pos.y)
          };
        }
        /**
         *
         * @param {point} pos
         * @returns {point}
         */
      }, {
        key: "DOMtoCanvas",
        value: function DOMtoCanvas(pos) {
          return {
            x: this._XconvertDOMtoCanvas(pos.x),
            y: this._YconvertDOMtoCanvas(pos.y)
          };
        }
      }]);
      return Canvas2;
    }();
    View = function() {
      function View2(body, canvas) {
        var _context, _this = this, _context2;
        classCallCheck(this, View2);
        this.body = body;
        this.canvas = canvas;
        this.animationSpeed = 1 / this.renderRefreshRate;
        this.animationEasingFunction = "easeInOutQuint";
        this.easingTime = 0;
        this.sourceScale = 0;
        this.targetScale = 0;
        this.sourceTranslation = 0;
        this.targetTranslation = 0;
        this.lockedOnNodeId = void 0;
        this.lockedOnNodeOffset = void 0;
        this.touchTime = 0;
        this.viewFunction = void 0;
        this.body.emitter.on("fit", bind$2(_context = this.fit).call(_context, this));
        this.body.emitter.on("animationFinished", function() {
          _this.body.emitter.emit("_stopRendering");
        });
        this.body.emitter.on("unlockNode", bind$2(_context2 = this.releaseNode).call(_context2, this));
      }
      createClass(View2, [{
        key: "setOptions",
        value: function setOptions() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.options = options2;
        }
        /**
         * This function zooms out to fit all data on screen based on amount of nodes
         * @param {Object} [options={{nodes=Array}}]
         * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
         */
      }, {
        key: "fit",
        value: function fit() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            nodes: []
          };
          var initialZoom = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var range;
          var zoomLevel;
          options2 = assign$2({}, options2);
          if (options2.nodes === void 0 || options2.nodes.length === 0) {
            options2.nodes = this.body.nodeIndices;
          }
          var canvasWidth = this.canvas.frame.canvas.clientWidth;
          var canvasHeight = this.canvas.frame.canvas.clientHeight;
          if (canvasWidth === 0 || canvasHeight === 0) {
            zoomLevel = 1;
            range = NetworkUtil.getRange(this.body.nodes, options2.nodes);
          } else if (initialZoom === true) {
            var positionDefined = 0;
            for (var nodeId in this.body.nodes) {
              if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
                var node = this.body.nodes[nodeId];
                if (node.predefinedPosition === true) {
                  positionDefined += 1;
                }
              }
            }
            if (positionDefined > 0.5 * this.body.nodeIndices.length) {
              this.fit(options2, false);
              return;
            }
            range = NetworkUtil.getRange(this.body.nodes, options2.nodes);
            var numberOfNodes = this.body.nodeIndices.length;
            zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822;
            var factor = Math.min(canvasWidth / 600, canvasHeight / 600);
            zoomLevel *= factor;
          } else {
            this.body.emitter.emit("_resizeNodes");
            range = NetworkUtil.getRange(this.body.nodes, options2.nodes);
            var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
            var yDistance = Math.abs(range.maxY - range.minY) * 1.1;
            var xZoomLevel = canvasWidth / xDistance;
            var yZoomLevel = canvasHeight / yDistance;
            zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
          }
          if (zoomLevel > 1) {
            zoomLevel = 1;
          } else if (zoomLevel === 0) {
            zoomLevel = 1;
          }
          var center = NetworkUtil.findCenter(range);
          var animationOptions = {
            position: center,
            scale: zoomLevel,
            animation: options2.animation
          };
          this.moveTo(animationOptions);
        }
        // animation
        /**
         * Center a node in view.
         *
         * @param {number} nodeId
         * @param {number} [options]
         */
      }, {
        key: "focus",
        value: function focus(nodeId) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (this.body.nodes[nodeId] !== void 0) {
            var nodePosition = {
              x: this.body.nodes[nodeId].x,
              y: this.body.nodes[nodeId].y
            };
            options2.position = nodePosition;
            options2.lockedOnNode = nodeId;
            this.moveTo(options2);
          } else {
            console.log("Node: " + nodeId + " cannot be found.");
          }
        }
        /**
         *
         * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
         *                          |  options.scale    = number                 // scale to move to
         *                          |  options.position = {x:number, y:number}   // position to move to
         *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
         */
      }, {
        key: "moveTo",
        value: function moveTo(options2) {
          if (options2 === void 0) {
            options2 = {};
            return;
          }
          if (options2.offset != null) {
            if (options2.offset.x != null) {
              options2.offset.x = +options2.offset.x;
              if (!_isFinite$2(options2.offset.x)) {
                throw new TypeError('The option "offset.x" has to be a finite number.');
              }
            } else {
              options2.offset.x = 0;
            }
            if (options2.offset.y != null) {
              options2.offset.y = +options2.offset.y;
              if (!_isFinite$2(options2.offset.y)) {
                throw new TypeError('The option "offset.y" has to be a finite number.');
              }
            } else {
              options2.offset.x = 0;
            }
          } else {
            options2.offset = {
              x: 0,
              y: 0
            };
          }
          if (options2.position != null) {
            if (options2.position.x != null) {
              options2.position.x = +options2.position.x;
              if (!_isFinite$2(options2.position.x)) {
                throw new TypeError('The option "position.x" has to be a finite number.');
              }
            } else {
              options2.position.x = 0;
            }
            if (options2.position.y != null) {
              options2.position.y = +options2.position.y;
              if (!_isFinite$2(options2.position.y)) {
                throw new TypeError('The option "position.y" has to be a finite number.');
              }
            } else {
              options2.position.x = 0;
            }
          } else {
            options2.position = this.getViewPosition();
          }
          if (options2.scale != null) {
            options2.scale = +options2.scale;
            if (!(options2.scale > 0)) {
              throw new TypeError('The option "scale" has to be a number greater than zero.');
            }
          } else {
            options2.scale = this.body.view.scale;
          }
          if (options2.animation === void 0) {
            options2.animation = {
              duration: 0
            };
          }
          if (options2.animation === false) {
            options2.animation = {
              duration: 0
            };
          }
          if (options2.animation === true) {
            options2.animation = {};
          }
          if (options2.animation.duration === void 0) {
            options2.animation.duration = 1e3;
          }
          if (options2.animation.easingFunction === void 0) {
            options2.animation.easingFunction = "easeInOutQuad";
          }
          this.animateView(options2);
        }
        /**
         *
         * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
         *                          |  options.time     = number                 // animation time in milliseconds
         *                          |  options.scale    = number                 // scale to animate to
         *                          |  options.position = {x:number, y:number}   // position to animate to
         *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
         *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
         *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
         *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
         */
      }, {
        key: "animateView",
        value: function animateView(options2) {
          if (options2 === void 0) {
            return;
          }
          this.animationEasingFunction = options2.animation.easingFunction;
          this.releaseNode();
          if (options2.locked === true) {
            this.lockedOnNodeId = options2.lockedOnNode;
            this.lockedOnNodeOffset = options2.offset;
          }
          if (this.easingTime != 0) {
            this._transitionRedraw(true);
          }
          this.sourceScale = this.body.view.scale;
          this.sourceTranslation = this.body.view.translation;
          this.targetScale = options2.scale;
          this.body.view.scale = this.targetScale;
          var viewCenter = this.canvas.DOMtoCanvas({
            x: 0.5 * this.canvas.frame.canvas.clientWidth,
            y: 0.5 * this.canvas.frame.canvas.clientHeight
          });
          var distanceFromCenter = {
            // offset from view, distance view has to change by these x and y to center the node
            x: viewCenter.x - options2.position.x,
            y: viewCenter.y - options2.position.y
          };
          this.targetTranslation = {
            x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options2.offset.x,
            y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options2.offset.y
          };
          if (options2.animation.duration === 0) {
            if (this.lockedOnNodeId != void 0) {
              var _context3;
              this.viewFunction = bind$2(_context3 = this._lockedRedraw).call(_context3, this);
              this.body.emitter.on("initRedraw", this.viewFunction);
            } else {
              this.body.view.scale = this.targetScale;
              this.body.view.translation = this.targetTranslation;
              this.body.emitter.emit("_requestRedraw");
            }
          } else {
            var _context4;
            this.animationSpeed = 1 / (60 * options2.animation.duration * 1e-3) || 1 / 60;
            this.animationEasingFunction = options2.animation.easingFunction;
            this.viewFunction = bind$2(_context4 = this._transitionRedraw).call(_context4, this);
            this.body.emitter.on("initRedraw", this.viewFunction);
            this.body.emitter.emit("_startRendering");
          }
        }
        /**
         * used to animate smoothly by hijacking the redraw function.
         * @private
         */
      }, {
        key: "_lockedRedraw",
        value: function _lockedRedraw() {
          var nodePosition = {
            x: this.body.nodes[this.lockedOnNodeId].x,
            y: this.body.nodes[this.lockedOnNodeId].y
          };
          var viewCenter = this.canvas.DOMtoCanvas({
            x: 0.5 * this.canvas.frame.canvas.clientWidth,
            y: 0.5 * this.canvas.frame.canvas.clientHeight
          });
          var distanceFromCenter = {
            // offset from view, distance view has to change by these x and y to center the node
            x: viewCenter.x - nodePosition.x,
            y: viewCenter.y - nodePosition.y
          };
          var sourceTranslation = this.body.view.translation;
          var targetTranslation = {
            x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
            y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
          };
          this.body.view.translation = targetTranslation;
        }
        /**
         * Resets state of a locked on Node
         */
      }, {
        key: "releaseNode",
        value: function releaseNode() {
          if (this.lockedOnNodeId !== void 0 && this.viewFunction !== void 0) {
            this.body.emitter.off("initRedraw", this.viewFunction);
            this.lockedOnNodeId = void 0;
            this.lockedOnNodeOffset = void 0;
          }
        }
        /**
         * @param {boolean} [finished=false]
         * @private
         */
      }, {
        key: "_transitionRedraw",
        value: function _transitionRedraw() {
          var finished = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          this.easingTime += this.animationSpeed;
          this.easingTime = finished === true ? 1 : this.easingTime;
          var progress = easingFunctions[this.animationEasingFunction](this.easingTime);
          this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
          this.body.view.translation = {
            x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
            y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
          };
          if (this.easingTime >= 1) {
            this.body.emitter.off("initRedraw", this.viewFunction);
            this.easingTime = 0;
            if (this.lockedOnNodeId != void 0) {
              var _context5;
              this.viewFunction = bind$2(_context5 = this._lockedRedraw).call(_context5, this);
              this.body.emitter.on("initRedraw", this.viewFunction);
            }
            this.body.emitter.emit("animationFinished");
          }
        }
        /**
         *
         * @returns {number}
         */
      }, {
        key: "getScale",
        value: function getScale2() {
          return this.body.view.scale;
        }
        /**
         *
         * @returns {{x: number, y: number}}
         */
      }, {
        key: "getViewPosition",
        value: function getViewPosition() {
          return this.canvas.DOMtoCanvas({
            x: 0.5 * this.canvas.frame.canvas.clientWidth,
            y: 0.5 * this.canvas.frame.canvas.clientHeight
          });
        }
      }]);
      return View2;
    }();
    css_248z$1 = "div.vis-network div.vis-navigation div.vis-button {\n    width:34px;\n    height:34px;\n    -moz-border-radius: 17px;\n    border-radius: 17px;\n    position:absolute;\n    display:inline-block;\n    background-position: 2px 2px;\n    background-repeat:no-repeat;\n    cursor: pointer;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:hover {\n    box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.30);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:active {\n    box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button.vis-up {\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABphJREFUeNqcV2twU9cR/nbPlVTHxpKRbNnBLyEbPyJisLEcPwgwUMKQtjNJAzNJZkgNNJOmJaZAaDKlxaXDTIBAcJtOOzSYKSkdiimhAdIMjyT4bYgBYxA2BgcUQPLrCiGDR4qt2x+yXTASFt1/957d7zt3z3d39xDCMQWUfgAz/RI/T4pSTAJpAGL8rECAXX7QFQGq9wOHOxYO1oCgjAdJj1wtB095Giv9TFuZAIWHAziATMPhTAwiHgUkYPXFJu92lMP/2MTpB1AKUCVEgNAcleUo1M+2F8TO6crSTncb1QleAOj2OTSX3Ge1p+Va42m5JrnzbnsCE8Ov+EHgpa0LPLvCJjZ/whuIlN8wAcXG+e1LUn9hm238QU84p1Ld83nsXvuO7Lq+LzKYGAT6/dn58m/HJTYf4O3EShkT8Irpzab1Uz9sGevT5+tWn+j6NB4A5hp/5NSr43xjfd5rW5tT9e3OAhCBiCua5/WsDEls/hdvYklZSwDefmrT8eXmtzuDkb5YZ33p9ndylICAVjWxf39xw/5g5Luv/9H84ZWNcwNEypZT87rXjqyJB85UYDMJYN3U7UdLJ6/6JlgqV517teRqf9uTlug8e1zEk27HgD22o98WsTBh8fWxvjm6ApdONbGvse8LM5NUPOm1Cfabuz3nACAgxX0QEFTJAnjNvLJ+Sepb14KRHnN+Ev+1XJOhZs3Qu1mbG97J2NQgsXroa1dtxrGuf8cHi1mUtPTay0lv1DMJSCRVLtoX+FgGgDQNysBAcez89l9nbbsQSji7rlXkEhjPxb/QatHOcFu0M9zz419oFSRhj/3PuaHiyqasv1Con9NGxHAYUsoCxAqImbYSgCWmFbZQwdsur7N0eC4m6tT6/jUZ750Zeb82c+OZGLWh/2p/W+Kfrmy0hIp/aVKpTSIJEqu2QgFx2iE8CwDp0RbH7Ljng/4yXr+XT3QdyhYsodS0slGr0g2OrEUK7eCrKW82SqzCVz3/yfb6vRwM4xn9rN7JkRkOQRLmfJn2LBPxQjDBqp9lD7XbX7X8pKTP160zR2bdeiX5jYeU/nLSTztNkem3XL5eXbltRUkonBxdgZ2IIUmahUxERQSCVT+rK5hzQ89xQ6P8VaaK1f5VmRvqQ4G+lba+nlnlb5brMhvlk7FBiaPzuwQEmEQhg5BOxMjWTncHc2501cQLkjDTsMCWpyuRQxFP0xXIJfp5FyVW4Zy7KajC06ItbiIGg6ZITBxDxIgbrr1jTSM0fibGIHz8O9sKK0GAibEua9spANh4aY2VmcEg+DEkiBgR/L2hYFgGtcErkQQAMVJgBxyy9hboZzv32v+Kpr7qbEECTAIMAoaJa3qPTmNiiAAgJAjk6J5xhu6HDAIgQYGLmI29PocmMcI8MNYvT1ckfzD9H/ub5br4e4Me9WfOKqtyX6Ud2cwC449PRamifDm6Auc0rTXokci+Xo1EAgBckiDuYGLjpTvntcGIA+SFcp6uUAaAI879VhWrRteYAqn/edq758brXJ1327QMhgJcZjA3EBjNrgZjOG1PkAjyTGENMjZPq5ECQ0MDE9ERBqFZrk0OJ3i4x/7vyIjBxGERt3takgVJEAp9xq3f769WiPDNvSsJdT3HDOEASPelmoBRYT3Kzt5uMtwauJEgSOCpwrk1DIJCoNUMwj9v7MweP9XSQ8/hJPp496fZTAICvLqcyv2B7nRbrgCA03JN5h8ub7A8VqpB437xHvsOy3l3cyaB4L2uqxhti1WLMcSgZQCw7+bOooO3Pk4JBZIYYXISMV5sKH59UePM10GESRGpIf/bE92HU452HywSJIGIllctrhp6YAK5+fHds0lLtJFMXNwkV6fFqA29mROefqiMJj1h6um4a5vY/92dKGaBxIhU5zJTWW2cJmEgGOmeb3c8FxAfb9mdf2RzyGGv5MvU7QwuEySwKHFp/c/M71zA/2F7b1RajnYdLAqMukMVu2YcfmDYE2MD7H+7/Xlq6cRIJqm4zXM+qd3TGjVBir43KSLlXjiELe5TsX+3/yW/ST45PaAHbKmccWh12AP93JNZywj0kSABIobpiXRHjtZ6faout2tyZMadGLXBCxBcvl6NfaAz+tKdFmObpzWl2+tIIBACYy0t/yj34M7HvsKUK+CGassvicX7alYDwwq+vykIEqPVa+Q9gdYk5+V+UE7lj3+FGbuBM/X5JUT8QwIVSSSZiTgmoFR2MfiqYFFPfjpkyrfWPopwxP47AP1pK1g9/dqeAAAAAElFTkSuQmCC');\n    bottom:50px;\n    left:55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-down {\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABpdJREFUeNqcV21QlNcVfp5zX9ikoAvLEsAIIgsoHwpqWAQUNKLNaNv8iZ1JMkNG6/Qj/dDUyCSTtCHpmEkwVk3TToZRMjXj5MOG2KidjIkxQYSAQUAtX6IgIN8su8KCoOzbH4sk4q5g77/33uee555z7rnneYmZDB2MKcJKlyYbqOsZVIgGEOgSHQoy4AKbFFjqAo5dWn/rNAh9OpO852oeJHYxtrmEu4WALhMbxG2ZE9uFAlImDRLY/t/y0b3Ig+u+iWOKsAlgIZSb0OIf15kWtKo1NXh1d5xxiSPEN2wUAHrGOg11jirjWVtJyFnb6YgrzoYwocClu0DI5guPDb43Y2LLp/Iaqf9JCGSErGvIifxd7aqQn/TOJCvFvZ8Hf9haEH+m/6sFQgHBv1Sts/15WmJLkeyl6FuFwFPzny1/ZdE7Nfg/xhv1uUmH2w6kggQp+yqze7d5JbZ8Im+KpucSwI6EN7/cYtlxZarBCts3ptfrtq9odjaGKihE+sV0vRC3u8RqWmmbij149W+Wd5p2rnET6bsqsntyb6+pO3KqkE8FvLxo74lNUX9s9uTJb8/9fG2L81KoogJFYfCm3b9usNq0MXxzw1RsUkDqQICPqf/b/q8sQi3j4WdmtV47OFgNAO6r+DEUFAtFAc9YtpXmRP6hxVsI24cvhyoqnFtrK6jM7isgBa3Dl0O94TeGb255MvzXpUIFjVrhxo/dzgoARBuwFQJkBK9reCnurxfvXX8CRW3yW1G749vT2Br7ysW0oNX1pKDTPG+rm1gHRbibAHLm/7522sKnQCZqFgCUaBCqaS/bEw9vqtWoQROf3dBBiT6KTACImZ3YueqhDdOWjDbFQ4IzIl4elNUX5begU1HD6lPRmULKeghhDcpqnUmZuD3+nkgTH6gZEE9ctlZSoGmG9UIynSCsQVndMyX+IZGiBoHMjHh2SreCglClaSBiSEG8cYnD24bv7CWms/3FocO3hnw13plTggAFb196NdlPM44tC0zrSg5ItXmyEz070UEKCMRqQgkkBQ9NvL2eSJ+revoJTORSpoT6do4/7/7UShBFHQexM+HdfyUHWO8iN/uaRzX3/QjUSLlnqM72F4cCRIY5u9Zf+Y+BAv4AvzpkQ7WAIBRujA/7Vg6cia9xlId6InafVEAAGnQMUCSkb6zTMPdBy8hU3JjrphIq+CrD+Mvxeyumrr+4IH9y7o2GF5eDghuuGx4L2zbWZ9Dc0RoQRbkkFNRdP2/0BH7EtLJLKCjr+zqh2l5u8haZ847vTBW24kRFQXKAtcsT5oqz3igQENIoECkjBJUDZSGewBlBj/ammjLrdX1c/t70ero34gMte9IByLLAjPrUwKweT5jawQshdIuGMiF5XEBU2koivBl9NeEfJeYHwuxtI81zPrn2z6ip60c6DkV1jLTOCTaE2HNjd5Z4s9MwWBOhqEHp/I9cWDtUrJNoHm4KO9P7hdnTBoMYXI8Gb6gVCg63FS53jg9O5tA57tSOdHywnCAygrJrfcTgUe5U2cvNHSPtYYoKCWlrTgsIneB2AfFR+4F4b6f9ZdTzF6P8Ytud407/dy/nL7k9X9i8J9l5y+Ef6RfbnjPvWa8N5suez+KFCgqyPY95Lnd3stv2AcBZ2+mFbze+lui1xc3dXCUUlPafXNx4/aKxcajWWNp/MklRw8/mPFntbd+h1oLE847KhQQxejVg36QQqD0MPTzHv42Ux+uGasJNBnPfwllJd71kkX7RQ3WDNf7dox3BLcNNs6vt34bbbvYHJhlTGp6O+JVHb0/2HJtX1PH+aqECqG/5YN1nlXcokGvvO6vCc4x+QskotxVHB/qa+xbOWuzw8NB3nuo+Ht0z2hHsuGU3GrWAoZfi3jrxgHpw3BPpobaCH7vbqOw6mHI836vYW3Eqcq9AtioqbJy7ufQ3lhfu8sR+s9+3vL8klACsQSu7AnxMY1MxH7YXJp7oPpLulrrj+9575Ni2aeVt1teWfEWfHQLCaspseHzOU7VWU+aM5G2NoyL4i+6j8XWDNQsmGsKu/cv+nTtjQb/mm7hfENyvqEAK5v8opjPJaL26KGBpd5TfguuBvuZRgBgY6zO0jlyZXXe9JqR+8MK8ntHOMHfHIkhu2b/0yIH7/oXJ0yFlxYnPUdRbvuILgO7+y+91l6Ka6M+cnCf4fMSypXvymHf/vzBTD3CuNGUFKT8lmK5Rs5ASqKiBlAGBXFaiSuni0fkp1pJ7Ed4e/xsAqLk46EWsG1EAAAAASUVORK5CYII=');\n    bottom:10px;\n    left:55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-left {\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABt5JREFUeNqsl2lUlOcVx//3Pi9DZRsGBgYiS2RYBQKIjAhEJW4pNrXNMbZpWtTGNkttYmJMG5soSZckRk+0p+dYPYY0Gk0ihlhRj63GhVUgBhDD5oIOy8AAMwzD4lCYtx+GqCQKuNyP7/Pc+3u2+7/3JUzEZFBYLh62S7yIZDmVBEIBqOwsQ4DNdtBFASq2A4cuZAwVgCCPF5LGHM0Chz+E1XamzUyAzCMO7IhMI+5MDCK+HpCANd+U2rYgC/Y7BoflYgVA2RAOoNYtyjDTe45+hk96e5QywaJR+NsAwDhocK61VCjLTYWaclNB0OW+en8mhl22g8C/rn7U+uGEwdov+C0i+Q0mIFWzoD7zwVU1czQ/6pjIreR3HPX5VL9jalHXiQgmBoH+XLHAtH5csDaXtxDLLzIBv5jyfOmG2H9U4S7snbpX43KaPpgBIhDx1rPzOlbfPC5GQT/nd1mS1zABa6PfPf5y5F/rcJeWpp7fPkly6f7KXBRCoOSATFfXll19x74HDsvFCghsJAG8HrvlvytCXm7EPVqc5wyzp5NX15muE1omKXXyMnd9yy5r5Q3wPghvJzrLAlimXV38+7D1DbhPFq1M6O4b6rPVWKsCBfHi5EWWv9TkQBYAEPpLvERMC9N8FtRvjt9dPl6wwo5jPvuas7WV5jNqEjz8wA+CBsaan+w9x1hrrXJtuaZX97ooLfqPLCUEGRR+iOwAsF2X98Uc30W3fb02u41frVqeVmo6FUkkwCAwCWxJ2Ls/0TPFNBb8TNdp9WvnVz4OAKdmX2QOzcMsAAjziDGMBd3asCF6SXHyknJTfqQTK+zpvhnVKT5zawCgzFTgN94pJXvP7gxxjTAIkpB+MnSWRMQZYEDnPVt/K4ejbZ/77726Lb6h95tAAiPELaJ1bcTbRfGeM8xv1azWSeyEa0P9igk+Nr1+oNFfkpwzJCJKIQA679ntN08yDXYo3qh+LuUrc0E4EcNL4dP7VNDzpU8FP3vpekoQQ5CEw4bPdEfa9+sAgEZUmkmAAAS5hLQ9p11XGO+pM8V5JLUfMeQARDMlEMKIGFOVCZYb0C7Fz0oeXmIZ6nZzYoV9od/jVS+GbahUOnn9b7T6sEOviUGyA8bMDlUa0W79wBW/bZf+lrY98cDBUI8YCxGDgHCJiVVEDN8R7QWAE8Z/+1mGut2i3eP1r0S+XRztkdBzq6NbF7WpbF3UprKxjvfHxbrfttla/QBArVDbJJIAQCURMRg8ugrKIAKBSNxzHtN3VdmxY0iQYSZmTeegwTlgknYAAB7RZBh2Nm7urbeeC1r19ROT52kWn3shfH2Fu1AO3RxjY/0fdac7/hPPJMDE11GC+HpBJmIEuAS3Oa6w01lybMbMgvgCE6O255zy24DeCr/Bvckn9+u8ZjXYIYvjxoMJy8oeXZrT9GHIqMWTwA2oI6cFMeDIcAiSEOyibXsmZG0hAFzuq1OyY6xBAnMJgdPOmks08zU/bbsB9x18P37PqS/b8+o/a96ZcLm3PmBH46Z5x40HW1eFvl4Uq0w0MwiCBOb7/qTsd6GvVY537DXWas1Iw1AiNJnOgwJi+bXhAbE08OnvaXSIW0TvYw88eaF/uM/WNdju3m5r9TlhPBzVNNDoPGC/5tRma/GJ80xqjPPUjVuvP2narrMOWd1Jlv/E1fN782UiNPZf9C/qOKa+ndOz2j+cz046sn+6KrVOsODirpOxld0lUxmEBK/ktvGgFd2l6taBZn9BAtEz5xYIvAn4/8rFKkgstAyZ6Yf+S67ezlkiSU73XXRV6xqh93TyssR4JF75efBvymLdE03jgT/Wb5tutLWpGbTm7wHZxQQAT+yDuKLyHRIk4cnAZ4pfCF9/HvfR9uh3xBxtz00BANsVDylnac6wAICaHMiBmW5NRLy4trcq0MtZ3RnpHme5H9AvjYeCc1t3pzMJgOSVnyw4eHZUB9Kyu68iMFPpysSppab8UJVC3Rnp/pDlXqF7mnYsdKQbv7cr6fDGW/Zczbt6jgUtV6kIlFxuyg/tH+6zJXmlGe8G+mlzdsyB1j3pTAwZ9q3/Sspbc9tmDwD0H3UffXCFlyuTlFpnPRdYb612c5c8+idPCu6fCLDKUubzsf6fSaWm0wmO9hbvZU8fDR2zoZ97OuppAu0UJEDEmOISZohT6q7Gek5rD3GN6FEp1DaAYB7sdNYPXPao7anS1Fmrg402g7+jYhGIaOXOaQc+uONfmCwZXJIf8xKx2KRgxYgOS+CROuyoyQKCxIhkOr4T6JWgxGnvZ1HWnf/CfHcBXxcnpRHxYwRKkUjSErFKkAQiNjP4kmBRTHbKm5KkKxwL+K39fwDX1XGF8ct++QAAAABJRU5ErkJggg==');\n    bottom:10px;\n    left:15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-right {\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABs1JREFUeNqsl3tQlOcVxp9z3m+XygK7C4sLxkW5o4CAkYssFSkRjabjJEOSJm1IbZx2krapiZdeprW0NVVJ0pqMM0kYJQlqkoZImGioE1ItiCAgIsFwE4Es99vCslwChf36xy5EW1A0Pn9+73fO772e93kJC5EMCszFd20SbyFZNpJAAACtjWUI8KAN1CRAJTbg9LXNU+dBkG+Xkm7Zmg4OWoUdNqZXmQCZHQFsz0yOcCYGEc8mJGDnl2UTh5AO2x2DA3OxDaAsCDvQ32VF11qP9aZYz6SeFeooi17pPQEAvZNdTnWWKnWFuVhfYT7v0zza4M3EsMk2EPgnNZusby8Y7P8x/5lI/gMTYNSnNKQt/0Xtev1DfQtZlaK+M54fmDJXXhg4G8zEINBfqlLMe28L9s/lQ8Tyr5iAJ32fK/tj+OFq3IUO1O+JyGk7GgsiEPFrlQ/07bixXdwEPckHWZJ3MgG7Qw9+/mLIS/W4SyXoNvQskpyHLg1e8CNQ3NI0laoje7Tg/8CBudgGgQwSwO/DD322ze/FFnxLRWhiBzUK94GLA2f9mSTjfU+7mjqyrVe+AX8I4aGgShbA0/47Sn4ZuLcR90ih6qih0anRiVprtUEQb43bYtlXmwNZAEDAj/ACMW1M8ExpeDXyWMVCEl4yF7vntR/zLeov8JJlWfZR+Y3N92+cx/reOmu1quNrk27EWW0xvWspJcigoNNkA4C3Yk59vH7xltvu3ktDxe7PX34ilQCQfeci1j2xfn94ZrGCneY8uxcHCnW/vbr9EQD4d2ITc8AprAOAQLewroVAAaB8oMiLiRHvmVy7znNTjWCFrXKoJOSHFQ+kvnF9f+jco07s91MFdwmSkHQuYB0T8WYwIcYj0bTQdRufGlFKJMFVaCb/GvZW6aGI4yeXOwd2mr/u05zsyDY+W5X64Nm+fO85NpuJiCFJTpslIoonADEeiT2zIzIXuh+o25PQNtbsNVMOBUn2g08MiSTHN3uZjNTEDr4dnX/6H+1H/XPasmKvW+sMGfW/MXzende4K3h/ibvSYxIAItyie/K7cgCitQxCIBFjpTrKMgM+WPfrhLbxFi9iMQtlYjAJSCSBSYBAIPBNI3p86TPXj8bk56R4PVylFE626uFLQc9efiTVPDmgBIAAtzALEYNBQRITa4kYix21FwBax655CVagPLk7806Pj1qo/7MraF/FQ14/aMhszYhvGqn3KTef89rklWrSKXUTkn3mtJK9Bzf3XJA0e/PcrdgxIwSCDPmbZMQgABJkDBKzvn+yy2npIv9xAPB1Ceo2jTZ7Gc8afipIgEhAkACDwcSQQZBIIGnx5it7gg+U3wgcnbZKR1r+FnW+v2DVtDwtXCXNSKz797oAwDzZ7ySRAIBBFsTXmBh1w1+oZ4J3h+wv9lUFdbMDOrO+5IAqWIGZthuV13nC77nKRx8r7PssyibLIkoT1/h65HsfzWyu5tF6NYNB4EYJzKUETqgcLNVv0D/cDQBrNAnm9+LOfTLfNB5u2hf5z+6TMexYji+tVdrM5leMbWOtSwQx/F1C2rcuebIqwSO568a4WmuN3mEYSiUi+pRl2l1pLvYBsKArUKVwnZRYgdHpMWVG4+/WXhwoDBXE7OmkHzJ6JNemLfv51bniGqzVPoIkyLbpfK7ZMFIkE6FlrMn7Ql+BbiHg+zXGbgLjylDpyosD58KZmKM0cfWHI9//aD5o1VCZrnO83VuQQOja5PMCfwK8n3K2ChIbLVOD9KB36le3A+u/s2Q81C2yRavQmQNdVnamLnmq4nHD9jpB0rwm77jpjTW9E906Bu18fWlWCQHAox9CtGoXTwmS8IThZyXPB+29inuoE6bMsDM9ufEAMNHqJuU8ljMtAKA2B7IhzaWNiLfWjVQb3J10/SGuEZZ7Af1X7+lluZ3HkpgEQPL291M+qbzJgXQcG60ypKlVTGwsMxcFaJW6/hDXVZZvCz3RlrmRiQHwy9nRn2bM6bnas4cLfH6s1RIorsJcFDA2PToR7Z7QezfQD9qzwvI6TyTZC47ttXeiT+2c1+wBgOndoTPLt7mrmCRjvfULQ4O1xsVVchu7b9GysYUAqy3lnsdNb0aXmQuj7PYWL2etuRl6S0OfXLjiGQIdEY6K5esc2BWhjvkqXLO6x08VPKxV6iYAwuBkv5NpvNmtbrhaX2+tWdY70eVNINhtLW0/sjrv6B0/YdJlcGlR2AvE4hUlKwHQ7BU5cz8LRx0HaPY7gXb53L/67+mUfudPmP/twOWS6AQi/j6B4iWS/IlYK+yGYJDB1wWLErLRKd/omOJbAWf03wEAyO9m+/TtS3AAAAAASUVORK5CYII=');\n    bottom:10px;\n    left:95px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomIn {\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABiBJREFUeNqkV2tQlOcVfp7zvgvDRe66y8htXUBR1GoFI+BtFJvRtjPJBGeaH2a8DGmbttgSTWbSJEw6TWOsrbbpTIeJZGqaTipTa6LJZDTVUTYQdNAohoso6qLucnERN0Axcb/8+HaJUHDX9Pz6vnnPe57vXJ5zzkeEIwaYcwBL/VrW0TCKqZANINEvBhSk3w9eUmC9HzjcsfarOhBGKJN84GkVJHcetvqFu4SAIYELYlpm4LpQQMqoQQKVnzeO7EYV/A8NnHMAGwHWQJmAjtg895LkFa7FU1d258UvGLBGpI4AQM9dd2TrwNn4016n9bS3LqNzsD1VKPAbfhCyqflR31thAzv+La+QxotCoNi6pn1D1s9aVli/3xtOVk72fjT1XVf17E9uHZspFBD8zdk13pdCAjsOyG6KUSEEnrT/tPHluW+cw7eQ19q2z6/t2rsYJEjZ07S6d+ukwI5/yQ7RxnYC2DZnx8dbHNs6xxs85T2R9GprZcmVwYs2BYWsmBzP83m7nIVJS73jdfdd+7PjjUu/XWUCGTtPre7ZHjxTY3Kq8DoV8Ou5u49snPGrKxN58syZ9aVXBztsigoUBd+Xt2NbfZ8llaVvah+vOz9hcX+CJenWp7eOOYS6ePpTU1w39vk+AwCzFPdDQbFGFPCUY2v9hqxfXJ0shNeHLtsUFc6UequbVvdVkwLX0GXbZPpl6Zuu/ij9x/VCBU1dU7bfdFYAIDsSFRCgeOqa9hfy/nDhwfwTKOrRd0U95n0iqch9+cKS5JVtpMCdkllhAhugCHcRwAb7z1tCEp8CCXAWAJRoCFXIYnti+sYWTQ0tll0wQMk+hGUAkBOX714xbV1IyuhxHhIMC/iR5OV9M2JmuhU1Vh7PXiakrIUQhcnLXeHQxPT4GyAtFqgwgAPF5iIFWkeu1SSLCKAweXn3/ZR5rXV7SddQpy3YDoNems9qTI5hGCitm1MOAAx0aaFCerTd84zjBed3Egq9ADA/rqD7Q3ctQC4REDmkYHb8goGgsR2tz5V0DV+xUdQoqAQ81RybU4IgFWgACgpaLLCIBUo0bv63y/aXy6+WBHWz4/IHSIGAuVooiaRgWqD3AsDVoQ6bEgtOrfJUhwrf0WUtk+r8sL6wvHvk5ijVUiJSRrQZuURtfoGMuaCoRyfP/yMy0XykgAA0DPRTxNp31x2ZFuUYBgB7bK7HNdhpKz6WXq6oQCooKghMKhkgji77vBoA1jkXlAvVfRQjFMUcmxSkRWd6gpjeu32R2kxTvyhKh1DQeud8fFBh26zfOe0xuR4JgAbzywCoRSzfeDUKatJKUQK+CjKiHZ6nZ2xzBnU7B9vixTy7qCHSQEhJU3+DtdT6mAcAFiWUeP/xyPH3Jwrfo3XzysemRcEA8F5RY8h6aPE1WwMLQ4OQ/EBANHmdGWHlzZyxk3ayB0m771yGooYy+KE0l35x0iBxZehS6ie9R1PCMaDvCzWDXA4hZ283ptwcvp6qqDBnyao6AWEQrBQQ/7y+d3YoA+NBTAaElo973p8tVFCQyipW+c3pdNu7BwBOe+tm/eniK/kPFWowpMfvuKrzzw80zSKIkWsJe0bHYu163BNwMwDsv7G36ODNtzMnM5IWZfeQgscbisvLPl1aDhLTo7I8k+n/p+dw5pGeg0WKGiS31K6vvTdmA7nx9uDZ9A3xMUIpbvSezE6MSOmbNWXewHhD6dH23o7BlqQvvrwTK6KQFpXl2WyvcE6LTB2eCPSdrurvmcUnO/cVfPD6pMteyfGs3QKpUFQoS9tU/xPH8xe+Tdd693pN/pHug0Xmqntvz1uLDo9Z9v5nnrn+dvujrI1JMUJd3OY7n97ua46douOGpkdlDoUDeG7g1NS/u/5a0Og9scCsB+ysWXSoMuyFftWJvM0E31SBjmWPznHPjy+8NjdhYfeMmJl3EiNSRgCi/25fpGu4M671zjlrm685s2fEnUoQ5lrLLW8uPLj3oX9hqgxIw8n8X1LU7yMkItCHzREZrGQV6ONmy5TggHk247sL/1jFqof/hRn/AWfqC0pI+QHBIk3tICXRrFTpF8hlJaqefh6yFxQ6HwQYlK8HAKyt3WsWxl7fAAAAAElFTkSuQmCC');\n    bottom:10px;\n    right:15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomOut {\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABV5JREFUeNq0l2tQVVUYht/3W/vACMr16IFRQDiAgChpgiikMqY1WjnN9KsfGOXYTOVgkvbDUsZuXrK0qZmGUSvNspjI8TZOmo6AGBoZYly8YB6Qw80DBwQ6jJ3dj30OZZmiwvtv77XW96y91l7v9y1iMNLBuCI84tZkIXU9gwqxAILdokNBOtzgJQWWuYEDFxfcLAGh3y0k79iaD4mfjOVu4WYhoItngBiR6RkuFJAyEJBA3m/lri3Ih/uewXFFyAG4A8oAWkcm2meEzrFNH53Vkhg4xWnxCXcBQGu/3bfGeTbwjKPUcsZRElnfUxcuFLh1Nwh5vurx7s8GDbZ+L+tI/U0hkGGZX5c9/pXqOZYn2gazK8Vth0fvsRUknbx+bIJQQPCts/Mda+4KthbJFoqeKwSejX6pfO2kjytxH1pfuyqlsGH7dJAgZWvFo23L/9muboF+JxtE0/OEwMqJG46uSHinFvepTPO8lhGaX+fPHSdjCKaPy/b3v7az58h/wHFFyIHCRirgjUlbfsiJWXEFD6iUoOkdQaaQ6z9dP2YVahljF4+yXdvZ/evf4G+hQk2sEAUsti4vWxa35gKGSBMDp3T23OxxVXdXRijKovSFzrerC6ELAMT6IhcCZIyeX7c68YPzGGLlxq89PyM0q5YU2M1RuQAg0EERbiaA7Ohl1RgmPTM2p1qjBk1Mm6GDErsfswAgLiDZPmfMwrbhAqeHzm6P8Z9gV9SQdTx2lpCyAEKkhc62YZiVEjTdRgo0zXeBRnImAaSFzm7xdjjtOBGyvmZVZkNvfZjXDhU14+BToFEDKRAQpAJ0HRTjP6XHpYUKEX7RzS9bV5c+FJTmAICUgNSWQ/ZCgJwhIOJIQVLgFKcXvKHm9cyGvithFDUAFQqECho1CBUIggYapAJ1QEFBExNMYoISDU1/NIR9cvndTG/c2IBkp2fC8ZpQgknBGI/3AsDvvRfDlJhwem5zwYMs7VNlaUtbXE1h3mezj9mlGSsXrBkzkFsGKGoDmedBJLfLjxQQgAYdHRSxtPfbfceNsPYBQPTI+GZbT31YxrGIpYoKpIKigkAgFOggNBrbQBBCBaEM2L+iGGmTgnF+Uc1epqO/3VejAoAOUZSLQkFN17lAb4eVCe+VRvvHN4sH6t1feqAmMUGoPHvvhdLzTjzfKoj0sza/GLOy1Bu3vqc20Pgl5YIGkVOEZFZ0nLLMszzdDADTgjIdX6Uf3zfUx6m6u8riKRhOCcmDAqLCURo53Oe4rrsyUlGD0nlIqubdKNZJXOm9FH6y7Yh5uKBnO8vNTX2N4YoKE2fMLREQOsE8AfFN4/ak4QIfbd2XJFRQkLx85ruN7NTp2AoAZxwlCR9dWJc81NDdtoLkc86KBIJwXQ3aOpCPqwuhR2SPbCBlUc2NyogQX3N7wqgU51BAf2w9EFXUtCtLqADqS76ev6/ilgrk2q6esxHZgf5CySh3FMcG+5jbE0ZNdj4odHdDwWPGcZNNO1MPbrxtzdW4s+tI5HPBwQTTzziKY3v/7HGlhmS23g90T+OO5L1Nu7MMw3Fv/Tx1f97/FnsAYPui8/D4nBB/oZZR230uoq67auQoLaB37Iio3sEAK52nR39p+zS13HFiilHeYtOOabdC71jQzz2R+ALBbcrjWNF+cfaUwLSrk4KmtsT4T+gK9jG7AKKjv93X1lcfUNNVaantropqddnDCcIoa7lk29S92+/5CpOvQ04VJ79KUe/7iI/Hh40U6c3PyuPjhmWKN8G8Fvnw1A/zmX/vV5h/T+CXstRMUp4kOFOjZiUlWBkFQYdALitRZXRzf3RqWumdgF79NQDBOa2V/iYSHAAAAABJRU5ErkJggg==');\n    bottom:10px;\n    right:55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomExtends {\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABptJREFUeNqsl21QlNcVx///cx9hIipuAJHasgHlRdw0xay7yK7smg6sb2DSdtqZduLUNENmOk1tQuM4U7UzTvshSRlFZzoNCWSSSTJp+6VNkLCAeQHBoCCgqNBE0wUqL+KuwIiiZZ9+eHa3aAS3Sf8zO8/L3nt+95x7z7n3YWlpKUQEJAEgch9+Jola9xEC2ADBVgAOKqwCYAqKDgUJBIHPBWwFWQNdbyZFBwAC0GGIAHQSj3/8HHRdhzYbdDfwg4IjAsGvICgXAroYBiCEDkBBACBZoyST4gDwQqh7mQ4cEkhQD0EBIIggRMQAh2EiEvEYAGrdR3YSqIYCIEDaotVDeYnu/ryEjSOr43PHl8WmTBPA6PRQ7IWJrvhT/ubkU/7m1EvX+1KEUh7Ug+WkPEXgdUSkR+xrd0NJ4qjr8AEI9pGAI7mo78mHfnF+Y/K2K7iHUheuvJG6cOUNz/LvDwPobrpSl/Ruf2VOy9UPs4RSTSANwH4Y449EVdnt9ojHIeghCHYLgR+n/7zt4Np32tIWZU4hSpnjVk1t/caPfOO3/f++MNH5TVJcisoEoo4ksgbsXwYfdR1+kQplQuCFNS82Pp/9+158RTkTC0ce0OKutQeOp5PME0qcUBqyBmwGOC8vz4AWVOyE4CUqYO/Dh+p3pj//Bb6mHllqCyxd8ODVT69+uFKoOYTSnzFg7SJpzHFNQYWiQrUIsCN9V+uOh375zz179pSGI1FSUuK12+2+aGDt7e3muro6T/h57969lZdvDrT+ZbA6n0B1nfPVN7e0PjMjIgIIdkEAR1JR329yDvaE0+l/hQKA1Wr1bd682SsikUW7K+O3PesTNvaSAiXaLhGBvO86RFEoJ4Adac+eDxsgiZKSEm9NTY3n5MmT5mjBHR0d5vr6es+mTZu8SqnI+x+s+Ol5jRo0auX1jtepQaEAADKWWIbcy7ZGUmb79u1eu93uI+mtra31HLj5TGDs9rBJICCNn1GRCKGCUJAUuzzw6CfbTB6Px7t27VofAG/YXl6Ceyw9LmvIN3UxZUafKRACWyCELcHVP3vk4fDabDZf+2N/D9g+fsLEEFSooFGDogZNFkBRgSCsTcWm066jgRAU4et/F5u9nxRosmCLRmE+QdgSXCNzhW/s9rDJ63wVJx77V+V8YS6UNaW8BdOcqzx+3Ujt0F8Bcr1GMIMU5CzJHZ+rg6IGCYV2PimoyIK6lzIWrxkPTVGmRoqJFCyLTZmeq4MB5f3BVADnbpcQkzStUQMAk0YKBPfzxlhA95NQQe43QBotBECAFFyZHo6dz6CKCizAPFPivzUWqxm2AqIgnwkFvZNn4uczGK3Hah7wpet98UZ85R8aKScIcXYEWpMLkx8fvleHpNjlAWtTsakQa0pVKGcJQqMGUqCHBvfdjp/gTP6xwFzg85PdyaH2J4SUowKiw3889e4KBACnT582W5uKTV2uusAdUFlgzBcFQoFGDT35HwW+82mhqaenxwwA4WtYfRNnUkMZUqsJpEkn8cXU5yktYw2JjsTCMQDwer0ekt6GhgZPUVGRd3fu7qjqdU9Mj7mlpcVD0tvS0uKxWCyVANB5rS3x8s3BFEUFgTTLtuZndQHLBMSfB6pyZtfqMDQ3NzfqTcJisficTqc3BI+8bxh9L8corarM3fnDoIT+rACAU/7m7MOfHbCEwQDQ2Njo6erqinqTOHfuXNjjiI23+ystZ8c7smmkWgVJcN++fRARfLDhlacEUqVEQ1nm77xPrHjSh/+Djo3WmN/s/6OHEOgIPr2h63tVuq5Dud1ukETWoK3zorkzTiiONn/TKlNM4lj24m+Pf13o2wOVHqGA5MsAXjKPrDaqnMvlQnjTzhy0Nlw0d5oI5p3yN62amrk+ve5B5+hXgb47WGX52+V3NgoFOvQKAGUkkTqcbZy5XC7XHYf4zEFr3aXU7jih5uidPPOtvsmzixZr8VMrHjBHddLsHj+Z9Fb/n9a1+T/JDaXey0IpEzEKkHnU8Jj79++PeEwSSimQRGP+Gz8j5DVFBVKQtjBj6JGlNt/D8Y+OpMdlTphiEqcB4tqtsVjfjUtLLkx0J/dOnjWPTg+lEARIEHwaQJVQIYggACC/qxi6rn8ZHL4XETSsf0MU1HOk/CFGYgAwskUqY5eBitRxzn7/a0V1EEBwdqkN6jPI7y4xPmHmC5unbWdQRMqP2d86qANOksU6gvmArNQRNClqABnQgYuK0krI+wCOAyH3DK/vqOXhaf3PAO7mIRjDNV25AAAAAElFTkSuQmCC');\n    bottom:50px;\n    right:15px;\n}\n";
    styleInject(css_248z$1);
    NavigationHandler = function() {
      function NavigationHandler2(body, canvas) {
        var _this = this;
        classCallCheck(this, NavigationHandler2);
        this.body = body;
        this.canvas = canvas;
        this.iconsCreated = false;
        this.navigationHammers = [];
        this.boundFunctions = {};
        this.touchTime = 0;
        this.activated = false;
        this.body.emitter.on("activate", function() {
          _this.activated = true;
          _this.configureKeyboardBindings();
        });
        this.body.emitter.on("deactivate", function() {
          _this.activated = false;
          _this.configureKeyboardBindings();
        });
        this.body.emitter.on("destroy", function() {
          if (_this.keycharm !== void 0) {
            _this.keycharm.destroy();
          }
        });
        this.options = {};
      }
      createClass(NavigationHandler2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            this.options = options2;
            this.create();
          }
        }
        /**
         * Creates or refreshes navigation and sets key bindings
         */
      }, {
        key: "create",
        value: function create5() {
          if (this.options.navigationButtons === true) {
            if (this.iconsCreated === false) {
              this.loadNavigationElements();
            }
          } else if (this.iconsCreated === true) {
            this.cleanNavigation();
          }
          this.configureKeyboardBindings();
        }
        /**
         * Cleans up previous navigation items
         */
      }, {
        key: "cleanNavigation",
        value: function cleanNavigation() {
          if (this.navigationHammers.length != 0) {
            for (var i = 0; i < this.navigationHammers.length; i++) {
              this.navigationHammers[i].destroy();
            }
            this.navigationHammers = [];
          }
          if (this.navigationDOM && this.navigationDOM["wrapper"] && this.navigationDOM["wrapper"].parentNode) {
            this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);
          }
          this.iconsCreated = false;
        }
        /**
         * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
         * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
         * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
         * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
         *
         * @private
         */
      }, {
        key: "loadNavigationElements",
        value: function loadNavigationElements() {
          var _this2 = this;
          this.cleanNavigation();
          this.navigationDOM = {};
          var navigationDivs = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"];
          var navigationDivActions = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
          this.navigationDOM["wrapper"] = document.createElement("div");
          this.navigationDOM["wrapper"].className = "vis-navigation";
          this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);
          for (var i = 0; i < navigationDivs.length; i++) {
            this.navigationDOM[navigationDivs[i]] = document.createElement("div");
            this.navigationDOM[navigationDivs[i]].className = "vis-button vis-" + navigationDivs[i];
            this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);
            var hammer$1 = new hammer(this.navigationDOM[navigationDivs[i]]);
            if (navigationDivActions[i] === "_fit") {
              var _context;
              onTouch(hammer$1, bind$2(_context = this._fit).call(_context, this));
            } else {
              var _context2;
              onTouch(hammer$1, bind$2(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));
            }
            this.navigationHammers.push(hammer$1);
          }
          var hammerFrame = new hammer(this.canvas.frame);
          onRelease(hammerFrame, function() {
            _this2._stopMovement();
          });
          this.navigationHammers.push(hammerFrame);
          this.iconsCreated = true;
        }
        /**
         *
         * @param {string} action
         */
      }, {
        key: "bindToRedraw",
        value: function bindToRedraw(action) {
          if (this.boundFunctions[action] === void 0) {
            var _context3;
            this.boundFunctions[action] = bind$2(_context3 = this[action]).call(_context3, this);
            this.body.emitter.on("initRedraw", this.boundFunctions[action]);
            this.body.emitter.emit("_startRendering");
          }
        }
        /**
         *
         * @param {string} action
         */
      }, {
        key: "unbindFromRedraw",
        value: function unbindFromRedraw(action) {
          if (this.boundFunctions[action] !== void 0) {
            this.body.emitter.off("initRedraw", this.boundFunctions[action]);
            this.body.emitter.emit("_stopRendering");
            delete this.boundFunctions[action];
          }
        }
        /**
         * this stops all movement induced by the navigation buttons
         *
         * @private
         */
      }, {
        key: "_fit",
        value: function _fit() {
          if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 700) {
            this.body.emitter.emit("fit", {
              duration: 700
            });
            this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
          }
        }
        /**
         * this stops all movement induced by the navigation buttons
         *
         * @private
         */
      }, {
        key: "_stopMovement",
        value: function _stopMovement() {
          for (var boundAction in this.boundFunctions) {
            if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {
              this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
              this.body.emitter.emit("_stopRendering");
            }
          }
          this.boundFunctions = {};
        }
        /**
         *
         * @private
         */
      }, {
        key: "_moveUp",
        value: function _moveUp() {
          this.body.view.translation.y += this.options.keyboard.speed.y;
        }
        /**
         *
         * @private
         */
      }, {
        key: "_moveDown",
        value: function _moveDown() {
          this.body.view.translation.y -= this.options.keyboard.speed.y;
        }
        /**
         *
         * @private
         */
      }, {
        key: "_moveLeft",
        value: function _moveLeft() {
          this.body.view.translation.x += this.options.keyboard.speed.x;
        }
        /**
         *
         * @private
         */
      }, {
        key: "_moveRight",
        value: function _moveRight() {
          this.body.view.translation.x -= this.options.keyboard.speed.x;
        }
        /**
         *
         * @private
         */
      }, {
        key: "_zoomIn",
        value: function _zoomIn() {
          var scaleOld = this.body.view.scale;
          var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
          var translation = this.body.view.translation;
          var scaleFrac = scale / scaleOld;
          var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
          var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
          this.body.view.scale = scale;
          this.body.view.translation = {
            x: tx,
            y: ty
          };
          this.body.emitter.emit("zoom", {
            direction: "+",
            scale: this.body.view.scale,
            pointer: null
          });
        }
        /**
         *
         * @private
         */
      }, {
        key: "_zoomOut",
        value: function _zoomOut() {
          var scaleOld = this.body.view.scale;
          var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
          var translation = this.body.view.translation;
          var scaleFrac = scale / scaleOld;
          var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
          var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
          this.body.view.scale = scale;
          this.body.view.translation = {
            x: tx,
            y: ty
          };
          this.body.emitter.emit("zoom", {
            direction: "-",
            scale: this.body.view.scale,
            pointer: null
          });
        }
        /**
         * bind all keys using keycharm.
         */
      }, {
        key: "configureKeyboardBindings",
        value: function configureKeyboardBindings() {
          var _this3 = this;
          if (this.keycharm !== void 0) {
            this.keycharm.destroy();
          }
          if (this.options.keyboard.enabled === true) {
            if (this.options.keyboard.bindToWindow === true) {
              this.keycharm = keycharm({
                container: window,
                preventDefault: true
              });
            } else {
              this.keycharm = keycharm({
                container: this.canvas.frame,
                preventDefault: true
              });
            }
            this.keycharm.reset();
            if (this.activated === true) {
              var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;
              bind$2(_context4 = this.keycharm).call(_context4, "up", function() {
                _this3.bindToRedraw("_moveUp");
              }, "keydown");
              bind$2(_context5 = this.keycharm).call(_context5, "down", function() {
                _this3.bindToRedraw("_moveDown");
              }, "keydown");
              bind$2(_context6 = this.keycharm).call(_context6, "left", function() {
                _this3.bindToRedraw("_moveLeft");
              }, "keydown");
              bind$2(_context7 = this.keycharm).call(_context7, "right", function() {
                _this3.bindToRedraw("_moveRight");
              }, "keydown");
              bind$2(_context8 = this.keycharm).call(_context8, "=", function() {
                _this3.bindToRedraw("_zoomIn");
              }, "keydown");
              bind$2(_context9 = this.keycharm).call(_context9, "num+", function() {
                _this3.bindToRedraw("_zoomIn");
              }, "keydown");
              bind$2(_context10 = this.keycharm).call(_context10, "num-", function() {
                _this3.bindToRedraw("_zoomOut");
              }, "keydown");
              bind$2(_context11 = this.keycharm).call(_context11, "-", function() {
                _this3.bindToRedraw("_zoomOut");
              }, "keydown");
              bind$2(_context12 = this.keycharm).call(_context12, "[", function() {
                _this3.bindToRedraw("_zoomOut");
              }, "keydown");
              bind$2(_context13 = this.keycharm).call(_context13, "]", function() {
                _this3.bindToRedraw("_zoomIn");
              }, "keydown");
              bind$2(_context14 = this.keycharm).call(_context14, "pageup", function() {
                _this3.bindToRedraw("_zoomIn");
              }, "keydown");
              bind$2(_context15 = this.keycharm).call(_context15, "pagedown", function() {
                _this3.bindToRedraw("_zoomOut");
              }, "keydown");
              bind$2(_context16 = this.keycharm).call(_context16, "up", function() {
                _this3.unbindFromRedraw("_moveUp");
              }, "keyup");
              bind$2(_context17 = this.keycharm).call(_context17, "down", function() {
                _this3.unbindFromRedraw("_moveDown");
              }, "keyup");
              bind$2(_context18 = this.keycharm).call(_context18, "left", function() {
                _this3.unbindFromRedraw("_moveLeft");
              }, "keyup");
              bind$2(_context19 = this.keycharm).call(_context19, "right", function() {
                _this3.unbindFromRedraw("_moveRight");
              }, "keyup");
              bind$2(_context20 = this.keycharm).call(_context20, "=", function() {
                _this3.unbindFromRedraw("_zoomIn");
              }, "keyup");
              bind$2(_context21 = this.keycharm).call(_context21, "num+", function() {
                _this3.unbindFromRedraw("_zoomIn");
              }, "keyup");
              bind$2(_context22 = this.keycharm).call(_context22, "num-", function() {
                _this3.unbindFromRedraw("_zoomOut");
              }, "keyup");
              bind$2(_context23 = this.keycharm).call(_context23, "-", function() {
                _this3.unbindFromRedraw("_zoomOut");
              }, "keyup");
              bind$2(_context24 = this.keycharm).call(_context24, "[", function() {
                _this3.unbindFromRedraw("_zoomOut");
              }, "keyup");
              bind$2(_context25 = this.keycharm).call(_context25, "]", function() {
                _this3.unbindFromRedraw("_zoomIn");
              }, "keyup");
              bind$2(_context26 = this.keycharm).call(_context26, "pageup", function() {
                _this3.unbindFromRedraw("_zoomIn");
              }, "keyup");
              bind$2(_context27 = this.keycharm).call(_context27, "pagedown", function() {
                _this3.unbindFromRedraw("_zoomOut");
              }, "keyup");
            }
          }
        }
      }]);
      return NavigationHandler2;
    }();
    css_248z$2 = "div.vis-tooltip {\n  position: absolute;\n  visibility: hidden;\n  padding: 5px;\n  white-space: nowrap;\n\n  font-family: verdana;\n  font-size:14px;\n  color:#000000;\n  background-color: #f5f4ed;\n\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  border: 1px solid #808074;\n\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  pointer-events: none;\n\n  z-index: 5;\n}\n";
    styleInject(css_248z$2);
    Popup = function() {
      function Popup2(container, overflowMethod) {
        classCallCheck(this, Popup2);
        this.container = container;
        this.overflowMethod = overflowMethod || "cap";
        this.x = 0;
        this.y = 0;
        this.padding = 5;
        this.hidden = false;
        this.frame = document.createElement("div");
        this.frame.className = "vis-tooltip";
        this.container.appendChild(this.frame);
      }
      createClass(Popup2, [{
        key: "setPosition",
        value: function setPosition(x, y) {
          this.x = _parseInt$2(x);
          this.y = _parseInt$2(y);
        }
        /**
         * Set the content for the popup window. This can be HTML code or text.
         * @param {string | Element} content
         */
      }, {
        key: "setText",
        value: function setText(content) {
          if (content instanceof Element) {
            this.frame.innerHTML = "";
            this.frame.appendChild(content);
          } else {
            this.frame.innerHTML = content;
          }
        }
        /**
         * Show the popup window
         * @param {boolean} [doShow]    Show or hide the window
         */
      }, {
        key: "show",
        value: function show(doShow) {
          if (doShow === void 0) {
            doShow = true;
          }
          if (doShow === true) {
            var height = this.frame.clientHeight;
            var width = this.frame.clientWidth;
            var maxHeight = this.frame.parentNode.clientHeight;
            var maxWidth = this.frame.parentNode.clientWidth;
            var left = 0, top = 0;
            if (this.overflowMethod == "flip") {
              var isLeft = false, isTop = true;
              if (this.y - height < this.padding) {
                isTop = false;
              }
              if (this.x + width > maxWidth - this.padding) {
                isLeft = true;
              }
              if (isLeft) {
                left = this.x - width;
              } else {
                left = this.x;
              }
              if (isTop) {
                top = this.y - height;
              } else {
                top = this.y;
              }
            } else {
              top = this.y - height;
              if (top + height + this.padding > maxHeight) {
                top = maxHeight - height - this.padding;
              }
              if (top < this.padding) {
                top = this.padding;
              }
              left = this.x;
              if (left + width + this.padding > maxWidth) {
                left = maxWidth - width - this.padding;
              }
              if (left < this.padding) {
                left = this.padding;
              }
            }
            this.frame.style.left = left + "px";
            this.frame.style.top = top + "px";
            this.frame.style.visibility = "visible";
            this.hidden = false;
          } else {
            this.hide();
          }
        }
        /**
         * Hide the popup window
         */
      }, {
        key: "hide",
        value: function hide() {
          this.hidden = true;
          this.frame.style.left = "0";
          this.frame.style.top = "0";
          this.frame.style.visibility = "hidden";
        }
        /**
         * Remove the popup window
         */
      }, {
        key: "destroy",
        value: function destroy() {
          this.frame.parentNode.removeChild(this.frame);
        }
      }]);
      return Popup2;
    }();
    InteractionHandler = function() {
      function InteractionHandler2(body, canvas, selectionHandler) {
        var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;
        classCallCheck(this, InteractionHandler2);
        this.body = body;
        this.canvas = canvas;
        this.selectionHandler = selectionHandler;
        this.navigationHandler = new NavigationHandler(body, canvas);
        this.body.eventListeners.onTap = bind$2(_context = this.onTap).call(_context, this);
        this.body.eventListeners.onTouch = bind$2(_context2 = this.onTouch).call(_context2, this);
        this.body.eventListeners.onDoubleTap = bind$2(_context3 = this.onDoubleTap).call(_context3, this);
        this.body.eventListeners.onHold = bind$2(_context4 = this.onHold).call(_context4, this);
        this.body.eventListeners.onDragStart = bind$2(_context5 = this.onDragStart).call(_context5, this);
        this.body.eventListeners.onDrag = bind$2(_context6 = this.onDrag).call(_context6, this);
        this.body.eventListeners.onDragEnd = bind$2(_context7 = this.onDragEnd).call(_context7, this);
        this.body.eventListeners.onMouseWheel = bind$2(_context8 = this.onMouseWheel).call(_context8, this);
        this.body.eventListeners.onPinch = bind$2(_context9 = this.onPinch).call(_context9, this);
        this.body.eventListeners.onMouseMove = bind$2(_context10 = this.onMouseMove).call(_context10, this);
        this.body.eventListeners.onRelease = bind$2(_context11 = this.onRelease).call(_context11, this);
        this.body.eventListeners.onContext = bind$2(_context12 = this.onContext).call(_context12, this);
        this.touchTime = 0;
        this.drag = {};
        this.pinch = {};
        this.popup = void 0;
        this.popupObj = void 0;
        this.popupTimer = void 0;
        this.body.functions.getPointer = bind$2(_context13 = this.getPointer).call(_context13, this);
        this.options = {};
        this.defaultOptions = {
          dragNodes: true,
          dragView: true,
          hover: false,
          keyboard: {
            enabled: false,
            speed: {
              x: 10,
              y: 10,
              zoom: 0.02
            },
            bindToWindow: true
          },
          navigationButtons: false,
          tooltipDelay: 300,
          zoomView: true,
          zoomSpeed: 1
        };
        assign$2(this.options, this.defaultOptions);
        this.bindEventListeners();
      }
      createClass(InteractionHandler2, [{
        key: "bindEventListeners",
        value: function bindEventListeners() {
          var _this = this;
          this.body.emitter.on("destroy", function() {
            clearTimeout(_this.popupTimer);
            delete _this.body.functions.getPointer;
          });
        }
        /**
         *
         * @param {Object} options
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
            selectiveNotDeepExtend(fields, this.options, options2);
            mergeOptions(this.options, options2, "keyboard");
            if (options2.tooltip) {
              assign$2(this.options.tooltip, options2.tooltip);
              if (options2.tooltip.color) {
                this.options.tooltip.color = parseColor(options2.tooltip.color);
              }
            }
          }
          this.navigationHandler.setOptions(this.options);
        }
        /**
         * Get the pointer location from a touch location
         * @param {{x: number, y: number}} touch
         * @return {{x: number, y: number}} pointer
         * @private
         */
      }, {
        key: "getPointer",
        value: function getPointer(touch) {
          return {
            x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),
            y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)
          };
        }
        /**
         * On start of a touch gesture, store the pointer
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "onTouch",
        value: function onTouch2(event) {
          if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 50) {
            this.drag.pointer = this.getPointer(event.center);
            this.drag.pinched = false;
            this.pinch.scale = this.body.view.scale;
            this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
          }
        }
        /**
         * handle tap/click event: select/unselect a node
         * @param {Event} event
         * @private
         */
      }, {
        key: "onTap",
        value: function onTap(event) {
          var pointer = this.getPointer(event.center);
          var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);
          this.checkSelectionChanges(pointer, event, multiselect);
          this.selectionHandler._generateClickEvent("click", event, pointer);
        }
        /**
         * handle doubletap event
         * @param {Event} event
         * @private
         */
      }, {
        key: "onDoubleTap",
        value: function onDoubleTap(event) {
          var pointer = this.getPointer(event.center);
          this.selectionHandler._generateClickEvent("doubleClick", event, pointer);
        }
        /**
         * handle long tap event: multi select nodes
         * @param {Event} event
         * @private
         */
      }, {
        key: "onHold",
        value: function onHold(event) {
          var pointer = this.getPointer(event.center);
          var multiselect = this.selectionHandler.options.multiselect;
          this.checkSelectionChanges(pointer, event, multiselect);
          this.selectionHandler._generateClickEvent("click", event, pointer);
          this.selectionHandler._generateClickEvent("hold", event, pointer);
        }
        /**
         * handle the release of the screen
         *
         * @param {Event} event
         * @private
         */
      }, {
        key: "onRelease",
        value: function onRelease2(event) {
          if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 10) {
            var pointer = this.getPointer(event.center);
            this.selectionHandler._generateClickEvent("release", event, pointer);
            this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
          }
        }
        /**
         *
         * @param {Event} event
         */
      }, {
        key: "onContext",
        value: function onContext(event) {
          var pointer = this.getPointer({
            x: event.clientX,
            y: event.clientY
          });
          this.selectionHandler._generateClickEvent("oncontext", event, pointer);
        }
        /**
         * Select and deselect nodes depending current selection change.
         *
         * For changing nodes, select/deselect events are fired.
         *
         * NOTE: For a given edge, if one connecting node is deselected and with the same
         *       click the other node is selected, no events for the edge will fire.
         *       It was selected and it will remain selected.
         *
         * TODO: This is all SelectionHandler calls; the method should be moved to there.
         *
         * @param {{x: number, y: number}} pointer
         * @param {Event} event
         * @param {boolean} [add=false]
         */
      }, {
        key: "checkSelectionChanges",
        value: function checkSelectionChanges(pointer, event) {
          var add = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var previousSelection = this.selectionHandler.getSelection();
          var selected = false;
          if (add === true) {
            selected = this.selectionHandler.selectAdditionalOnPoint(pointer);
          } else {
            selected = this.selectionHandler.selectOnPoint(pointer);
          }
          var currentSelection = this.selectionHandler.getSelection();
          var deselectedItems = this._determineDifference(previousSelection, currentSelection);
          var selectedItems = this._determineDifference(currentSelection, previousSelection);
          if (deselectedItems.edges.length > 0) {
            this.selectionHandler._generateClickEvent("deselectEdge", event, pointer, previousSelection);
            selected = true;
          }
          if (deselectedItems.nodes.length > 0) {
            this.selectionHandler._generateClickEvent("deselectNode", event, pointer, previousSelection);
            selected = true;
          }
          if (selectedItems.nodes.length > 0) {
            this.selectionHandler._generateClickEvent("selectNode", event, pointer);
            selected = true;
          }
          if (selectedItems.edges.length > 0) {
            this.selectionHandler._generateClickEvent("selectEdge", event, pointer);
            selected = true;
          }
          if (selected === true) {
            this.selectionHandler._generateClickEvent("select", event, pointer);
          }
        }
        /**
         * Remove all node and edge id's from the first set that are present in the second one.
         *
         * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
         * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
         * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
         * @private
         */
      }, {
        key: "_determineDifference",
        value: function _determineDifference(firstSet, secondSet) {
          var arrayDiff = function arrayDiff2(firstArr, secondArr) {
            var result = [];
            for (var i = 0; i < firstArr.length; i++) {
              var value = firstArr[i];
              if (indexOf$3(secondArr).call(secondArr, value) === -1) {
                result.push(value);
              }
            }
            return result;
          };
          return {
            nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
            edges: arrayDiff(firstSet.edges, secondSet.edges)
          };
        }
        /**
         * This function is called by onDragStart.
         * It is separated out because we can then overload it for the datamanipulation system.
         *
         * @param {Event} event
         * @private
         */
      }, {
        key: "onDragStart",
        value: function onDragStart(event) {
          if (this.drag.dragging) {
            return;
          }
          if (this.drag.pointer === void 0) {
            this.onTouch(event);
          }
          var node = this.selectionHandler.getNodeAt(this.drag.pointer);
          this.drag.dragging = true;
          this.drag.selection = [];
          this.drag.translation = assign$2({}, this.body.view.translation);
          this.drag.nodeId = void 0;
          if (event.srcEvent.shiftKey) {
            this.body.selectionBox.show = true;
            var pointer = this.getPointer(event.center);
            this.body.selectionBox.position.start = {
              x: this.canvas._XconvertDOMtoCanvas(pointer.x),
              y: this.canvas._YconvertDOMtoCanvas(pointer.y)
            };
            this.body.selectionBox.position.end = {
              x: this.canvas._XconvertDOMtoCanvas(pointer.x),
              y: this.canvas._YconvertDOMtoCanvas(pointer.y)
            };
          }
          if (node !== void 0 && this.options.dragNodes === true) {
            this.drag.nodeId = node.id;
            if (node.isSelected() === false) {
              this.selectionHandler.unselectAll();
              this.selectionHandler.selectObject(node);
            }
            this.selectionHandler._generateClickEvent("dragStart", event, this.drag.pointer);
            var selection = this.selectionHandler.selectionObj.nodes;
            for (var nodeId in selection) {
              if (Object.prototype.hasOwnProperty.call(selection, nodeId)) {
                var object2 = selection[nodeId];
                var s = {
                  id: object2.id,
                  node: object2,
                  // store original x, y, xFixed and yFixed, make the node temporarily Fixed
                  x: object2.x,
                  y: object2.y,
                  xFixed: object2.options.fixed.x,
                  yFixed: object2.options.fixed.y
                };
                object2.options.fixed.x = true;
                object2.options.fixed.y = true;
                this.drag.selection.push(s);
              }
            }
          } else {
            this.selectionHandler._generateClickEvent("dragStart", event, this.drag.pointer, void 0, true);
          }
        }
        /**
         * handle drag event
         * @param {Event} event
         * @private
         */
      }, {
        key: "onDrag",
        value: function onDrag(event) {
          var _this2 = this;
          if (this.drag.pinched === true) {
            return;
          }
          this.body.emitter.emit("unlockNode");
          var pointer = this.getPointer(event.center);
          var selection = this.drag.selection;
          if (selection && selection.length && this.options.dragNodes === true) {
            this.selectionHandler._generateClickEvent("dragging", event, pointer);
            var deltaX = pointer.x - this.drag.pointer.x;
            var deltaY = pointer.y - this.drag.pointer.y;
            forEach$2(selection).call(selection, function(selection2) {
              var node = selection2.node;
              if (selection2.xFixed === false) {
                node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection2.x) + deltaX);
              }
              if (selection2.yFixed === false) {
                node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection2.y) + deltaY);
              }
            });
            this.body.emitter.emit("startSimulation");
          } else {
            if (event.srcEvent.shiftKey) {
              this.selectionHandler._generateClickEvent("dragging", event, pointer, void 0, true);
              if (this.drag.pointer === void 0) {
                this.onDragStart(event);
                return;
              }
              this.body.selectionBox.position.end = {
                x: this.canvas._XconvertDOMtoCanvas(pointer.x),
                y: this.canvas._YconvertDOMtoCanvas(pointer.y)
              };
              this.body.emitter.emit("_requestRedraw");
            }
            if (this.options.dragView === true && !event.srcEvent.shiftKey) {
              this.selectionHandler._generateClickEvent("dragging", event, pointer, void 0, true);
              if (this.drag.pointer === void 0) {
                this.onDragStart(event);
                return;
              }
              var diffX = pointer.x - this.drag.pointer.x;
              var diffY = pointer.y - this.drag.pointer.y;
              this.body.view.translation = {
                x: this.drag.translation.x + diffX,
                y: this.drag.translation.y + diffY
              };
              this.body.emitter.emit("_requestRedraw");
            }
          }
        }
        /**
         * handle drag start event
         * @param {Event} event
         * @private
         */
      }, {
        key: "onDragEnd",
        value: function onDragEnd(event) {
          var _this3 = this;
          this.drag.dragging = false;
          if (this.body.selectionBox.show) {
            var _context14;
            this.body.selectionBox.show = false;
            var selectionBoxPosition = this.body.selectionBox.position;
            var selectionBoxPositionMinMax = {
              minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
              minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),
              maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
              maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)
            };
            var toBeSelectedNodes = filter$2(_context14 = this.body.nodeIndices).call(_context14, function(nodeId) {
              var node = _this3.body.nodes[nodeId];
              return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;
            });
            forEach$2(toBeSelectedNodes).call(toBeSelectedNodes, function(nodeId) {
              return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);
            });
            this.selectionHandler._generateClickEvent("dragEnd", event, this.getPointer(event.center), void 0, true);
            this.body.emitter.emit("_requestRedraw");
          } else {
            var selection = this.drag.selection;
            if (selection && selection.length) {
              forEach$2(selection).call(selection, function(s) {
                s.node.options.fixed.x = s.xFixed;
                s.node.options.fixed.y = s.yFixed;
              });
              this.selectionHandler._generateClickEvent("dragEnd", event, this.getPointer(event.center));
              this.body.emitter.emit("startSimulation");
            } else {
              this.selectionHandler._generateClickEvent("dragEnd", event, this.getPointer(event.center), void 0, true);
              this.body.emitter.emit("_requestRedraw");
            }
          }
        }
        /**
         * Handle pinch event
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "onPinch",
        value: function onPinch(event) {
          var pointer = this.getPointer(event.center);
          this.drag.pinched = true;
          if (this.pinch["scale"] === void 0) {
            this.pinch.scale = 1;
          }
          var scale = this.pinch.scale * event.scale;
          this.zoom(scale, pointer);
        }
        /**
         * Zoom the network in or out
         * @param {number} scale a number around 1, and between 0.01 and 10
         * @param {{x: number, y: number}} pointer    Position on screen
         * @private
         */
      }, {
        key: "zoom",
        value: function zoom(scale, pointer) {
          if (this.options.zoomView === true) {
            var scaleOld = this.body.view.scale;
            if (scale < 1e-5) {
              scale = 1e-5;
            }
            if (scale > 10) {
              scale = 10;
            }
            var preScaleDragPointer = void 0;
            if (this.drag !== void 0) {
              if (this.drag.dragging === true) {
                preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
              }
            }
            var translation = this.body.view.translation;
            var scaleFrac = scale / scaleOld;
            var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
            var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;
            this.body.view.scale = scale;
            this.body.view.translation = {
              x: tx,
              y: ty
            };
            if (preScaleDragPointer != void 0) {
              var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
              this.drag.pointer.x = postScaleDragPointer.x;
              this.drag.pointer.y = postScaleDragPointer.y;
            }
            this.body.emitter.emit("_requestRedraw");
            if (scaleOld < scale) {
              this.body.emitter.emit("zoom", {
                direction: "+",
                scale: this.body.view.scale,
                pointer
              });
            } else {
              this.body.emitter.emit("zoom", {
                direction: "-",
                scale: this.body.view.scale,
                pointer
              });
            }
          }
        }
        /**
         * Event handler for mouse wheel event, used to zoom the timeline
         * See http://adomas.org/javascript-mouse-wheel/
         *     https://github.com/EightMedia/hammer.js/issues/256
         * @param {MouseEvent}  event
         * @private
         */
      }, {
        key: "onMouseWheel",
        value: function onMouseWheel(event) {
          if (this.options.zoomView === true) {
            if (event.deltaY !== 0) {
              var scale = this.body.view.scale;
              scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1);
              var pointer = this.getPointer({
                x: event.clientX,
                y: event.clientY
              });
              this.zoom(scale, pointer);
            }
            event.preventDefault();
          }
        }
        /**
         * Mouse move handler for checking whether the title moves over a node with a title.
         * @param  {Event} event
         * @private
         */
      }, {
        key: "onMouseMove",
        value: function onMouseMove(event) {
          var _this4 = this;
          var pointer = this.getPointer({
            x: event.clientX,
            y: event.clientY
          });
          var popupVisible = false;
          if (this.popup !== void 0) {
            if (this.popup.hidden === false) {
              this._checkHidePopup(pointer);
            }
            if (this.popup.hidden === false) {
              popupVisible = true;
              this.popup.setPosition(pointer.x + 3, pointer.y - 5);
              this.popup.show();
            }
          }
          if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
            this.canvas.frame.focus();
          }
          if (popupVisible === false) {
            if (this.popupTimer !== void 0) {
              clearInterval(this.popupTimer);
              this.popupTimer = void 0;
            }
            if (!this.drag.dragging) {
              this.popupTimer = setTimeout$2(function() {
                return _this4._checkShowPopup(pointer);
              }, this.options.tooltipDelay);
            }
          }
          if (this.options.hover === true) {
            this.selectionHandler.hoverObject(event, pointer);
          }
        }
        /**
         * Check if there is an element on the given position in the network
         * (a node or edge). If so, and if this element has a title,
         * show a popup window with its title.
         *
         * @param {{x:number, y:number}} pointer
         * @private
         */
      }, {
        key: "_checkShowPopup",
        value: function _checkShowPopup(pointer) {
          var x = this.canvas._XconvertDOMtoCanvas(pointer.x);
          var y = this.canvas._YconvertDOMtoCanvas(pointer.y);
          var pointerObj = {
            left: x,
            top: y,
            right: x,
            bottom: y
          };
          var previousPopupObjId = this.popupObj === void 0 ? void 0 : this.popupObj.id;
          var nodeUnderCursor = false;
          var popupType = "node";
          if (this.popupObj === void 0) {
            var nodeIndices = this.body.nodeIndices;
            var nodes = this.body.nodes;
            var node;
            var overlappingNodes = [];
            for (var i = 0; i < nodeIndices.length; i++) {
              node = nodes[nodeIndices[i]];
              if (node.isOverlappingWith(pointerObj) === true) {
                nodeUnderCursor = true;
                if (node.getTitle() !== void 0) {
                  overlappingNodes.push(nodeIndices[i]);
                }
              }
            }
            if (overlappingNodes.length > 0) {
              this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];
              nodeUnderCursor = true;
            }
          }
          if (this.popupObj === void 0 && nodeUnderCursor === false) {
            var edgeIndices = this.body.edgeIndices;
            var edges = this.body.edges;
            var edge;
            var overlappingEdges = [];
            for (var _i = 0; _i < edgeIndices.length; _i++) {
              edge = edges[edgeIndices[_i]];
              if (edge.isOverlappingWith(pointerObj) === true) {
                if (edge.connected === true && edge.getTitle() !== void 0) {
                  overlappingEdges.push(edgeIndices[_i]);
                }
              }
            }
            if (overlappingEdges.length > 0) {
              this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
              popupType = "edge";
            }
          }
          if (this.popupObj !== void 0) {
            if (this.popupObj.id !== previousPopupObjId) {
              if (this.popup === void 0) {
                this.popup = new Popup(this.canvas.frame);
              }
              this.popup.popupTargetType = popupType;
              this.popup.popupTargetId = this.popupObj.id;
              this.popup.setPosition(pointer.x + 3, pointer.y - 5);
              this.popup.setText(this.popupObj.getTitle());
              this.popup.show();
              this.body.emitter.emit("showPopup", this.popupObj.id);
            }
          } else {
            if (this.popup !== void 0) {
              this.popup.hide();
              this.body.emitter.emit("hidePopup");
            }
          }
        }
        /**
         * Check if the popup must be hidden, which is the case when the mouse is no
         * longer hovering on the object
         * @param {{x:number, y:number}} pointer
         * @private
         */
      }, {
        key: "_checkHidePopup",
        value: function _checkHidePopup(pointer) {
          var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
          var stillOnObj = false;
          if (this.popup.popupTargetType === "node") {
            if (this.body.nodes[this.popup.popupTargetId] !== void 0) {
              stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);
              if (stillOnObj === true) {
                var overNode = this.selectionHandler.getNodeAt(pointer);
                stillOnObj = overNode === void 0 ? false : overNode.id === this.popup.popupTargetId;
              }
            }
          } else {
            if (this.selectionHandler.getNodeAt(pointer) === void 0) {
              if (this.body.edges[this.popup.popupTargetId] !== void 0) {
                stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
              }
            }
          }
          if (stillOnObj === false) {
            this.popupObj = void 0;
            this.popup.hide();
            this.body.emitter.emit("hidePopup");
          }
        }
      }]);
      return InteractionHandler2;
    }();
    SelectionHandler = function() {
      function SelectionHandler2(body, canvas) {
        var _this = this;
        classCallCheck(this, SelectionHandler2);
        this.body = body;
        this.canvas = canvas;
        this.selectionObj = {
          nodes: [],
          edges: []
        };
        this.hoverObj = {
          nodes: {},
          edges: {}
        };
        this.options = {};
        this.defaultOptions = {
          multiselect: false,
          selectable: true,
          selectConnectedEdges: true,
          hoverConnectedEdges: true
        };
        assign$2(this.options, this.defaultOptions);
        this.body.emitter.on("_dataChanged", function() {
          _this.updateSelection();
        });
      }
      createClass(SelectionHandler2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            var fields = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
            selectiveDeepExtend(fields, this.options, options2);
          }
        }
        /**
         * handles the selection part of the tap;
         *
         * @param {{x: number, y: number}} pointer
         * @returns {boolean}
         */
      }, {
        key: "selectOnPoint",
        value: function selectOnPoint(pointer) {
          var selected = false;
          if (this.options.selectable === true) {
            var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);
            this.unselectAll();
            if (obj !== void 0) {
              selected = this.selectObject(obj);
            }
            this.body.emitter.emit("_requestRedraw");
          }
          return selected;
        }
        /**
         *
         * @param {{x: number, y: number}} pointer
         * @returns {boolean}
         */
      }, {
        key: "selectAdditionalOnPoint",
        value: function selectAdditionalOnPoint(pointer) {
          var selectionChanged = false;
          if (this.options.selectable === true) {
            var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);
            if (obj !== void 0) {
              selectionChanged = true;
              if (obj.isSelected() === true) {
                this.deselectObject(obj);
              } else {
                this.selectObject(obj);
              }
              this.body.emitter.emit("_requestRedraw");
            }
          }
          return selectionChanged;
        }
        /**
         * Create an object containing the standard fields for an event.
         *
         * @param {Event} event
         * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
         * @returns {{}}
         * @private
         */
      }, {
        key: "_initBaseEvent",
        value: function _initBaseEvent(event, pointer) {
          var properties = {};
          properties["pointer"] = {
            DOM: {
              x: pointer.x,
              y: pointer.y
            },
            canvas: this.canvas.DOMtoCanvas(pointer)
          };
          properties["event"] = event;
          return properties;
        }
        /**
         * Generate an event which the user can catch.
         *
         * This adds some extra data to the event with respect to cursor position and
         * selected nodes and edges.
         *
         * @param {string} eventType                          Name of event to send
         * @param {Event}  event
         * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
         * @param {Object|undefined} oldSelection             If present, selection state before event occured
         * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
         */
      }, {
        key: "_generateClickEvent",
        value: function _generateClickEvent(eventType, event, pointer, oldSelection) {
          var emptySelection = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
          var properties = this._initBaseEvent(event, pointer);
          if (emptySelection === true) {
            properties.nodes = [];
            properties.edges = [];
          } else {
            var tmp = this.getSelection();
            properties.nodes = tmp.nodes;
            properties.edges = tmp.edges;
          }
          if (oldSelection !== void 0) {
            properties["previousSelection"] = oldSelection;
          }
          if (eventType == "click") {
            properties.items = this.getClickedItems(pointer);
          }
          if (event.controlEdge !== void 0) {
            properties.controlEdge = event.controlEdge;
          }
          this.body.emitter.emit(eventType, properties);
        }
        /**
         *
         * @param {Object} obj
         * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
         * @returns {boolean}
         */
      }, {
        key: "selectObject",
        value: function selectObject(obj) {
          var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.selectConnectedEdges;
          if (obj !== void 0) {
            if (obj instanceof Node) {
              if (highlightEdges === true) {
                this._selectConnectedEdges(obj);
              }
            }
            obj.select();
            this._addToSelection(obj);
            return true;
          }
          return false;
        }
        /**
         *
         * @param {Object} obj
         */
      }, {
        key: "deselectObject",
        value: function deselectObject(obj) {
          if (obj.isSelected() === true) {
            obj.selected = false;
            this._removeFromSelection(obj);
          }
        }
        /**
         * retrieve all nodes overlapping with given object
         * @param {Object} object  An object with parameters left, top, right, bottom
         * @return {number[]}   An array with id's of the overlapping nodes
         * @private
         */
      }, {
        key: "_getAllNodesOverlappingWith",
        value: function _getAllNodesOverlappingWith(object2) {
          var overlappingNodes = [];
          var nodes = this.body.nodes;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var nodeId = this.body.nodeIndices[i];
            if (nodes[nodeId].isOverlappingWith(object2)) {
              overlappingNodes.push(nodeId);
            }
          }
          return overlappingNodes;
        }
        /**
         * Return a position object in canvasspace from a single point in screenspace
         *
         * @param {{x: number, y: number}} pointer
         * @returns {{left: number, top: number, right: number, bottom: number}}
         * @private
         */
      }, {
        key: "_pointerToPositionObject",
        value: function _pointerToPositionObject(pointer) {
          var canvasPos = this.canvas.DOMtoCanvas(pointer);
          return {
            left: canvasPos.x - 1,
            top: canvasPos.y + 1,
            right: canvasPos.x + 1,
            bottom: canvasPos.y - 1
          };
        }
        /**
         * Get the top node at the passed point (like a click)
         *
         * @param {{x: number, y: number}} pointer
         * @param {boolean} [returnNode=true]
         * @return {Node | undefined} node
         */
      }, {
        key: "getNodeAt",
        value: function getNodeAt(pointer) {
          var returnNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var positionObject = this._pointerToPositionObject(pointer);
          var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
          if (overlappingNodes.length > 0) {
            if (returnNode === true) {
              return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
            } else {
              return overlappingNodes[overlappingNodes.length - 1];
            }
          } else {
            return void 0;
          }
        }
        /**
         * retrieve all edges overlapping with given object, selector is around center
         * @param {Object} object  An object with parameters left, top, right, bottom
         * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
         * @private
         */
      }, {
        key: "_getEdgesOverlappingWith",
        value: function _getEdgesOverlappingWith(object2, overlappingEdges) {
          var edges = this.body.edges;
          for (var i = 0; i < this.body.edgeIndices.length; i++) {
            var edgeId = this.body.edgeIndices[i];
            if (edges[edgeId].isOverlappingWith(object2)) {
              overlappingEdges.push(edgeId);
            }
          }
        }
        /**
         * retrieve all nodes overlapping with given object
         * @param {Object} object  An object with parameters left, top, right, bottom
         * @return {number[]}   An array with id's of the overlapping nodes
         * @private
         */
      }, {
        key: "_getAllEdgesOverlappingWith",
        value: function _getAllEdgesOverlappingWith(object2) {
          var overlappingEdges = [];
          this._getEdgesOverlappingWith(object2, overlappingEdges);
          return overlappingEdges;
        }
        /**
         * Get the edges nearest to the passed point (like a click)
         *
         * @param {{x: number, y: number}} pointer
         * @param {boolean} [returnEdge=true]
         * @return {Edge | undefined} node
         */
      }, {
        key: "getEdgeAt",
        value: function getEdgeAt(pointer) {
          var returnEdge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var canvasPos = this.canvas.DOMtoCanvas(pointer);
          var mindist = 10;
          var overlappingEdge = null;
          var edges = this.body.edges;
          for (var i = 0; i < this.body.edgeIndices.length; i++) {
            var edgeId = this.body.edgeIndices[i];
            var edge = edges[edgeId];
            if (edge.connected) {
              var xFrom = edge.from.x;
              var yFrom = edge.from.y;
              var xTo = edge.to.x;
              var yTo = edge.to.y;
              var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);
              if (dist < mindist) {
                overlappingEdge = edgeId;
                mindist = dist;
              }
            }
          }
          if (overlappingEdge !== null) {
            if (returnEdge === true) {
              return this.body.edges[overlappingEdge];
            } else {
              return overlappingEdge;
            }
          } else {
            return void 0;
          }
        }
        /**
         * Add object to the selection array.
         *
         * @param {Object} obj
         * @private
         */
      }, {
        key: "_addToSelection",
        value: function _addToSelection(obj) {
          if (obj instanceof Node) {
            this.selectionObj.nodes[obj.id] = obj;
          } else {
            this.selectionObj.edges[obj.id] = obj;
          }
        }
        /**
         * Add object to the selection array.
         *
         * @param {Object} obj
         * @private
         */
      }, {
        key: "_addToHover",
        value: function _addToHover(obj) {
          if (obj instanceof Node) {
            this.hoverObj.nodes[obj.id] = obj;
          } else {
            this.hoverObj.edges[obj.id] = obj;
          }
        }
        /**
         * Remove a single option from selection.
         *
         * @param {Object} obj
         * @private
         */
      }, {
        key: "_removeFromSelection",
        value: function _removeFromSelection(obj) {
          if (obj instanceof Node) {
            delete this.selectionObj.nodes[obj.id];
            this._unselectConnectedEdges(obj);
          } else {
            delete this.selectionObj.edges[obj.id];
          }
        }
        /**
         * Unselect all. The selectionObj is useful for this.
         */
      }, {
        key: "unselectAll",
        value: function unselectAll() {
          for (var nodeId in this.selectionObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
              this.selectionObj.nodes[nodeId].unselect();
            }
          }
          for (var edgeId in this.selectionObj.edges) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.edges, edgeId)) {
              this.selectionObj.edges[edgeId].unselect();
            }
          }
          this.selectionObj = {
            nodes: {},
            edges: {}
          };
        }
        /**
         * return the number of selected nodes
         *
         * @returns {number}
         * @private
         */
      }, {
        key: "_getSelectedNodeCount",
        value: function _getSelectedNodeCount() {
          var count = 0;
          for (var nodeId in this.selectionObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
              count += 1;
            }
          }
          return count;
        }
        /**
         * return the selected node
         *
         * @returns {number}
         * @private
         */
      }, {
        key: "_getSelectedNode",
        value: function _getSelectedNode() {
          for (var nodeId in this.selectionObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
              return this.selectionObj.nodes[nodeId];
            }
          }
          return void 0;
        }
        /**
         * return the selected edge
         *
         * @returns {number}
         * @private
         */
      }, {
        key: "_getSelectedEdge",
        value: function _getSelectedEdge() {
          for (var edgeId in this.selectionObj.edges) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.edges, edgeId)) {
              return this.selectionObj.edges[edgeId];
            }
          }
          return void 0;
        }
        /**
         * return the number of selected edges
         *
         * @returns {number}
         * @private
         */
      }, {
        key: "_getSelectedEdgeCount",
        value: function _getSelectedEdgeCount() {
          var count = 0;
          for (var edgeId in this.selectionObj.edges) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.edges, edgeId)) {
              count += 1;
            }
          }
          return count;
        }
        /**
         * return the number of selected objects.
         *
         * @returns {number}
         * @private
         */
      }, {
        key: "_getSelectedObjectCount",
        value: function _getSelectedObjectCount() {
          var count = 0;
          for (var nodeId in this.selectionObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
              count += 1;
            }
          }
          for (var edgeId in this.selectionObj.edges) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.edges, edgeId)) {
              count += 1;
            }
          }
          return count;
        }
        /**
         * Check if anything is selected
         *
         * @returns {boolean}
         * @private
         */
      }, {
        key: "_selectionIsEmpty",
        value: function _selectionIsEmpty() {
          for (var nodeId in this.selectionObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
              return false;
            }
          }
          for (var edgeId in this.selectionObj.edges) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.edges, edgeId)) {
              return false;
            }
          }
          return true;
        }
        /**
         * check if one of the selected nodes is a cluster.
         *
         * @returns {boolean}
         * @private
         */
      }, {
        key: "_clusterInSelection",
        value: function _clusterInSelection() {
          for (var nodeId in this.selectionObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
              if (this.selectionObj.nodes[nodeId].clusterSize > 1) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * select the edges connected to the node that is being selected
         *
         * @param {Node} node
         * @private
         */
      }, {
        key: "_selectConnectedEdges",
        value: function _selectConnectedEdges(node) {
          for (var i = 0; i < node.edges.length; i++) {
            var edge = node.edges[i];
            edge.select();
            this._addToSelection(edge);
          }
        }
        /**
         * select the edges connected to the node that is being selected
         *
         * @param {Node} node
         * @private
         */
      }, {
        key: "_hoverConnectedEdges",
        value: function _hoverConnectedEdges(node) {
          for (var i = 0; i < node.edges.length; i++) {
            var edge = node.edges[i];
            edge.hover = true;
            this._addToHover(edge);
          }
        }
        /**
         * unselect the edges connected to the node that is being selected
         *
         * @param {Node} node
         * @private
         */
      }, {
        key: "_unselectConnectedEdges",
        value: function _unselectConnectedEdges(node) {
          for (var i = 0; i < node.edges.length; i++) {
            var edge = node.edges[i];
            edge.unselect();
            this._removeFromSelection(edge);
          }
        }
        /**
         * Remove the highlight from a node or edge, in response to mouse movement
         *
         * @param {Event}  event
         * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
         * @param {Node|vis.Edge} object
         * @private
         */
      }, {
        key: "emitBlurEvent",
        value: function emitBlurEvent(event, pointer, object2) {
          var properties = this._initBaseEvent(event, pointer);
          if (object2.hover === true) {
            object2.hover = false;
            if (object2 instanceof Node) {
              properties.node = object2.id;
              this.body.emitter.emit("blurNode", properties);
            } else {
              properties.edge = object2.id;
              this.body.emitter.emit("blurEdge", properties);
            }
          }
        }
        /**
         * Create the highlight for a node or edge, in response to mouse movement
         *
         * @param {Event}  event
         * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
         * @param {Node|vis.Edge} object
         * @returns {boolean} hoverChanged
         * @private
         */
      }, {
        key: "emitHoverEvent",
        value: function emitHoverEvent(event, pointer, object2) {
          var properties = this._initBaseEvent(event, pointer);
          var hoverChanged = false;
          if (object2.hover === false) {
            object2.hover = true;
            this._addToHover(object2);
            hoverChanged = true;
            if (object2 instanceof Node) {
              properties.node = object2.id;
              this.body.emitter.emit("hoverNode", properties);
            } else {
              properties.edge = object2.id;
              this.body.emitter.emit("hoverEdge", properties);
            }
          }
          return hoverChanged;
        }
        /**
         * Perform actions in response to a mouse movement.
         *
         * @param {Event}  event
         * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
         */
      }, {
        key: "hoverObject",
        value: function hoverObject(event, pointer) {
          var object2 = this.getNodeAt(pointer);
          if (object2 === void 0) {
            object2 = this.getEdgeAt(pointer);
          }
          var hoverChanged = false;
          for (var nodeId in this.hoverObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {
              if (object2 === void 0 || object2 instanceof Node && object2.id != nodeId || object2 instanceof Edge) {
                this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);
                delete this.hoverObj.nodes[nodeId];
                hoverChanged = true;
              }
            }
          }
          for (var edgeId in this.hoverObj.edges) {
            if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {
              if (hoverChanged === true) {
                this.hoverObj.edges[edgeId].hover = false;
                delete this.hoverObj.edges[edgeId];
              } else if (object2 === void 0 || object2 instanceof Edge && object2.id != edgeId || object2 instanceof Node && !object2.hover) {
                this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);
                delete this.hoverObj.edges[edgeId];
                hoverChanged = true;
              }
            }
          }
          if (object2 !== void 0) {
            var hoveredEdgesCount = keys$3(this.hoverObj.edges).length;
            var hoveredNodesCount = keys$3(this.hoverObj.nodes).length;
            var newOnlyHoveredEdge = object2 instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
            var newOnlyHoveredNode = object2 instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
            if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {
              hoverChanged = this.emitHoverEvent(event, pointer, object2);
            }
            if (object2 instanceof Node && this.options.hoverConnectedEdges === true) {
              this._hoverConnectedEdges(object2);
            }
          }
          if (hoverChanged === true) {
            this.body.emitter.emit("_requestRedraw");
          }
        }
        /**
         *
         * retrieve the currently selected objects
         * @return {{nodes: Array.<string>, edges: Array.<string>}} selection
         */
      }, {
        key: "getSelection",
        value: function getSelection() {
          var nodeIds = this.getSelectedNodes();
          var edgeIds = this.getSelectedEdges();
          return {
            nodes: nodeIds,
            edges: edgeIds
          };
        }
        /**
         *
         * retrieve the currently selected nodes
         * @return {string[]} selection    An array with the ids of the
         *                                            selected nodes.
         */
      }, {
        key: "getSelectedNodes",
        value: function getSelectedNodes() {
          var idArray = [];
          if (this.options.selectable === true) {
            for (var nodeId in this.selectionObj.nodes) {
              if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
                idArray.push(this.selectionObj.nodes[nodeId].id);
              }
            }
          }
          return idArray;
        }
        /**
         *
         * retrieve the currently selected edges
         * @return {Array} selection    An array with the ids of the
         *                                            selected nodes.
         */
      }, {
        key: "getSelectedEdges",
        value: function getSelectedEdges() {
          var idArray = [];
          if (this.options.selectable === true) {
            for (var edgeId in this.selectionObj.edges) {
              if (Object.prototype.hasOwnProperty.call(this.selectionObj.edges, edgeId)) {
                idArray.push(this.selectionObj.edges[edgeId].id);
              }
            }
          }
          return idArray;
        }
        /**
         * Updates the current selection
         * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
         * @param {Object} options                                 Options
         */
      }, {
        key: "setSelection",
        value: function setSelection(selection) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var i, id2;
          if (!selection || !selection.nodes && !selection.edges) throw "Selection must be an object with nodes and/or edges properties";
          if (options2.unselectAll || options2.unselectAll === void 0) {
            this.unselectAll();
          }
          if (selection.nodes) {
            for (i = 0; i < selection.nodes.length; i++) {
              id2 = selection.nodes[i];
              var node = this.body.nodes[id2];
              if (!node) {
                throw new RangeError('Node with id "' + id2 + '" not found');
              }
              this.selectObject(node, options2.highlightEdges);
            }
          }
          if (selection.edges) {
            for (i = 0; i < selection.edges.length; i++) {
              id2 = selection.edges[i];
              var edge = this.body.edges[id2];
              if (!edge) {
                throw new RangeError('Edge with id "' + id2 + '" not found');
              }
              this.selectObject(edge);
            }
          }
          this.body.emitter.emit("_requestRedraw");
        }
        /**
         * select zero or more nodes with the option to highlight edges
         * @param {number[] | string[]} selection     An array with the ids of the
         *                                            selected nodes.
         * @param {boolean} [highlightEdges]
         */
      }, {
        key: "selectNodes",
        value: function selectNodes(selection) {
          var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (!selection || selection.length === void 0) throw "Selection must be an array with ids";
          this.setSelection({
            nodes: selection
          }, {
            highlightEdges
          });
        }
        /**
         * select zero or more edges
         * @param {number[] | string[]} selection     An array with the ids of the
         *                                            selected nodes.
         */
      }, {
        key: "selectEdges",
        value: function selectEdges(selection) {
          if (!selection || selection.length === void 0) throw "Selection must be an array with ids";
          this.setSelection({
            edges: selection
          });
        }
        /**
         * Validate the selection: remove ids of nodes which no longer exist
         * @private
         */
      }, {
        key: "updateSelection",
        value: function updateSelection() {
          for (var nodeId in this.selectionObj.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.nodes, nodeId)) {
              if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
                delete this.selectionObj.nodes[nodeId];
              }
            }
          }
          for (var edgeId in this.selectionObj.edges) {
            if (Object.prototype.hasOwnProperty.call(this.selectionObj.edges, edgeId)) {
              if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {
                delete this.selectionObj.edges[edgeId];
              }
            }
          }
        }
        /**
         * Determine all the visual elements clicked which are on the given point.
         *
         * All elements are returned; this includes nodes, edges and their labels.
         * The order returned is from highest to lowest, i.e. element 0 of the return
         * value is the topmost item clicked on.
         *
         * The return value consists of an array of the following possible elements:
         *
         * - `{nodeId:number}`             - node with given id clicked on
         * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
         * - `{edgeId:number}`             - edge with given id clicked on
         * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
         *
         * ## NOTES
         *
         * - Currently, there is only one label associated with a node or an edge,
         *   but this is expected to change somewhere in the future.
         * - Since there is no z-indexing yet, it is not really possible to set the nodes and
         *   edges in the correct order. For the time being, nodes come first.
         *
         * @param {point} pointer  mouse position in screen coordinates
         * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
         * @private
         */
      }, {
        key: "getClickedItems",
        value: function getClickedItems(pointer) {
          var point = this.canvas.DOMtoCanvas(pointer);
          var items = [];
          var nodeIndices = this.body.nodeIndices;
          var nodes = this.body.nodes;
          for (var i = nodeIndices.length - 1; i >= 0; i--) {
            var node = nodes[nodeIndices[i]];
            var ret = node.getItemsOnPoint(point);
            items.push.apply(items, ret);
          }
          var edgeIndices = this.body.edgeIndices;
          var edges = this.body.edges;
          for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
            var edge = edges[edgeIndices[_i]];
            var _ret = edge.getItemsOnPoint(point);
            items.push.apply(items, _ret);
          }
          return items;
        }
      }]);
      return SelectionHandler2;
    }();
    timsort = createCommonjsModule(function(module, exports) {
      (function(global2, factory) {
        {
          factory(exports);
        }
      })(commonjsGlobal, function(exports2) {
        exports2.__esModule = true;
        exports2.sort = sort3;
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var DEFAULT_MIN_MERGE = 32;
        var DEFAULT_MIN_GALLOPING = 7;
        var DEFAULT_TMP_STORAGE_LENGTH = 256;
        var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
        function log10(x) {
          if (x < 1e5) {
            if (x < 100) {
              return x < 10 ? 0 : 1;
            }
            if (x < 1e4) {
              return x < 1e3 ? 2 : 3;
            }
            return 4;
          }
          if (x < 1e7) {
            return x < 1e6 ? 5 : 6;
          }
          if (x < 1e9) {
            return x < 1e8 ? 7 : 8;
          }
          return 9;
        }
        function alphabeticalCompare(a, b) {
          if (a === b) {
            return 0;
          }
          if (~~a === a && ~~b === b) {
            if (a === 0 || b === 0) {
              return a < b ? -1 : 1;
            }
            if (a < 0 || b < 0) {
              if (b >= 0) {
                return -1;
              }
              if (a >= 0) {
                return 1;
              }
              a = -a;
              b = -b;
            }
            var al = log10(a);
            var bl = log10(b);
            var t = 0;
            if (al < bl) {
              a *= POWERS_OF_TEN[bl - al - 1];
              b /= 10;
              t = -1;
            } else if (al > bl) {
              b *= POWERS_OF_TEN[al - bl - 1];
              a /= 10;
              t = 1;
            }
            if (a === b) {
              return t;
            }
            return a < b ? -1 : 1;
          }
          var aStr = String(a);
          var bStr = String(b);
          if (aStr === bStr) {
            return 0;
          }
          return aStr < bStr ? -1 : 1;
        }
        function minRunLength(n) {
          var r = 0;
          while (n >= DEFAULT_MIN_MERGE) {
            r |= n & 1;
            n >>= 1;
          }
          return n + r;
        }
        function makeAscendingRun(array2, lo, hi2, compare) {
          var runHi = lo + 1;
          if (runHi === hi2) {
            return 1;
          }
          if (compare(array2[runHi++], array2[lo]) < 0) {
            while (runHi < hi2 && compare(array2[runHi], array2[runHi - 1]) < 0) {
              runHi++;
            }
            reverseRun(array2, lo, runHi);
          } else {
            while (runHi < hi2 && compare(array2[runHi], array2[runHi - 1]) >= 0) {
              runHi++;
            }
          }
          return runHi - lo;
        }
        function reverseRun(array2, lo, hi2) {
          hi2--;
          while (lo < hi2) {
            var t = array2[lo];
            array2[lo++] = array2[hi2];
            array2[hi2--] = t;
          }
        }
        function binaryInsertionSort(array2, lo, hi2, start, compare) {
          if (start === lo) {
            start++;
          }
          for (; start < hi2; start++) {
            var pivot = array2[start];
            var left = lo;
            var right = start;
            while (left < right) {
              var mid = left + right >>> 1;
              if (compare(pivot, array2[mid]) < 0) {
                right = mid;
              } else {
                left = mid + 1;
              }
            }
            var n = start - left;
            switch (n) {
              case 3:
                array2[left + 3] = array2[left + 2];
              case 2:
                array2[left + 2] = array2[left + 1];
              case 1:
                array2[left + 1] = array2[left];
                break;
              default:
                while (n > 0) {
                  array2[left + n] = array2[left + n - 1];
                  n--;
                }
            }
            array2[left] = pivot;
          }
        }
        function gallopLeft(value, array2, start, length2, hint, compare) {
          var lastOffset = 0;
          var maxOffset = 0;
          var offset = 1;
          if (compare(value, array2[start + hint]) > 0) {
            maxOffset = length2 - hint;
            while (offset < maxOffset && compare(value, array2[start + hint + offset]) > 0) {
              lastOffset = offset;
              offset = (offset << 1) + 1;
              if (offset <= 0) {
                offset = maxOffset;
              }
            }
            if (offset > maxOffset) {
              offset = maxOffset;
            }
            lastOffset += hint;
            offset += hint;
          } else {
            maxOffset = hint + 1;
            while (offset < maxOffset && compare(value, array2[start + hint - offset]) <= 0) {
              lastOffset = offset;
              offset = (offset << 1) + 1;
              if (offset <= 0) {
                offset = maxOffset;
              }
            }
            if (offset > maxOffset) {
              offset = maxOffset;
            }
            var tmp = lastOffset;
            lastOffset = hint - offset;
            offset = hint - tmp;
          }
          lastOffset++;
          while (lastOffset < offset) {
            var m = lastOffset + (offset - lastOffset >>> 1);
            if (compare(value, array2[start + m]) > 0) {
              lastOffset = m + 1;
            } else {
              offset = m;
            }
          }
          return offset;
        }
        function gallopRight(value, array2, start, length2, hint, compare) {
          var lastOffset = 0;
          var maxOffset = 0;
          var offset = 1;
          if (compare(value, array2[start + hint]) < 0) {
            maxOffset = hint + 1;
            while (offset < maxOffset && compare(value, array2[start + hint - offset]) < 0) {
              lastOffset = offset;
              offset = (offset << 1) + 1;
              if (offset <= 0) {
                offset = maxOffset;
              }
            }
            if (offset > maxOffset) {
              offset = maxOffset;
            }
            var tmp = lastOffset;
            lastOffset = hint - offset;
            offset = hint - tmp;
          } else {
            maxOffset = length2 - hint;
            while (offset < maxOffset && compare(value, array2[start + hint + offset]) >= 0) {
              lastOffset = offset;
              offset = (offset << 1) + 1;
              if (offset <= 0) {
                offset = maxOffset;
              }
            }
            if (offset > maxOffset) {
              offset = maxOffset;
            }
            lastOffset += hint;
            offset += hint;
          }
          lastOffset++;
          while (lastOffset < offset) {
            var m = lastOffset + (offset - lastOffset >>> 1);
            if (compare(value, array2[start + m]) < 0) {
              offset = m;
            } else {
              lastOffset = m + 1;
            }
          }
          return offset;
        }
        var TimSort = function() {
          function TimSort2(array2, compare) {
            _classCallCheck2(this, TimSort2);
            this.array = null;
            this.compare = null;
            this.minGallop = DEFAULT_MIN_GALLOPING;
            this.length = 0;
            this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
            this.stackLength = 0;
            this.runStart = null;
            this.runLength = null;
            this.stackSize = 0;
            this.array = array2;
            this.compare = compare;
            this.length = array2.length;
            if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
              this.tmpStorageLength = this.length >>> 1;
            }
            this.tmp = new Array(this.tmpStorageLength);
            this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
            this.runStart = new Array(this.stackLength);
            this.runLength = new Array(this.stackLength);
          }
          TimSort2.prototype.pushRun = function pushRun(runStart, runLength) {
            this.runStart[this.stackSize] = runStart;
            this.runLength[this.stackSize] = runLength;
            this.stackSize += 1;
          };
          TimSort2.prototype.mergeRuns = function mergeRuns() {
            while (this.stackSize > 1) {
              var n = this.stackSize - 2;
              if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
                if (this.runLength[n - 1] < this.runLength[n + 1]) {
                  n--;
                }
              } else if (this.runLength[n] > this.runLength[n + 1]) {
                break;
              }
              this.mergeAt(n);
            }
          };
          TimSort2.prototype.forceMergeRuns = function forceMergeRuns() {
            while (this.stackSize > 1) {
              var n = this.stackSize - 2;
              if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
                n--;
              }
              this.mergeAt(n);
            }
          };
          TimSort2.prototype.mergeAt = function mergeAt(i) {
            var compare = this.compare;
            var array2 = this.array;
            var start1 = this.runStart[i];
            var length1 = this.runLength[i];
            var start2 = this.runStart[i + 1];
            var length2 = this.runLength[i + 1];
            this.runLength[i] = length1 + length2;
            if (i === this.stackSize - 3) {
              this.runStart[i + 1] = this.runStart[i + 2];
              this.runLength[i + 1] = this.runLength[i + 2];
            }
            this.stackSize--;
            var k = gallopRight(array2[start2], array2, start1, length1, 0, compare);
            start1 += k;
            length1 -= k;
            if (length1 === 0) {
              return;
            }
            length2 = gallopLeft(array2[start1 + length1 - 1], array2, start2, length2, length2 - 1, compare);
            if (length2 === 0) {
              return;
            }
            if (length1 <= length2) {
              this.mergeLow(start1, length1, start2, length2);
            } else {
              this.mergeHigh(start1, length1, start2, length2);
            }
          };
          TimSort2.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {
            var compare = this.compare;
            var array2 = this.array;
            var tmp = this.tmp;
            var i = 0;
            for (i = 0; i < length1; i++) {
              tmp[i] = array2[start1 + i];
            }
            var cursor1 = 0;
            var cursor2 = start2;
            var dest = start1;
            array2[dest++] = array2[cursor2++];
            if (--length2 === 0) {
              for (i = 0; i < length1; i++) {
                array2[dest + i] = tmp[cursor1 + i];
              }
              return;
            }
            if (length1 === 1) {
              for (i = 0; i < length2; i++) {
                array2[dest + i] = array2[cursor2 + i];
              }
              array2[dest + length2] = tmp[cursor1];
              return;
            }
            var minGallop = this.minGallop;
            while (true) {
              var count1 = 0;
              var count2 = 0;
              var exit = false;
              do {
                if (compare(array2[cursor2], tmp[cursor1]) < 0) {
                  array2[dest++] = array2[cursor2++];
                  count2++;
                  count1 = 0;
                  if (--length2 === 0) {
                    exit = true;
                    break;
                  }
                } else {
                  array2[dest++] = tmp[cursor1++];
                  count1++;
                  count2 = 0;
                  if (--length1 === 1) {
                    exit = true;
                    break;
                  }
                }
              } while ((count1 | count2) < minGallop);
              if (exit) {
                break;
              }
              do {
                count1 = gallopRight(array2[cursor2], tmp, cursor1, length1, 0, compare);
                if (count1 !== 0) {
                  for (i = 0; i < count1; i++) {
                    array2[dest + i] = tmp[cursor1 + i];
                  }
                  dest += count1;
                  cursor1 += count1;
                  length1 -= count1;
                  if (length1 <= 1) {
                    exit = true;
                    break;
                  }
                }
                array2[dest++] = array2[cursor2++];
                if (--length2 === 0) {
                  exit = true;
                  break;
                }
                count2 = gallopLeft(tmp[cursor1], array2, cursor2, length2, 0, compare);
                if (count2 !== 0) {
                  for (i = 0; i < count2; i++) {
                    array2[dest + i] = array2[cursor2 + i];
                  }
                  dest += count2;
                  cursor2 += count2;
                  length2 -= count2;
                  if (length2 === 0) {
                    exit = true;
                    break;
                  }
                }
                array2[dest++] = tmp[cursor1++];
                if (--length1 === 1) {
                  exit = true;
                  break;
                }
                minGallop--;
              } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
              if (exit) {
                break;
              }
              if (minGallop < 0) {
                minGallop = 0;
              }
              minGallop += 2;
            }
            this.minGallop = minGallop;
            if (minGallop < 1) {
              this.minGallop = 1;
            }
            if (length1 === 1) {
              for (i = 0; i < length2; i++) {
                array2[dest + i] = array2[cursor2 + i];
              }
              array2[dest + length2] = tmp[cursor1];
            } else if (length1 === 0) {
              throw new Error("mergeLow preconditions were not respected");
            } else {
              for (i = 0; i < length1; i++) {
                array2[dest + i] = tmp[cursor1 + i];
              }
            }
          };
          TimSort2.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
            var compare = this.compare;
            var array2 = this.array;
            var tmp = this.tmp;
            var i = 0;
            for (i = 0; i < length2; i++) {
              tmp[i] = array2[start2 + i];
            }
            var cursor1 = start1 + length1 - 1;
            var cursor2 = length2 - 1;
            var dest = start2 + length2 - 1;
            var customCursor = 0;
            var customDest = 0;
            array2[dest--] = array2[cursor1--];
            if (--length1 === 0) {
              customCursor = dest - (length2 - 1);
              for (i = 0; i < length2; i++) {
                array2[customCursor + i] = tmp[i];
              }
              return;
            }
            if (length2 === 1) {
              dest -= length1;
              cursor1 -= length1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = length1 - 1; i >= 0; i--) {
                array2[customDest + i] = array2[customCursor + i];
              }
              array2[dest] = tmp[cursor2];
              return;
            }
            var minGallop = this.minGallop;
            while (true) {
              var count1 = 0;
              var count2 = 0;
              var exit = false;
              do {
                if (compare(tmp[cursor2], array2[cursor1]) < 0) {
                  array2[dest--] = array2[cursor1--];
                  count1++;
                  count2 = 0;
                  if (--length1 === 0) {
                    exit = true;
                    break;
                  }
                } else {
                  array2[dest--] = tmp[cursor2--];
                  count2++;
                  count1 = 0;
                  if (--length2 === 1) {
                    exit = true;
                    break;
                  }
                }
              } while ((count1 | count2) < minGallop);
              if (exit) {
                break;
              }
              do {
                count1 = length1 - gallopRight(tmp[cursor2], array2, start1, length1, length1 - 1, compare);
                if (count1 !== 0) {
                  dest -= count1;
                  cursor1 -= count1;
                  length1 -= count1;
                  customDest = dest + 1;
                  customCursor = cursor1 + 1;
                  for (i = count1 - 1; i >= 0; i--) {
                    array2[customDest + i] = array2[customCursor + i];
                  }
                  if (length1 === 0) {
                    exit = true;
                    break;
                  }
                }
                array2[dest--] = tmp[cursor2--];
                if (--length2 === 1) {
                  exit = true;
                  break;
                }
                count2 = length2 - gallopLeft(array2[cursor1], tmp, 0, length2, length2 - 1, compare);
                if (count2 !== 0) {
                  dest -= count2;
                  cursor2 -= count2;
                  length2 -= count2;
                  customDest = dest + 1;
                  customCursor = cursor2 + 1;
                  for (i = 0; i < count2; i++) {
                    array2[customDest + i] = tmp[customCursor + i];
                  }
                  if (length2 <= 1) {
                    exit = true;
                    break;
                  }
                }
                array2[dest--] = array2[cursor1--];
                if (--length1 === 0) {
                  exit = true;
                  break;
                }
                minGallop--;
              } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
              if (exit) {
                break;
              }
              if (minGallop < 0) {
                minGallop = 0;
              }
              minGallop += 2;
            }
            this.minGallop = minGallop;
            if (minGallop < 1) {
              this.minGallop = 1;
            }
            if (length2 === 1) {
              dest -= length1;
              cursor1 -= length1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = length1 - 1; i >= 0; i--) {
                array2[customDest + i] = array2[customCursor + i];
              }
              array2[dest] = tmp[cursor2];
            } else if (length2 === 0) {
              throw new Error("mergeHigh preconditions were not respected");
            } else {
              customCursor = dest - (length2 - 1);
              for (i = 0; i < length2; i++) {
                array2[customCursor + i] = tmp[i];
              }
            }
          };
          return TimSort2;
        }();
        function sort3(array2, compare, lo, hi2) {
          if (!Array.isArray(array2)) {
            throw new TypeError("Can only sort arrays");
          }
          if (!compare) {
            compare = alphabeticalCompare;
          } else if (typeof compare !== "function") {
            hi2 = lo;
            lo = compare;
            compare = alphabeticalCompare;
          }
          if (!lo) {
            lo = 0;
          }
          if (!hi2) {
            hi2 = array2.length;
          }
          var remaining = hi2 - lo;
          if (remaining < 2) {
            return;
          }
          var runLength = 0;
          if (remaining < DEFAULT_MIN_MERGE) {
            runLength = makeAscendingRun(array2, lo, hi2, compare);
            binaryInsertionSort(array2, lo, hi2, lo + runLength, compare);
            return;
          }
          var ts = new TimSort(array2, compare);
          var minRun = minRunLength(remaining);
          do {
            runLength = makeAscendingRun(array2, lo, hi2, compare);
            if (runLength < minRun) {
              var force = remaining;
              if (force > minRun) {
                force = minRun;
              }
              binaryInsertionSort(array2, lo, lo + force, lo + runLength, compare);
              runLength = force;
            }
            ts.pushRun(lo, runLength);
            ts.mergeRuns();
            remaining -= runLength;
            lo += runLength;
          } while (remaining !== 0);
          ts.forceMergeRuns();
        }
      });
    });
    timsort$1 = timsort;
    DirectionInterface = function() {
      function DirectionInterface2() {
        classCallCheck(this, DirectionInterface2);
      }
      createClass(DirectionInterface2, [{
        key: "abstract",
        /** @ignore **/
        value: function abstract() {
          throw new Error("Can't instantiate abstract class!");
        }
        /**
         * This is a dummy call which is used to suppress the jsdoc errors of type:
         *
         *   "'param' is assigned a value but never used"
         *
         * @ignore
         **/
      }, {
        key: "fake_use",
        value: function fake_use() {
        }
        /**
         * Type to use to translate dynamic curves to, in the case of hierarchical layout.
         * Dynamic curves do not work for these.
         *
         * The value should be perpendicular to the actual direction of the layout.
         *
         * @return {string} Direction, either 'vertical' or 'horizontal'
         */
      }, {
        key: "curveType",
        value: function curveType() {
          return this.abstract();
        }
        /**
         * Return the value of the coordinate that is not fixed for this direction.
         *
         * @param {Node} node The node to read
         * @return {number} Value of the unfixed coordinate
         */
      }, {
        key: "getPosition",
        value: function getPosition(node) {
          this.fake_use(node);
          return this.abstract();
        }
        /**
         * Set the value of the coordinate that is not fixed for this direction.
         *
         * @param {Node} node The node to adjust
         * @param {number} position
         * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
         */
      }, {
        key: "setPosition",
        value: function setPosition(node, position) {
          var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
          this.fake_use(node, position, level);
          this.abstract();
        }
        /**
         * Get the width of a tree.
         *
         * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
         * only among themselves. In essence, it is a sub-network.
         *
         * @param {number} index The index number of a tree
         * @return {number} the width of a tree in the view coordinates
         */
      }, {
        key: "getTreeSize",
        value: function getTreeSize(index2) {
          this.fake_use(index2);
          return this.abstract();
        }
        /**
         * Sort array of nodes on the unfixed coordinates.
         *
         * **Note:** chrome has non-stable sorting implementation, which
         * has a tendency to change the order of the array items,
         * even if the custom sort function returns 0.
         *
         * For this reason, an external sort implementation is used,
         * which has the added benefit of being faster than the standard
         * platforms implementation. This has been verified on `node.js`,
         * `firefox` and `chrome` (all linux).
         *
         * @param {Array.<Node>} nodeArray array of nodes to sort
         */
      }, {
        key: "sort",
        value: function sort3(nodeArray) {
          this.fake_use(nodeArray);
          this.abstract();
        }
        /**
         * Assign the fixed coordinate of the node to the given level
         *
         * @param {Node} node The node to adjust
         * @param {number} level The level to fix to
         */
      }, {
        key: "fix",
        value: function fix2(node, level) {
          this.fake_use(node, level);
          this.abstract();
        }
        /**
         * Add an offset to the unfixed coordinate of the given node. 
         *
         * @param {NodeId} nodeId Id of the node to adjust
         * @param {number} diff Offset to add to the unfixed coordinate
         */
      }, {
        key: "shift",
        value: function shift(nodeId, diff) {
          this.fake_use(nodeId, diff);
          this.abstract();
        }
      }]);
      return DirectionInterface2;
    }();
    VerticalStrategy = function(_DirectionInterface) {
      inherits(VerticalStrategy2, _DirectionInterface);
      var _super = _createSuper$t(VerticalStrategy2);
      function VerticalStrategy2(layout) {
        var _this;
        classCallCheck(this, VerticalStrategy2);
        _this = _super.call(this);
        _this.layout = layout;
        return _this;
      }
      createClass(VerticalStrategy2, [{
        key: "curveType",
        value: function curveType() {
          return "horizontal";
        }
        /** @inheritdoc */
      }, {
        key: "getPosition",
        value: function getPosition(node) {
          return node.x;
        }
        /** @inheritdoc */
      }, {
        key: "setPosition",
        value: function setPosition(node, position) {
          var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
          if (level !== void 0) {
            this.layout.hierarchical.addToOrdering(node, level);
          }
          node.x = position;
        }
        /** @inheritdoc */
      }, {
        key: "getTreeSize",
        value: function getTreeSize(index2) {
          var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index2);
          return {
            min: res.min_x,
            max: res.max_x
          };
        }
        /** @inheritdoc */
      }, {
        key: "sort",
        value: function sort$12(nodeArray) {
          timsort$1.sort(nodeArray, function(a, b) {
            return a.x - b.x;
          });
        }
        /** @inheritdoc */
      }, {
        key: "fix",
        value: function fix2(node, level) {
          node.y = this.layout.options.hierarchical.levelSeparation * level;
          node.options.fixed.y = true;
        }
        /** @inheritdoc */
      }, {
        key: "shift",
        value: function shift(nodeId, diff) {
          this.layout.body.nodes[nodeId].x += diff;
        }
      }]);
      return VerticalStrategy2;
    }(DirectionInterface);
    HorizontalStrategy = function(_DirectionInterface2) {
      inherits(HorizontalStrategy2, _DirectionInterface2);
      var _super2 = _createSuper$t(HorizontalStrategy2);
      function HorizontalStrategy2(layout) {
        var _this2;
        classCallCheck(this, HorizontalStrategy2);
        _this2 = _super2.call(this);
        _this2.layout = layout;
        return _this2;
      }
      createClass(HorizontalStrategy2, [{
        key: "curveType",
        value: function curveType() {
          return "vertical";
        }
        /** @inheritdoc */
      }, {
        key: "getPosition",
        value: function getPosition(node) {
          return node.y;
        }
        /** @inheritdoc */
      }, {
        key: "setPosition",
        value: function setPosition(node, position) {
          var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
          if (level !== void 0) {
            this.layout.hierarchical.addToOrdering(node, level);
          }
          node.y = position;
        }
        /** @inheritdoc */
      }, {
        key: "getTreeSize",
        value: function getTreeSize(index2) {
          var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index2);
          return {
            min: res.min_y,
            max: res.max_y
          };
        }
        /** @inheritdoc */
      }, {
        key: "sort",
        value: function sort$12(nodeArray) {
          timsort$1.sort(nodeArray, function(a, b) {
            return a.y - b.y;
          });
        }
        /** @inheritdoc */
      }, {
        key: "fix",
        value: function fix2(node, level) {
          node.x = this.layout.options.hierarchical.levelSeparation * level;
          node.options.fixed.x = true;
        }
        /** @inheritdoc */
      }, {
        key: "shift",
        value: function shift(nodeId, diff) {
          this.layout.body.nodes[nodeId].y += diff;
        }
      }]);
      return HorizontalStrategy2;
    }(DirectionInterface);
    $every = arrayIteration.every;
    STRICT_METHOD$5 = arrayMethodIsStrict("every");
    USES_TO_LENGTH$9 = arrayMethodUsesToLength("every");
    _export({
      target: "Array",
      proto: true,
      forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$9
    }, {
      every: function every(callbackfn) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    every2 = entryVirtual("Array").every;
    ArrayPrototype$i = Array.prototype;
    every_1 = function(it2) {
      var own = it2.every;
      return it2 === ArrayPrototype$i || it2 instanceof Array && own === ArrayPrototype$i.every ? every2 : own;
    };
    every$1 = every_1;
    every$2 = every$1;
    HierarchicalStatus = function() {
      function HierarchicalStatus2() {
        classCallCheck(this, HierarchicalStatus2);
        this.childrenReference = {};
        this.parentReference = {};
        this.trees = {};
        this.distributionOrdering = {};
        this.levels = {};
        this.distributionIndex = {};
        this.isTree = false;
        this.treeIndex = -1;
      }
      createClass(HierarchicalStatus2, [{
        key: "addRelation",
        value: function addRelation(parentNodeId, childNodeId) {
          if (this.childrenReference[parentNodeId] === void 0) {
            this.childrenReference[parentNodeId] = [];
          }
          this.childrenReference[parentNodeId].push(childNodeId);
          if (this.parentReference[childNodeId] === void 0) {
            this.parentReference[childNodeId] = [];
          }
          this.parentReference[childNodeId].push(parentNodeId);
        }
        /**
         * Check if the current state is for a formal tree or formal forest.
         *
         * This is the case if every node has at most one parent.
         *
         * Pre: parentReference init'ed properly for current network
         */
      }, {
        key: "checkIfTree",
        value: function checkIfTree() {
          for (var i in this.parentReference) {
            if (this.parentReference[i].length > 1) {
              this.isTree = false;
              return;
            }
          }
          this.isTree = true;
        }
        /**
         * Return the number of separate trees in the current network.
         * @returns {number}
         */
      }, {
        key: "numTrees",
        value: function numTrees() {
          return this.treeIndex + 1;
        }
        /**
         * Assign a tree id to a node
         * @param {Node} node
         * @param {string|number} treeId
         */
      }, {
        key: "setTreeIndex",
        value: function setTreeIndex(node, treeId) {
          if (treeId === void 0) return;
          if (this.trees[node.id] === void 0) {
            this.trees[node.id] = treeId;
            this.treeIndex = Math.max(treeId, this.treeIndex);
          }
        }
        /**
         * Ensure level for given id is defined.
         *
         * Sets level to zero for given node id if not already present
         *
         * @param {Node.id} nodeId
         */
      }, {
        key: "ensureLevel",
        value: function ensureLevel(nodeId) {
          if (this.levels[nodeId] === void 0) {
            this.levels[nodeId] = 0;
          }
        }
        /**
         * get the maximum level of a branch.
         *
         * TODO: Never entered; find a test case to test this!
         * @param {Node.id} nodeId
         * @returns {number}
         */
      }, {
        key: "getMaxLevel",
        value: function getMaxLevel(nodeId) {
          var _this = this;
          var accumulator = {};
          var _getMaxLevel = function _getMaxLevel2(nodeId2) {
            if (accumulator[nodeId2] !== void 0) {
              return accumulator[nodeId2];
            }
            var level = _this.levels[nodeId2];
            if (_this.childrenReference[nodeId2]) {
              var children = _this.childrenReference[nodeId2];
              if (children.length > 0) {
                for (var i = 0; i < children.length; i++) {
                  level = Math.max(level, _getMaxLevel2(children[i]));
                }
              }
            }
            accumulator[nodeId2] = level;
            return level;
          };
          return _getMaxLevel(nodeId);
        }
        /**
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         */
      }, {
        key: "levelDownstream",
        value: function levelDownstream(nodeA, nodeB) {
          if (this.levels[nodeB.id] === void 0) {
            if (this.levels[nodeA.id] === void 0) {
              this.levels[nodeA.id] = 0;
            }
            this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
          }
        }
        /**
         * Small util method to set the minimum levels of the nodes to zero.
         *
         * @param {Array.<Node>} nodes
         */
      }, {
        key: "setMinLevelToZero",
        value: function setMinLevelToZero(nodes) {
          var minLevel = 1e9;
          for (var nodeId in nodes) {
            if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
              if (this.levels[nodeId] !== void 0) {
                minLevel = Math.min(this.levels[nodeId], minLevel);
              }
            }
          }
          for (var _nodeId in nodes) {
            if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {
              if (this.levels[_nodeId] !== void 0) {
                this.levels[_nodeId] -= minLevel;
              }
            }
          }
        }
        /**
         * Get the min and max xy-coordinates of a given tree
         *
         * @param {Array.<Node>} nodes
         * @param {number} index
         * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
         */
      }, {
        key: "getTreeSize",
        value: function getTreeSize(nodes, index2) {
          var min_x = 1e9;
          var max_x = -1e9;
          var min_y = 1e9;
          var max_y = -1e9;
          for (var nodeId in this.trees) {
            if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {
              if (this.trees[nodeId] === index2) {
                var node = nodes[nodeId];
                min_x = Math.min(node.x, min_x);
                max_x = Math.max(node.x, max_x);
                min_y = Math.min(node.y, min_y);
                max_y = Math.max(node.y, max_y);
              }
            }
          }
          return {
            min_x,
            max_x,
            min_y,
            max_y
          };
        }
        /**
         * Check if two nodes have the same parent(s)
         *
         * @param {Node} node1
         * @param {Node} node2
         * @return {boolean} true if the two nodes have a same ancestor node, false otherwise
         */
      }, {
        key: "hasSameParent",
        value: function hasSameParent(node1, node2) {
          var parents1 = this.parentReference[node1.id];
          var parents2 = this.parentReference[node2.id];
          if (parents1 === void 0 || parents2 === void 0) {
            return false;
          }
          for (var i = 0; i < parents1.length; i++) {
            for (var j = 0; j < parents2.length; j++) {
              if (parents1[i] == parents2[j]) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * Check if two nodes are in the same tree.
         *
         * @param {Node} node1
         * @param {Node} node2
         * @return {Boolean} true if this is so, false otherwise
         */
      }, {
        key: "inSameSubNetwork",
        value: function inSameSubNetwork(node1, node2) {
          return this.trees[node1.id] === this.trees[node2.id];
        }
        /**
         * Get a list of the distinct levels in the current network
         *
         * @returns {Array}
         */
      }, {
        key: "getLevels",
        value: function getLevels() {
          return keys$3(this.distributionOrdering);
        }
        /**
         * Add a node to the ordering per level
         *
         * @param {Node} node
         * @param {number} level
         */
      }, {
        key: "addToOrdering",
        value: function addToOrdering(node, level) {
          if (this.distributionOrdering[level] === void 0) {
            this.distributionOrdering[level] = [];
          }
          var isPresent = false;
          var curLevel = this.distributionOrdering[level];
          for (var n in curLevel) {
            if (curLevel[n] === node) {
              isPresent = true;
              break;
            }
          }
          if (!isPresent) {
            this.distributionOrdering[level].push(node);
            this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
          }
        }
      }]);
      return HierarchicalStatus2;
    }();
    LayoutEngine = function() {
      function LayoutEngine2(body) {
        classCallCheck(this, LayoutEngine2);
        this.body = body;
        this._resetRNG(Math.random() + ":" + now$2());
        this.setPhysics = false;
        this.options = {};
        this.optionsBackup = {
          physics: {}
        };
        this.defaultOptions = {
          randomSeed: void 0,
          improvedLayout: true,
          clusterThreshold: 150,
          hierarchical: {
            enabled: false,
            levelSeparation: 150,
            nodeSpacing: 100,
            treeSpacing: 200,
            blockShifting: true,
            edgeMinimization: true,
            parentCentralization: true,
            direction: "UD",
            // UD, DU, LR, RL
            sortMethod: "hubsize"
            // hubsize, directed
          }
        };
        assign$2(this.options, this.defaultOptions);
        this.bindEventListeners();
      }
      createClass(LayoutEngine2, [{
        key: "bindEventListeners",
        value: function bindEventListeners() {
          var _this2 = this;
          this.body.emitter.on("_dataChanged", function() {
            _this2.setupHierarchicalLayout();
          });
          this.body.emitter.on("_dataLoaded", function() {
            _this2.layoutNetwork();
          });
          this.body.emitter.on("_resetHierarchicalLayout", function() {
            _this2.setupHierarchicalLayout();
          });
          this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function() {
            if (_this2.options.hierarchical.enabled !== true) {
              return;
            }
            var type = _this2.direction.curveType();
            _this2.body.emitter.emit("_forceDisableDynamicCurves", type, false);
          });
        }
        /**
         *
         * @param {Object} options
         * @param {Object} allOptions
         * @returns {Object}
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2, allOptions2) {
          if (options2 !== void 0) {
            var hierarchical = this.options.hierarchical;
            var prevHierarchicalState = hierarchical.enabled;
            selectiveDeepExtend(["randomSeed", "improvedLayout", "clusterThreshold"], this.options, options2);
            mergeOptions(this.options, options2, "hierarchical");
            if (options2.randomSeed !== void 0) {
              this._resetRNG(options2.randomSeed);
            }
            if (hierarchical.enabled === true) {
              if (prevHierarchicalState === true) {
                this.body.emitter.emit("refresh", true);
              }
              if (hierarchical.direction === "RL" || hierarchical.direction === "DU") {
                if (hierarchical.levelSeparation > 0) {
                  hierarchical.levelSeparation *= -1;
                }
              } else {
                if (hierarchical.levelSeparation < 0) {
                  hierarchical.levelSeparation *= -1;
                }
              }
              this.setDirectionStrategy();
              this.body.emitter.emit("_resetHierarchicalLayout");
              return this.adaptAllOptionsForHierarchicalLayout(allOptions2);
            } else {
              if (prevHierarchicalState === true) {
                this.body.emitter.emit("refresh");
                return deepExtend(allOptions2, this.optionsBackup);
              }
            }
          }
          return allOptions2;
        }
        /**
         * Reset the random number generator with given seed.
         *
         * @param {any} seed - The seed that will be forwarded the the RNG.
         */
      }, {
        key: "_resetRNG",
        value: function _resetRNG(seed) {
          this.initialRandomSeed = seed;
          this._rng = Alea(this.initialRandomSeed);
        }
        /**
         *
         * @param {Object} allOptions
         * @returns {Object}
         */
      }, {
        key: "adaptAllOptionsForHierarchicalLayout",
        value: function adaptAllOptionsForHierarchicalLayout(allOptions2) {
          if (this.options.hierarchical.enabled === true) {
            var backupPhysics = this.optionsBackup.physics;
            if (allOptions2.physics === void 0 || allOptions2.physics === true) {
              allOptions2.physics = {
                enabled: backupPhysics.enabled === void 0 ? true : backupPhysics.enabled,
                solver: "hierarchicalRepulsion"
              };
              backupPhysics.enabled = backupPhysics.enabled === void 0 ? true : backupPhysics.enabled;
              backupPhysics.solver = backupPhysics.solver || "barnesHut";
            } else if (_typeof_1(allOptions2.physics) === "object") {
              backupPhysics.enabled = allOptions2.physics.enabled === void 0 ? true : allOptions2.physics.enabled;
              backupPhysics.solver = allOptions2.physics.solver || "barnesHut";
              allOptions2.physics.solver = "hierarchicalRepulsion";
            } else if (allOptions2.physics !== false) {
              backupPhysics.solver = "barnesHut";
              allOptions2.physics = {
                solver: "hierarchicalRepulsion"
              };
            }
            var type = this.direction.curveType();
            if (allOptions2.edges === void 0) {
              this.optionsBackup.edges = {
                smooth: {
                  enabled: true,
                  type: "dynamic"
                }
              };
              allOptions2.edges = {
                smooth: false
              };
            } else if (allOptions2.edges.smooth === void 0) {
              this.optionsBackup.edges = {
                smooth: {
                  enabled: true,
                  type: "dynamic"
                }
              };
              allOptions2.edges.smooth = false;
            } else {
              if (typeof allOptions2.edges.smooth === "boolean") {
                this.optionsBackup.edges = {
                  smooth: allOptions2.edges.smooth
                };
                allOptions2.edges.smooth = {
                  enabled: allOptions2.edges.smooth,
                  type
                };
              } else {
                var smooth = allOptions2.edges.smooth;
                if (smooth.type !== void 0 && smooth.type !== "dynamic") {
                  type = smooth.type;
                }
                this.optionsBackup.edges = {
                  smooth: {
                    enabled: smooth.enabled === void 0 ? true : smooth.enabled,
                    type: smooth.type === void 0 ? "dynamic" : smooth.type,
                    roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
                    forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
                  }
                };
                allOptions2.edges.smooth = {
                  enabled: smooth.enabled === void 0 ? true : smooth.enabled,
                  type,
                  roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
                  forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
                };
              }
            }
            this.body.emitter.emit("_forceDisableDynamicCurves", type);
          }
          return allOptions2;
        }
        /**
         *
         * @param {Array.<Node>} nodesArray
         */
      }, {
        key: "positionInitially",
        value: function positionInitially(nodesArray) {
          if (this.options.hierarchical.enabled !== true) {
            this._resetRNG(this.initialRandomSeed);
            var radius = nodesArray.length + 50;
            for (var i = 0; i < nodesArray.length; i++) {
              var node = nodesArray[i];
              var angle = 2 * Math.PI * this._rng();
              if (node.x === void 0) {
                node.x = radius * Math.cos(angle);
              }
              if (node.y === void 0) {
                node.y = radius * Math.sin(angle);
              }
            }
          }
        }
        /**
         * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
         * cluster them first to reduce the amount.
         */
      }, {
        key: "layoutNetwork",
        value: function layoutNetwork() {
          if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
            var indices = this.body.nodeIndices;
            var positionDefined = 0;
            for (var i = 0; i < indices.length; i++) {
              var node = this.body.nodes[indices[i]];
              if (node.predefinedPosition === true) {
                positionDefined += 1;
              }
            }
            if (positionDefined < 0.5 * indices.length) {
              var MAX_LEVELS = 10;
              var level = 0;
              var clusterThreshold = this.options.clusterThreshold;
              var clusterOptions = {
                clusterNodeProperties: {
                  shape: "ellipse",
                  // Bugfix: avoid type 'image', no images supplied
                  label: "",
                  // avoid label handling
                  group: "",
                  // avoid group handling
                  font: {
                    multi: false
                  }
                  // avoid font propagation
                },
                clusterEdgeProperties: {
                  label: "",
                  // avoid label handling
                  font: {
                    multi: false
                  },
                  // avoid font propagation
                  smooth: {
                    enabled: false
                    // avoid drawing penalty for complex edges
                  }
                }
              };
              if (indices.length > clusterThreshold) {
                var startLength = indices.length;
                while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
                  level += 1;
                  var before = indices.length;
                  if (level % 3 === 0) {
                    this.body.modules.clustering.clusterBridges(clusterOptions);
                  } else {
                    this.body.modules.clustering.clusterOutliers(clusterOptions);
                  }
                  var after = indices.length;
                  if (before == after && level % 3 !== 0) {
                    this._declusterAll();
                    this.body.emitter.emit("_layoutFailed");
                    console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                    return;
                  }
                }
                this.body.modules.kamadaKawai.setOptions({
                  springLength: Math.max(150, 2 * startLength)
                });
              }
              if (level > MAX_LEVELS) {
                console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result.");
              }
              this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);
              this._shiftToCenter();
              var offset = 70;
              for (var _i = 0; _i < indices.length; _i++) {
                var _node = this.body.nodes[indices[_i]];
                if (_node.predefinedPosition === false) {
                  _node.x += (0.5 - this._rng()) * offset;
                  _node.y += (0.5 - this._rng()) * offset;
                }
              }
              this._declusterAll();
              this.body.emitter.emit("_repositionBezierNodes");
            }
          }
        }
        /**
         * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
         * @private
         */
      }, {
        key: "_shiftToCenter",
        value: function _shiftToCenter() {
          var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
          var center = NetworkUtil.findCenter(range);
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            node.x -= center.x;
            node.y -= center.y;
          }
        }
        /**
         * Expands all clusters
         * @private
         */
      }, {
        key: "_declusterAll",
        value: function _declusterAll() {
          var clustersPresent = true;
          while (clustersPresent === true) {
            clustersPresent = false;
            for (var i = 0; i < this.body.nodeIndices.length; i++) {
              if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
                clustersPresent = true;
                this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
              }
            }
            if (clustersPresent === true) {
              this.body.emitter.emit("_dataChanged");
            }
          }
        }
        /**
         *
         * @returns {number|*}
         */
      }, {
        key: "getSeed",
        value: function getSeed() {
          return this.initialRandomSeed;
        }
        /**
         * This is the main function to layout the nodes in a hierarchical way.
         * It checks if the node details are supplied correctly
         *
         * @private
         */
      }, {
        key: "setupHierarchicalLayout",
        value: function setupHierarchicalLayout() {
          if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
            var node, nodeId;
            var definedLevel = false;
            var undefinedLevel = false;
            this.lastNodeOnLevel = {};
            this.hierarchical = new HierarchicalStatus();
            for (nodeId in this.body.nodes) {
              if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
                node = this.body.nodes[nodeId];
                if (node.options.level !== void 0) {
                  definedLevel = true;
                  this.hierarchical.levels[nodeId] = node.options.level;
                } else {
                  undefinedLevel = true;
                }
              }
            }
            if (undefinedLevel === true && definedLevel === true) {
              throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");
            } else {
              if (undefinedLevel === true) {
                var sortMethod = this.options.hierarchical.sortMethod;
                if (sortMethod === "hubsize") {
                  this._determineLevelsByHubsize();
                } else if (sortMethod === "directed") {
                  this._determineLevelsDirected();
                } else if (sortMethod === "custom") {
                  this._determineLevelsCustomCallback();
                }
              }
              for (var _nodeId2 in this.body.nodes) {
                if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
                  this.hierarchical.ensureLevel(_nodeId2);
                }
              }
              var distribution = this._getDistribution();
              this._generateMap();
              this._placeNodesByHierarchy(distribution);
              this._condenseHierarchy();
              this._shiftToCenter();
            }
          }
        }
        /**
         * @private
         */
      }, {
        key: "_condenseHierarchy",
        value: function _condenseHierarchy() {
          var _this3 = this;
          var stillShifting = false;
          var branches = {};
          var shiftTrees = function shiftTrees2() {
            var treeSizes = getTreeSizes();
            var shiftBy = 0;
            for (var i = 0; i < treeSizes.length - 1; i++) {
              var diff = treeSizes[i].max - treeSizes[i + 1].min;
              shiftBy += diff + _this3.options.hierarchical.treeSpacing;
              shiftTree(i + 1, shiftBy);
            }
          };
          var shiftTree = function shiftTree2(index2, offset) {
            var trees = _this3.hierarchical.trees;
            for (var nodeId in trees) {
              if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {
                if (trees[nodeId] === index2) {
                  _this3.direction.shift(nodeId, offset);
                }
              }
            }
          };
          var getTreeSizes = function getTreeSizes2() {
            var treeWidths = [];
            for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
              treeWidths.push(_this3.direction.getTreeSize(i));
            }
            return treeWidths;
          };
          var getBranchNodes = function getBranchNodes2(source, map3) {
            if (map3[source.id]) {
              return;
            }
            map3[source.id] = true;
            if (_this3.hierarchical.childrenReference[source.id]) {
              var children = _this3.hierarchical.childrenReference[source.id];
              if (children.length > 0) {
                for (var i = 0; i < children.length; i++) {
                  getBranchNodes2(_this3.body.nodes[children[i]], map3);
                }
              }
            }
          };
          var getBranchBoundary = function getBranchBoundary2(branchMap) {
            var maxLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e9;
            var minSpace = 1e9;
            var maxSpace = 1e9;
            var min2 = 1e9;
            var max2 = -1e9;
            for (var branchNode in branchMap) {
              if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {
                var node = _this3.body.nodes[branchNode];
                var level = _this3.hierarchical.levels[node.id];
                var position = _this3.direction.getPosition(node);
                var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap), _this3$_getSpaceAroun2 = slicedToArray(_this3$_getSpaceAroun, 2), minSpaceNode = _this3$_getSpaceAroun2[0], maxSpaceNode = _this3$_getSpaceAroun2[1];
                minSpace = Math.min(minSpaceNode, minSpace);
                maxSpace = Math.min(maxSpaceNode, maxSpace);
                if (level <= maxLevel) {
                  min2 = Math.min(position, min2);
                  max2 = Math.max(position, max2);
                }
              }
            }
            return [min2, max2, minSpace, maxSpace];
          };
          var getCollisionLevel = function getCollisionLevel2(node1, node2) {
            var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);
            var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);
            return Math.min(maxLevel1, maxLevel2);
          };
          var shiftElementsCloser = function shiftElementsCloser2(callback, levels, centerParents) {
            var hier = _this3.hierarchical;
            for (var i = 0; i < levels.length; i++) {
              var level = levels[i];
              var levelNodes = hier.distributionOrdering[level];
              if (levelNodes.length > 1) {
                for (var j = 0; j < levelNodes.length - 1; j++) {
                  var node1 = levelNodes[j];
                  var node2 = levelNodes[j + 1];
                  if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                    callback(node1, node2, centerParents);
                  }
                }
              }
            }
          };
          var branchShiftCallback = function branchShiftCallback2(node1, node2) {
            var centerParent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var pos1 = _this3.direction.getPosition(node1);
            var pos2 = _this3.direction.getPosition(node2);
            var diffAbs = Math.abs(pos2 - pos1);
            var nodeSpacing = _this3.options.hierarchical.nodeSpacing;
            if (diffAbs > nodeSpacing) {
              var branchNodes1 = {};
              var branchNodes2 = {};
              getBranchNodes(node1, branchNodes1);
              getBranchNodes(node2, branchNodes2);
              var maxLevel = getCollisionLevel(node1, node2);
              var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
              var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
              var max1 = branchNodeBoundary1[1];
              var min2 = branchNodeBoundary2[0];
              var minSpace2 = branchNodeBoundary2[2];
              var diffBranch = Math.abs(max1 - min2);
              if (diffBranch > nodeSpacing) {
                var offset = max1 - min2 + nodeSpacing;
                if (offset < -minSpace2 + nodeSpacing) {
                  offset = -minSpace2 + nodeSpacing;
                }
                if (offset < 0) {
                  _this3._shiftBlock(node2.id, offset);
                  stillShifting = true;
                  if (centerParent === true) _this3._centerParent(node2);
                }
              }
            }
          };
          var minimizeEdgeLength = function minimizeEdgeLength2(iterations, node) {
            var nodeId = node.id;
            var allEdges = node.edges;
            var nodeLevel = _this3.hierarchical.levels[node.id];
            var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
            var referenceNodes = {};
            var aboveEdges = [];
            for (var i = 0; i < allEdges.length; i++) {
              var edge = allEdges[i];
              if (edge.toId != edge.fromId) {
                var otherNode = edge.toId == nodeId ? edge.from : edge.to;
                referenceNodes[allEdges[i].id] = otherNode;
                if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
                  aboveEdges.push(edge);
                }
              }
            }
            var getFx = function getFx2(point, edges) {
              var sum = 0;
              for (var _i2 = 0; _i2 < edges.length; _i2++) {
                if (referenceNodes[edges[_i2].id] !== void 0) {
                  var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;
                  sum += a / Math.sqrt(a * a + C2);
                }
              }
              return sum;
            };
            var getDFx = function getDFx2(point, edges) {
              var sum = 0;
              for (var _i3 = 0; _i3 < edges.length; _i3++) {
                if (referenceNodes[edges[_i3].id] !== void 0) {
                  var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;
                  sum -= C2 * Math.pow(a * a + C2, -1.5);
                }
              }
              return sum;
            };
            var getGuess = function getGuess2(iterations2, edges) {
              var guess2 = _this3.direction.getPosition(node);
              var guessMap = {};
              for (var _i4 = 0; _i4 < iterations2; _i4++) {
                var fx = getFx(guess2, edges);
                var dfx = getDFx(guess2, edges);
                var limit = 40;
                var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
                guess2 = guess2 - ratio;
                if (guessMap[guess2] !== void 0) {
                  break;
                }
                guessMap[guess2] = _i4;
              }
              return guess2;
            };
            var moveBranch = function moveBranch2(guess2) {
              var nodePosition = _this3.direction.getPosition(node);
              if (branches[node.id] === void 0) {
                var branchNodes = {};
                getBranchNodes(node, branchNodes);
                branches[node.id] = branchNodes;
              }
              var branchBoundary = getBranchBoundary(branches[node.id]);
              var minSpaceBranch = branchBoundary[2];
              var maxSpaceBranch = branchBoundary[3];
              var diff = guess2 - nodePosition;
              var branchOffset = 0;
              if (diff > 0) {
                branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
              } else if (diff < 0) {
                branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
              }
              if (branchOffset != 0) {
                _this3._shiftBlock(node.id, branchOffset);
                stillShifting = true;
              }
            };
            var moveNode = function moveNode2(guess2) {
              var nodePosition = _this3.direction.getPosition(node);
              var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node), _this3$_getSpaceAroun4 = slicedToArray(_this3$_getSpaceAroun3, 2), minSpace = _this3$_getSpaceAroun4[0], maxSpace = _this3$_getSpaceAroun4[1];
              var diff = guess2 - nodePosition;
              var newPosition = nodePosition;
              if (diff > 0) {
                newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess2);
              } else if (diff < 0) {
                newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess2);
              }
              if (newPosition !== nodePosition) {
                _this3.direction.setPosition(node, newPosition);
                stillShifting = true;
              }
            };
            var guess = getGuess(iterations, aboveEdges);
            moveBranch(guess);
            guess = getGuess(iterations, allEdges);
            moveNode(guess);
          };
          var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp2(iterations) {
            var levels = _this3.hierarchical.getLevels();
            levels = reverse$2(levels).call(levels);
            for (var i = 0; i < iterations; i++) {
              stillShifting = false;
              for (var j = 0; j < levels.length; j++) {
                var level = levels[j];
                var levelNodes = _this3.hierarchical.distributionOrdering[level];
                for (var k = 0; k < levelNodes.length; k++) {
                  minimizeEdgeLength(1e3, levelNodes[k]);
                }
              }
              if (stillShifting !== true) {
                break;
              }
            }
          };
          var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp2(iterations) {
            var levels = _this3.hierarchical.getLevels();
            levels = reverse$2(levels).call(levels);
            for (var i = 0; i < iterations; i++) {
              stillShifting = false;
              shiftElementsCloser(branchShiftCallback, levels, true);
              if (stillShifting !== true) {
                break;
              }
            }
          };
          var centerAllParents = function centerAllParents2() {
            for (var nodeId in _this3.body.nodes) {
              if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);
            }
          };
          var centerAllParentsBottomUp = function centerAllParentsBottomUp2() {
            var levels = _this3.hierarchical.getLevels();
            levels = reverse$2(levels).call(levels);
            for (var i = 0; i < levels.length; i++) {
              var level = levels[i];
              var levelNodes = _this3.hierarchical.distributionOrdering[level];
              for (var j = 0; j < levelNodes.length; j++) {
                _this3._centerParent(levelNodes[j]);
              }
            }
          };
          if (this.options.hierarchical.blockShifting === true) {
            shiftBranchesCloserBottomUp(5);
            centerAllParents();
          }
          if (this.options.hierarchical.edgeMinimization === true) {
            minimizeEdgeLengthBottomUp(20);
          }
          if (this.options.hierarchical.parentCentralization === true) {
            centerAllParentsBottomUp();
          }
          shiftTrees();
        }
        /**
         * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
         * This is used to only get the distances to nodes outside of a branch.
         * @param {Node} node
         * @param {{Node.id: vis.Node}} map
         * @returns {number[]}
         * @private
         */
      }, {
        key: "_getSpaceAroundNode",
        value: function _getSpaceAroundNode(node, map3) {
          var useMap = true;
          if (map3 === void 0) {
            useMap = false;
          }
          var level = this.hierarchical.levels[node.id];
          if (level !== void 0) {
            var index2 = this.hierarchical.distributionIndex[node.id];
            var position = this.direction.getPosition(node);
            var ordering = this.hierarchical.distributionOrdering[level];
            var minSpace = 1e9;
            var maxSpace = 1e9;
            if (index2 !== 0) {
              var prevNode = ordering[index2 - 1];
              if (useMap === true && map3[prevNode.id] === void 0 || useMap === false) {
                var prevPos = this.direction.getPosition(prevNode);
                minSpace = position - prevPos;
              }
            }
            if (index2 != ordering.length - 1) {
              var nextNode = ordering[index2 + 1];
              if (useMap === true && map3[nextNode.id] === void 0 || useMap === false) {
                var nextPos = this.direction.getPosition(nextNode);
                maxSpace = Math.min(maxSpace, nextPos - position);
              }
            }
            return [minSpace, maxSpace];
          } else {
            return [0, 0];
          }
        }
        /**
         * We use this method to center a parent node and check if it does not cross other nodes when it does.
         * @param {Node} node
         * @private
         */
      }, {
        key: "_centerParent",
        value: function _centerParent(node) {
          if (this.hierarchical.parentReference[node.id]) {
            var parents = this.hierarchical.parentReference[node.id];
            for (var i = 0; i < parents.length; i++) {
              var parentId = parents[i];
              var parentNode = this.body.nodes[parentId];
              var children = this.hierarchical.childrenReference[parentId];
              if (children !== void 0) {
                var newPosition = this._getCenterPosition(children);
                var position = this.direction.getPosition(parentNode);
                var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode), _this$_getSpaceAround2 = slicedToArray(_this$_getSpaceAround, 2), minSpace = _this$_getSpaceAround2[0], maxSpace = _this$_getSpaceAround2[1];
                var diff = position - newPosition;
                if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
                  this.direction.setPosition(parentNode, newPosition);
                }
              }
            }
          }
        }
        /**
         * This function places the nodes on the canvas based on the hierarchial distribution.
         *
         * @param {Object} distribution | obtained by the function this._getDistribution()
         * @private
         */
      }, {
        key: "_placeNodesByHierarchy",
        value: function _placeNodesByHierarchy(distribution) {
          this.positionedNodes = {};
          for (var level in distribution) {
            if (Object.prototype.hasOwnProperty.call(distribution, level)) {
              var _context;
              var nodeArray = keys$3(distribution[level]);
              nodeArray = this._indexArrayToNodes(nodeArray);
              sort$2(_context = this.direction).call(_context, nodeArray);
              var handledNodeCount = 0;
              for (var i = 0; i < nodeArray.length; i++) {
                var node = nodeArray[i];
                if (this.positionedNodes[node.id] === void 0) {
                  var spacing = this.options.hierarchical.nodeSpacing;
                  var pos = spacing * handledNodeCount;
                  if (handledNodeCount > 0) {
                    pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
                  }
                  this.direction.setPosition(node, pos, level);
                  this._validatePositionAndContinue(node, level, pos);
                  handledNodeCount++;
                }
              }
            }
          }
        }
        /**
         * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
         * on a X position that ensures there will be no overlap.
         *
         * @param {Node.id} parentId
         * @param {number} parentLevel
         * @private
         */
      }, {
        key: "_placeBranchNodes",
        value: function _placeBranchNodes(parentId, parentLevel) {
          var _context2;
          var childRef = this.hierarchical.childrenReference[parentId];
          if (childRef === void 0) {
            return;
          }
          var childNodes = [];
          for (var i = 0; i < childRef.length; i++) {
            childNodes.push(this.body.nodes[childRef[i]]);
          }
          sort$2(_context2 = this.direction).call(_context2, childNodes);
          for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
            var childNode = childNodes[_i5];
            var childNodeLevel = this.hierarchical.levels[childNode.id];
            if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === void 0) {
              var spacing = this.options.hierarchical.nodeSpacing;
              var pos = void 0;
              if (_i5 === 0) {
                pos = this.direction.getPosition(this.body.nodes[parentId]);
              } else {
                pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
              }
              this.direction.setPosition(childNode, pos, childNodeLevel);
              this._validatePositionAndContinue(childNode, childNodeLevel, pos);
            } else {
              return;
            }
          }
          var center = this._getCenterPosition(childNodes);
          this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
        }
        /**
         * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
         * Finally it will call _placeBranchNodes to place the branch nodes.
         * @param {Node} node
         * @param {number} level
         * @param {number} pos
         * @private
         */
      }, {
        key: "_validatePositionAndContinue",
        value: function _validatePositionAndContinue(node, level, pos) {
          if (!this.hierarchical.isTree) return;
          if (this.lastNodeOnLevel[level] !== void 0) {
            var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);
            if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
              var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
              var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);
              this._shiftBlock(sharedParent.withChild, diff);
            }
          }
          this.lastNodeOnLevel[level] = node.id;
          this.positionedNodes[node.id] = true;
          this._placeBranchNodes(node.id, level);
        }
        /**
         * Receives an array with node indices and returns an array with the actual node references.
         * Used for sorting based on node properties.
         * @param {Array.<Node.id>} idArray
         * @returns {Array.<Node>}
         */
      }, {
        key: "_indexArrayToNodes",
        value: function _indexArrayToNodes(idArray) {
          var array2 = [];
          for (var i = 0; i < idArray.length; i++) {
            array2.push(this.body.nodes[idArray[i]]);
          }
          return array2;
        }
        /**
         * This function get the distribution of levels based on hubsize
         *
         * @returns {Object}
         * @private
         */
      }, {
        key: "_getDistribution",
        value: function _getDistribution() {
          var distribution = {};
          var nodeId, node;
          for (nodeId in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
              node = this.body.nodes[nodeId];
              var level = this.hierarchical.levels[nodeId] === void 0 ? 0 : this.hierarchical.levels[nodeId];
              this.direction.fix(node, level);
              if (distribution[level] === void 0) {
                distribution[level] = {};
              }
              distribution[level][nodeId] = node;
            }
          }
          return distribution;
        }
        /**
         * Return the active (i.e. visible) edges for this node
         *
         * @param {Node} node
         * @returns {Array.<vis.Edge>} Array of edge instances
         * @private
         */
      }, {
        key: "_getActiveEdges",
        value: function _getActiveEdges(node) {
          var _this4 = this;
          var result = [];
          forEach$3(node.edges, function(edge) {
            var _context3;
            if (indexOf$3(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {
              result.push(edge);
            }
          });
          return result;
        }
        /**
         * Get the hubsizes for all active nodes.
         *
         * @returns {number}
         * @private
         */
      }, {
        key: "_getHubSizes",
        value: function _getHubSizes() {
          var _this5 = this;
          var hubSizes = {};
          var nodeIds = this.body.nodeIndices;
          forEach$3(nodeIds, function(nodeId) {
            var node = _this5.body.nodes[nodeId];
            var hubSize = _this5._getActiveEdges(node).length;
            hubSizes[hubSize] = true;
          });
          var result = [];
          forEach$3(hubSizes, function(size) {
            result.push(Number(size));
          });
          sort$2(timsort$1).call(timsort$1, result, function(a, b) {
            return b - a;
          });
          return result;
        }
        /**
         * this function allocates nodes in levels based on the recursive branching from the largest hubs.
         *
         * @private
         */
      }, {
        key: "_determineLevelsByHubsize",
        value: function _determineLevelsByHubsize() {
          var _this6 = this;
          var levelDownstream = function levelDownstream2(nodeA, nodeB) {
            _this6.hierarchical.levelDownstream(nodeA, nodeB);
          };
          var hubSizes = this._getHubSizes();
          var _loop = function _loop2(i2) {
            var hubSize = hubSizes[i2];
            if (hubSize === 0) return "break";
            forEach$3(_this6.body.nodeIndices, function(nodeId) {
              var node = _this6.body.nodes[nodeId];
              if (hubSize === _this6._getActiveEdges(node).length) {
                _this6._crawlNetwork(levelDownstream, nodeId);
              }
            });
          };
          for (var i = 0; i < hubSizes.length; ++i) {
            var _ret = _loop(i);
            if (_ret === "break") break;
          }
        }
        /**
         * TODO: release feature
         * TODO: Determine if this feature is needed at all
         *
         * @private
         */
      }, {
        key: "_determineLevelsCustomCallback",
        value: function _determineLevelsCustomCallback() {
          var _this7 = this;
          var minLevel = 1e5;
          var customCallback = function customCallback2(nodeA, nodeB, edge) {
          };
          var levelByDirection = function levelByDirection2(nodeA, nodeB, edge) {
            var levelA = _this7.hierarchical.levels[nodeA.id];
            if (levelA === void 0) {
              levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
            }
            var diff = customCallback(NetworkUtil.cloneOptions(nodeA, "node"), NetworkUtil.cloneOptions(nodeB, "node"), NetworkUtil.cloneOptions(edge, "edge"));
            _this7.hierarchical.levels[nodeB.id] = levelA + diff;
          };
          this._crawlNetwork(levelByDirection);
          this.hierarchical.setMinLevelToZero(this.body.nodes);
        }
        /**
         * Allocate nodes in levels based on the direction of the edges.
         *
         * @private
         */
      }, {
        key: "_determineLevelsDirected",
        value: function _determineLevelsDirected() {
          var _context4, _this8 = this;
          var nodes = reduce$2(_context4 = this.body.nodeIndices).call(_context4, function(acc, id2) {
            acc.set(id2, _this8.body.nodes[id2]);
            return acc;
          }, new map$5());
          var levels = this.hierarchical.levels;
          if (this.options.hierarchical.shakeTowards === "roots") {
            this.hierarchical.levels = fillLevelsByDirectionRoots(nodes, levels);
          } else {
            this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes, levels);
          }
          this.hierarchical.setMinLevelToZero(this.body.nodes);
        }
        /**
         * Update the bookkeeping of parent and child.
         * @private
         */
      }, {
        key: "_generateMap",
        value: function _generateMap() {
          var _this9 = this;
          var fillInRelations = function fillInRelations2(parentNode, childNode) {
            if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
              _this9.hierarchical.addRelation(parentNode.id, childNode.id);
            }
          };
          this._crawlNetwork(fillInRelations);
          this.hierarchical.checkIfTree();
        }
        /**
         * Crawl over the entire network and use a callback on each node couple that is connected to each other.
         * @param {function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
         * @param {Node.id} startingNodeId
         * @private
         */
      }, {
        key: "_crawlNetwork",
        value: function _crawlNetwork() {
          var _this10 = this;
          var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
          };
          var startingNodeId = arguments.length > 1 ? arguments[1] : void 0;
          var progress = {};
          var crawler = function crawler2(node2, tree) {
            if (progress[node2.id] === void 0) {
              _this10.hierarchical.setTreeIndex(node2, tree);
              progress[node2.id] = true;
              var childNode;
              var edges = _this10._getActiveEdges(node2);
              for (var i2 = 0; i2 < edges.length; i2++) {
                var edge = edges[i2];
                if (edge.connected === true) {
                  if (edge.toId == node2.id) {
                    childNode = edge.from;
                  } else {
                    childNode = edge.to;
                  }
                  if (node2.id != childNode.id) {
                    callback(node2, childNode, edge);
                    crawler2(childNode, tree);
                  }
                }
              }
            }
          };
          if (startingNodeId === void 0) {
            var treeIndex = 0;
            for (var i = 0; i < this.body.nodeIndices.length; i++) {
              var nodeId = this.body.nodeIndices[i];
              if (progress[nodeId] === void 0) {
                var node = this.body.nodes[nodeId];
                crawler(node, treeIndex);
                treeIndex += 1;
              }
            }
          } else {
            var _node2 = this.body.nodes[startingNodeId];
            if (_node2 === void 0) {
              console.error("Node not found:", startingNodeId);
              return;
            }
            crawler(_node2);
          }
        }
        /**
         * Shift a branch a certain distance
         * @param {Node.id} parentId
         * @param {number} diff
         * @private
         */
      }, {
        key: "_shiftBlock",
        value: function _shiftBlock(parentId, diff) {
          var _this11 = this;
          var progress = {};
          var shifter = function shifter2(parentId2) {
            if (progress[parentId2]) {
              return;
            }
            progress[parentId2] = true;
            _this11.direction.shift(parentId2, diff);
            var childRef = _this11.hierarchical.childrenReference[parentId2];
            if (childRef !== void 0) {
              for (var i = 0; i < childRef.length; i++) {
                shifter2(childRef[i]);
              }
            }
          };
          shifter(parentId);
        }
        /**
         * Find a common parent between branches.
         * @param {Node.id} childA
         * @param {Node.id} childB
         * @returns {{foundParent, withChild}}
         * @private
         */
      }, {
        key: "_findCommonParent",
        value: function _findCommonParent(childA, childB) {
          var _this12 = this;
          var parents = {};
          var iterateParents = function iterateParents2(parents2, child) {
            var parentRef = _this12.hierarchical.parentReference[child];
            if (parentRef !== void 0) {
              for (var i = 0; i < parentRef.length; i++) {
                var parent = parentRef[i];
                parents2[parent] = true;
                iterateParents2(parents2, parent);
              }
            }
          };
          var findParent = function findParent2(parents2, child) {
            var parentRef = _this12.hierarchical.parentReference[child];
            if (parentRef !== void 0) {
              for (var i = 0; i < parentRef.length; i++) {
                var parent = parentRef[i];
                if (parents2[parent] !== void 0) {
                  return {
                    foundParent: parent,
                    withChild: child
                  };
                }
                var branch = findParent2(parents2, parent);
                if (branch.foundParent !== null) {
                  return branch;
                }
              }
            }
            return {
              foundParent: null,
              withChild: child
            };
          };
          iterateParents(parents, childA);
          return findParent(parents, childB);
        }
        /**
         * Set the strategy pattern for handling the coordinates given the current direction.
         *
         * The individual instances contain all the operations and data specific to a layout direction.
         *
         * @param {Node} node
         * @param {{x: number, y: number}} position
         * @param {number} level
         * @param {boolean} [doNotUpdate=false]
         * @private
         */
      }, {
        key: "setDirectionStrategy",
        value: function setDirectionStrategy() {
          var isVertical = this.options.hierarchical.direction === "UD" || this.options.hierarchical.direction === "DU";
          if (isVertical) {
            this.direction = new VerticalStrategy(this);
          } else {
            this.direction = new HorizontalStrategy(this);
          }
        }
        /**
         * Determine the center position of a branch from the passed list of child nodes
         *
         * This takes into account the positions of all the child nodes.
         * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
         * @return {number}
         * @private
         */
      }, {
        key: "_getCenterPosition",
        value: function _getCenterPosition(childNodes) {
          var minPos = 1e9;
          var maxPos = -1e9;
          for (var i = 0; i < childNodes.length; i++) {
            var childNode = void 0;
            if (childNodes[i].id !== void 0) {
              childNode = childNodes[i];
            } else {
              var childNodeId = childNodes[i];
              childNode = this.body.nodes[childNodeId];
            }
            var position = this.direction.getPosition(childNode);
            minPos = Math.min(minPos, position);
            maxPos = Math.max(maxPos, position);
          }
          return 0.5 * (minPos + maxPos);
        }
      }]);
      return LayoutEngine2;
    }();
    css_248z$3 = "div.vis-network div.vis-manipulation {\n  box-sizing: content-box;\n\n  border-width: 0;\n  border-bottom: 1px;\n  border-style:solid;\n  border-color: #d6d9d8;\n  background: #ffffff; /* Old browsers */\n  background: -moz-linear-gradient(top,  #ffffff 0%, #fcfcfc 48%, #fafafa 50%, #fcfcfc 100%); /* FF3.6+ */\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(48%,#fcfcfc), color-stop(50%,#fafafa), color-stop(100%,#fcfcfc)); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(top,  #ffffff 0%,#fcfcfc 48%,#fafafa 50%,#fcfcfc 100%); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(top,  #ffffff 0%,#fcfcfc 48%,#fafafa 50%,#fcfcfc 100%); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top,  #ffffff 0%,#fcfcfc 48%,#fafafa 50%,#fcfcfc 100%); /* IE10+ */\n  background: linear-gradient(to bottom,  #ffffff 0%,#fcfcfc 48%,#fafafa 50%,#fcfcfc 100%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#fcfcfc',GradientType=0 ); /* IE6-9 */\n\n  padding-top:4px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 28px;\n}\n\ndiv.vis-network div.vis-edit-mode {\n  position:absolute;\n  left: 0;\n  top: 5px;\n  height: 30px;\n}\n\n/* FIXME: shouldn't the vis-close button be a child of the vis-manipulation div? */\n\ndiv.vis-network div.vis-close {\n  position:absolute;\n  right: 0;\n  top: 0;\n  width: 30px;\n  height: 30px;\n\n  background-position: 20px 3px;\n  background-repeat: no-repeat;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADvGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wMi0xNFQxMjowNToxNyswMTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo5ODJjNjBiMC1lM2YzLTA5NDAtODI1NC0xYmU5YjVhNGUxODM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIxODYxNmM2LTM1MWMtNDI0OS04YWFkLWJkZDQ2ZTczNWE0NDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0xNFQxMTo1NTozNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NzwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+cZUZMwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAA2ElEQVR42gDLADT/AS0tLUQFBQUVFxcXtPHx8fPl5eUNCAgITCkpKesEHx8fGgYGBjH+/v4a+Pj4qgQEBFU6OjodMTExzwQUFBSvEBAQEfX19SD19fVqNDQ0CElJSd/9/f2vAwEBAfrn5+fkBwcHLRYWFgsXFxfz29vbo9LS0uwDDQ0NDfPz81orKysXIyMj+ODg4Avh4eEa/f391gMkJCRYPz8/KUhISOMCAgKh8fHxHRsbGx4UFBQQBDk5OeY7Ozv7CAgItPb29vMEBASaJSUlTQ0NDesDAEwpT0Ko8Ri2AAAAAElFTkSuQmCC');\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-close:hover {\n  opacity: 0.6;\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button,\ndiv.vis-network div.vis-edit-mode div.vis-button {\n  float:left;\n  font-family: verdana;\n  font-size: 12px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  display:inline-block;\n  background-position: 0px 0px;\n  background-repeat:no-repeat;\n  height:24px;\n  margin-left: 10px;\n  /*vertical-align:middle;*/\n  cursor: pointer;\n  padding: 0px 8px 0px 8px;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.20);\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.50);\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button.vis-back {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpmOWQ3OGY4ZC1lNzY0LTc1NDgtODZiNy1iNmQ1OGMzZDg2OTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOmY5ZDc4ZjhkLWU3NjQtNzU0OC04NmI3LWI2ZDU4YzNkODY5Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4jq1U/AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAVTSURBVHjanFVfTFNnFP+d77ve8qeVFbBrpcVgRrCRFikFByLxwSAaE32oRCHD6JMxxhhn8G2RxxH3MsOTbyYsmCAxPMmMMYtkIUYmK60OO0qAK23BFlNob0uh3x7WS5jLZPpLbm6+k/P9zrm5v9855PF4UFhYCABgjIExBgAgIqRSqRIi6gDQRkQ1RGTB3wgR0e8AHgH4Sa/XR/EBiAiJRAJ04cIF5Ofng4g2n0gkUkxENwF0c843LzHGQEQQQkCLExEA9ALotVgsUQAQQmgNQhJCbF5kjCEUCl0moj4t5na7fTU1NUpVVVXUYrEkASAcDhe8efOmxOfzWScmJqoBdBNR99LS0hWz2dynNSSEAF28eBGFhYVgjCEcDn9HRD1EhIMHD3o9Hs9kWVlZAh9BKBQqGB4edr58+dKZ+6JbJpOpBwBWV1fB6+rqIMsyIpHIFcZYL2MMra2tY5cuXRrfuXNnBtvAYDBk3G63oqpqZm5uzgrgSDKZjBoMhueZTAbc5XIhFouVEtFTxhiOHTs2dv78eS8+Efv374+oqpqZnZ21cs5PJJPJPlmWkyynnBuMMTQ0NHi7uro+mVyDx+Pxulwu71ZOlkqlSonoJhGhvb39s8k1nDx50ss5hyRJN9PpdKlERB2aWjSVaEilUvzBgwcORVEs5eXloXPnzk1sV8BkMiUdDofP7/dXZ7PZDilnIhw4cGBeS1pbW2P37t1zBwKBikQiUUREWFhYsHHO0d7evm0Ru90+/+rVq2rO+XGJiJxEhMrKyhgAjI6OWoeHh5tWVla+4JzDZrO9bW5unhwcHGzz+/32np4e+xaDbfoHAMxmc6ijo2O0oqIiJkkSNjY2HBIRmRljMJvNyWfPnln7+/tPMMZQXl6+0NbW9qK2tjYcj8floaEhqKpq+HCkbD3PzMwYBgYG0NXV9UuusFna2kEgELAQEQ4dOvSis7PzN41Ar9dnrl27NqCNkv/C3bt3zy4tLVmICJxzEBFJRBQmorLFxcWCqqqq0Pj4eO3Y2JhbUZTdra2tL2pra8OJRGLHnTt3zkqS9K+huHU4EhHMZnMoGo0W5OIh7nK5jjLGKq1W69vDhw8rRqMxMjc3t2t5eXnX5ORklc/nM+fl5SWnpqa+0uv1K/n5+Ws6nW5NluXNd15e3ppOp1uz2WyzZ86cGQ0Gg6ZAIFCZzWZ/lYjokRDiuN/vt7W0tMw3NTUpbrd78P79++5gMFgRiUTKHj58WMYYQ3V19etTp05tq6Lp6Wkb5xxCiEfc7XZPM8a6FxcXTfX19a/1en2Gcy5qamreNjY2/qGq6joRZe12+9Tp06e3JY/FYgWPHz8+mhvr3/CWlpbk+vp6PmOseWVlBS6XS9GSJUkSdrs93NDQ8Oe+ffvC/8fJIyMjddFo9Esi6pVleVjT2m0A8Hq9zqGhIefnjoknT544A4GAM/eDbxMReFNTE0pKSpKqqsaI6Pj8/LxVVdWM3W6PfCr5xMTE1zllXS0uLn6aSqXAGxsbodPpoNfrn6uqCs75EUVRrJFIZMfevXsXdTrdxseIE4mEPDIyUu/3++tynd8yGo29RIR0Og26fv06ioqKwBgD5xzv3r27zBjrIyJIkgSHwzFZWVmp7NmzJ1ZaWpoAgGg0WqgoSvHMzIw1GAw6tvjhitFo7NPW5fv370Hd3d0oKCgA53zTQMvLy+VCiKuSJH0rSdLmztZytIWv5RPRD0T0Y3Fx8dzWfby6ugopHo//w4mcc8iyPMc5v5FOp7/PZrOdQohWInIC2C2EgBBigYi8Qoifs9lsv06nWyIiaFxagXg8jr8GAGxuIe7LBeWhAAAAAElFTkSuQmCC');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button.vis-none:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.0);\n  cursor: default;\n}\ndiv.vis-network div.vis-manipulation div.vis-button.vis-none:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.0);\n}\ndiv.vis-network div.vis-manipulation div.vis-button.vis-none {\n  padding: 0;\n}\ndiv.vis-network div.vis-manipulation div.notification {\n  margin: 2px;\n  font-weight: bold;\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button.vis-add {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0YjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2OWVmYWE1NS01ZTI5LTIzNGUtYTUzMy0xNDkxYjM1NDNmYmE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0Yjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjY5ZWZhYTU1LTVlMjktMjM0ZS1hNTMzLTE0OTFiMzU0M2ZiYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5WKqp9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYXSURBVHjafFZtUFTXGX7e9z27sveuMCwYV8ElrA7YSFYHtJUPkaaI0aRqG8wP00zUzljDINNSA/2ROtpO24SxnahlxjYd7SSjmUkymcxYlDhQPzHGisEVp8HwYWCVVVgEsrsuLnL74+5uqTF9Z+7cO/d8PO95zvO851BlZSV0XQcAMDOYGQBARDhX3JRmMDYZwLPMWAzGHACYIgwS46oBNBNwtOL8CwE8EkSEUCgE2rJlC2w2G4go8Zwo/bMDgnoG6gxLfAAAYvPDMCCszKTAMIAGAhrWnf15AAAMwwARIRKJgDZv3gy73Q4iAjPjxIr9VVOMRhbAYKB8zvrO0llrfEsdKwLZek6YAPSFvtSu3GtLawu0ZJ6625SHGBQB1T88t6MxvopgMAjaunUrdF0HM+P4yv27DMYeJmB1RqW3Jnf3tQX2p0L4P9EXuqEd7PmDp+XuMU9sRbvXnnt1TxxACgoKYLVacbzsQDUJGkSATe6qi28uPtzusM6Kxie6NHLGUX3lxVUNX9StPHnn4wy3njuUYcu6n2pNi66avcEXnByP/nv8aiaIyrqz2gO5A9+9FI1GIfn5+WhZdTAdjFMkwMvZOy7uWnTAOz3L4Yk71m3t69fdfTDoUGTBeHTUfiHQ6lo7Z2OXJvpDAChKe+aOCdKRKWxZ2+1qb3yyd3GYmRkQ7GQBVs99wfv6on3eR2k4PdTkDEbH7IuS8/svld/561PJS/pDk1/bzwx94pze7xc5v/H+YPY6r5BAkdrJzODTK46lE6PeYEJt7u+8j+OZwCBiEAgAoNgKJoEQf6PvNvdrXgtZoNhSf7q0KZ3B2AQmVMze0Jmt54S/DcDCVig2NcvEUGxJAE4Pl+YOr0iv6BRSIPAmBeBZAmHlE2sH4p1uhrq1s0MnnEQMBsf8wRASAICQQCCITN1X7/sOuc0kgOVp3/fPs2WHv+coG7gQOJUnLGsUCTxEjPzUohEA+NfIWUdtx0+efzA1kSSkIGyBAQNCKgHAEBAJ3u79U7kiAcWoem/gb5Fd33nrH3kp+SMWtuAB+GllMJxMjCx9QRgA3uiqL5kwHiTlpxb3smlfMDGYGPP1hcMAkJvs8ScpfdJspdj+MK6Pf+5+u29vyb4lR4+BGEziVESAkEpw6Av1OhUpHCz4qOXbzFWz4Ncdj/v/o08Lt92ODDgZDCEFJYoUGH4mzugP92puPTf0pD3H7wvfdFZdqSxnMtWjoGAAmG9fOLxjwesdjT2/XzIQ7ks3sycYMSEwGHNtWf5bkX5NkYCJBxUBXiGV0XHvosOt54Zey33j/K+8P33++vjnbiGJbbLE+J9SANAb6nJ2B79wcUwETAwQQ7fMjPzMvfP8ja87HUIKMOiaAqMZhrGmLdAy78eZrwwsTS0eObTs+IdtgVanxBUExqGbb5VzrIISGIoUXsmqbgEhJldCQWqRf27SvPAn/o8XmgLhZsUkR4ll37mhk3n94Z4OlzY/7NLcYZfm7o1z2zT4vsvUNSXqprBCkmiTFbPX90/fh8GIT2sf+zTPdDMf4dVnNg4z+E0ixsGeBs9jd5ViSgLHjCb/peaR+MD3d4/ZJg2llyuG2Vwy7QWAs8PNnn1f7vkGSGxAzE6mk+kxkx/p/4unffSCR0hAoL1EBCYiPNdWNcwkNQTCR7feWX6g+7f/A7I8rcw/U6UEe0Ndrhc/W7mtL9ztmqlSgstSS/zTJ28dalpOpkRryrwbhwBACgsLMWPGDOT4ll3qyeqAkJTdCF7P/CrUY/GkLL1rE+2hTbSH8+0Lb/WEuhzhyaA905blf9Vd/895WnZwLHrPevir/cvOB1oLYpTtLrm6oYGIMDExAaqtrUVKSgqYGSKCk0WHq5ikkWEWtNL0imv5qUW+RclLRjJsrhBAuH1/QL8R7HR4xy5nescuP23E6hOA6mLv+sb4uTw6Ogqqq6uDpmkQkcStorX4XRcM1FjZ+kvFFjCJKU1WpkNJJUqIMtX1RyLeX3JtQ0JRhmGYZ/L27duRnJycuFGISOJ9pqh5lrB6iYgqGOxRrOaa54DcZmKvkJxk8JHC9rKh+KVhOsD4+Dj+MwADIf8n5m4xGwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button.vis-edit,\ndiv.vis-network div.vis-edit-mode div.vis-button.vis-edit {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozOWNhNzE5ZC03YzNlLTUyNGEtYmY1NS03NGVmMmM1MzE0YTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjM5Y2E3MTlkLTdjM2UtNTI0YS1iZjU1LTc0ZWYyYzUzMTRhNzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ykninAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYpSURBVHjafFZtTFvnFX7Oea+NudiY2Hwam4CBlgQwXdKREDKUoYg0jbRJ29RJ2VZ1mjRFUxSpA3VTfkzJfkQbS7spU6rtx5Z2UtppScjaHxvLuiatWi2jLEoMIUDCh23g2gbj7+tPuPvhOurawPl1dc99n+c55z33fV46ceIEZFkGADAziAgAQERoe/9ZK4GPM/AcgbsIXAcABCgMvkfAqAa89eDoJyF8LogIqqqChoaGYDAYHr8kItS8uc8iIH6iAa9IkAo5EAQX8pqmgUVBCBggYFgDhv0/GAsBgKZpICJkMhnQ4OAgZFkGEYGZUXmp+0cS+CKBwWA0DVRPOg5Zl2q6zaHyJlnVAMQXVTkwHrUqH0Xsvn+tdQAAMQDgpPLS2MViFY8rkGUZzIzaS/t/xqCzGggtz9e697zsnKhoLUtim4jOq/LE6x7X0nsh16dEZ5a/O3a2SCAOHjwInU6Hujd6ThJ4mCDQ+b2G232v7v6vwarPbQn8MGlMr+X0kpE3Wr5Zt5hL5HPhqYSdQIfKJ+yhxDPKWC6Xg+jt7UXD5b5KBt1kCHS85Ljd8/On3NupfnhFaZj4rWff1B98B1R/hnUmKd36bdtCNl4g0en4edNE/cXwLq8qMTMIPAQwmo/WuHvObA8+9c58k/dKtD0TyZWXN5YGA7ej7epKxspM//7SoNOdWc/Jyq2wiwhDzPxT8cP0jys3VMM7OmL0/77zn4Ydui3b8uiK0jD7RrA77c9Wd57cefPpF+2T6bWsFPWkaiPTCWvTsZpHFU+XrS+8G3AR08F6X+1FJvBxQQzHQOWk2SmrW4FPX/U2LVwPuDZj+fJKl2khPpeyAqA9rzR/YqwuiWXX8taN/CabGkrVuq9YJlkQQDjOAJ5jAhz9Vt9W4N5/rNp8I+vtMV/aZm4zLnUNNt0urdYnF68HWoJj4Wo1mLGUNRr8LEgDgNqeCh8xQIKOsgC7iAjVe83rT9zQa8uNM28u70kspessu8q8zq/V3NcZpVzb9+0zmVhOvvvrhaMVzrJg0zeq7xMVCCwdpnWSGBqjUyJwLTFgbvxie3w31uoWR1Y74r60rdxZqrR8q85t2W2MGCp12bm/KC3hyaSTiMhxuGrKcahqpbjOaDOoEhOEoFqJQCCJvqA85I6bfTdDjQlf2lbxVNlS6wt19yy7jRHZZlDnrinNj/6sHMhnNw2Ogco7O79e5fm/xQywRBBCEAuwn4gQ96bkYj4Vyuq9N1Z3Bj4Od5bs0MXt/dZZ21ctiqFan174q985P+Lfp+U1g7XDON/1ctP458WlVjLyJhOISZE0wM0S1QfuRC3lTjkJAKKEtNC9eIOhSh9xHLZOJRZTFuXDsEoStLkR/768ummsaJG9Pb9oe+9J+xaeSVokiQDSJphAo5uaBuWjiKP4QTqS1cUWU7ayesN66wu22frD1vmVW6GW6T8u9eVjGyZzs+w78Nqu0a2mbvVu1KEJQAgeZRL0liQYyx+GOmKeQpu0rMYsAJPNEFGD2dLodLIy6c9Ys7G8yeSUl3tf2/X3rcBVJSOv34l3sCBogi7z1LH/rBHjl4IJ93/ncQFAnjeImJD0Z8zuCwu9q3djDXqTlAKID5xv+9t2R8n8VcUFBljQ8Gyfe40BYBM4DwDLt8Kue79ZcFkbzfEdbUbv+oN4c9KTtsfm1MbYQqqh+2zrVZYKs/7Ef+byimt1POYiJhDhPBFBIiIEXhxfs7/dfYoIF+auBfYTE/pebx/V8hqBP2ODvD34yvuh/WCAmU75Bx6sIgaI/v5+6PV6JLqUsYr7dpDAoehs0h73pHTWrvKgThYbRSt9UmSjef3MpaUvBz4O72UmADgTOPJguGiZor+/HyUlJWBmJFz+D8xTtlUiOpbwpmrmrweeSXrT+g11k4SBN3RGKUcAVCVdFhyP1nreDbY//NPyEXUlU/Pp4XYycGT6V0Ux2WwWdO7cOZSWlkII8diX7SPPNgDaKdbxoNAxwATBAEkEEgSWCEQAqPAMwqvMdCEwMO0tVqZpWsGTT58+DaPR+PhGIYQAAAgh0P7B3ioW/B0iGiCGiwXbCuOHFSJys6AbYFye2T+xWhT3WYJEIoH/DQBMw3kes8OJPgAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-edit-mode div.vis-button.vis-edit.vis-edit-mode {\n  background-color: #fcfcfc;\n  border: 1px solid #cccccc;\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button.vis-connect {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo3ZWRhMjI0MC0yYTQxLTNlNDQtYWM2My1iNzNiYTE5OWI3Y2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjdlZGEyMjQwLTJhNDEtM2U0NC1hYzYzLWI3M2JhMTk5YjdjYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ubxs+AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAUtSURBVHjajJZ/bNT1Gcdfz/P53PV6B4W7VltLqdAaplIOiMOoyxxJCSs/Gv/yB4gzJroAosmmDklwkYWR0bQsdmkykoojTpcsWYLxD/lRZdMQkTHRtkLZRqG0tIVe7662vTu43n32x/VKZ/jh89cn38/zvN7P5/l88zwf2blzJz6fDwARQUSm1n8s31CM0/VAnbNmsUPuAsDpgEO+Bg4C7//iyv5hvmMiQiqVQpqamvB6vVNwEeG1JZtCBrYi/MrkAwDNgjhwAlbzICBLA0rDb0+/839C6XQaaWxspLCw8Dp86cbNmqVFJQddE6KzdjZ9D89g+B6fSyCOcyn1nxil+O9xKg5HqWFSHGXLjrP7W/ICqVQK2bNnDz6fDxFh65KNvxbHDhF4rJj2bXPo+IGfcW5h5xL4f99P+FCEMIAob75x9t0dAMlkElNXV4e1lteXbNqiQoMaeOFOjrdU868SD2luYyEP6dUh+sYmSHeOU6GO5Z8VLx5+NNZxIpPJ5AS2L3upROCoCvz8Lo7vnkf77cAHhpiz/zIL9vWz8L8p/NvupmM0Q7pjnAoLqz8tDrc8MnQqYVUVhVdF4LEg7b+rvDn8wDDlH0WoPpukLJImSBaMwjcJqmwWts2jPZLG/8kwYVFeVdXXZcFf4yVDc2cNKfBFmD9X+0ncCP58F48eG+Feo2CAUkvs4dl0V/uJvdXLiiV+ut++n7YLSfxPfMMG54ChzB3WIesVWB2i82bw1AR6fJR7C4VsfYiv6u/k3A9nEgP4zXke8DiYHyAOMK+QxPIgnZ9GqSHr1itQJ8DK2fTerDQ+S/bHRXQJaHSCwNIZ2Xh+7+S3VAmwNMBA/tuPZtErgKquUmdMWIFlRURvdamRNEXGwIWrlP47pTMzLiunxghGMwTLvcTWlHAp77s4QNSrYMQtss6ZMgWqCm5cHoDHO1nbk6K8zEN8+3zatv2Hn1b59EqJZdxmYUERg9P9KwpIiAOTdWUWBXuLzB/vZG3P1Un4PNp2d1MbmyD45TWCxuCsQm0x56bHGHFYEZwxok7toAA9Sfw3hCcoL/NOwi9QO5wmWO1j4JEgZxTkodmcWRGkf3pcX0r8xoAaBixKu4U5/xwndM+0tpAvS6mP+PZK2nb1UBvPEKwKMLDvPj4ESGc55lGy303sdJKQdZB2rkMdctAB/4gzN+/Q2ENNd4LyUi/xN+bTtquX2thk5nk4wI3gAF+OMNcA1nFQDfK+BY5GqbkwWabTY5QZhXWlnNx1ntrY1Rz87fuvw29m/Sn8J+PUGAFj5T19baA1IspuBZp7cx1x4SwG1cEf+lgRSROs8jGwb+Ht4QB/GSSsAhYano39LWIBxNEIbP14hPDuiyS2VtJuHXQlKKvxM/jiXDq/D/xPlwifGMkJZB2NIoKpr69nxeiZxLHicFSFVWfGqBidIP3LSjrWltD94CyufF/4kQgPuVz2Lz93+dDRa9eu5QQ8Hg8/iXee+Dy4CKMs7xqn4nwKz9IirhQqmVuB42m8ey+x7LMoD6iAON782eChhqmRuXfvXgKBAKqKqtI0/8nNKrQI4BVYXkzHgzPpC88gWuHL/caXrhLoGiN0apSKr0ZZRBZM7q2w5ZnLR1oAnHOMjY0hra2tFBQUYIyZmstvVT1Z6eDlAuEVq7merxmwueNPDXy9PvybjKP5mctHLk4/XTKZRJqbm/H7/VNw1VyEMYbW4FN3WNWnnchKoy5sHeVGBRX6VWi3ymFx7r11Ix8MTX/y5C2RSPC/AQB61erowbpqSwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-button.vis-delete {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowNmE3NWYwMy04MDdhLWUzNGYtYjk1Zi1jZGU2MjM0Mzg4OGY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjA2YTc1ZjAzLTgwN2EtZTM0Zi1iOTVmLWNkZTYyMzQzODg4Zjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4aYJzYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYGSURBVHjalJZ7UJTnFcZ/73m/72PdJY1RbhoQp6lkXRAvmIYxdCUadLVOozPNtGObap1JsKipjiShbdoRbeKEiQHpQK3xj0xa03aamTbaTGyAYV1QGeqFi+JyiZFLAlmESBkWRmS3fyzslGkmnZ5/v/M873Oe75zzvqqoqAibzQaAiKCUAkApRdHIK/NFsx2NR91nOSILADDoJyzNaM4xxbtvPHh0iC+JiYkJ1OHDh4mJiUEpFSXPv/ziPC28TIiXDCOSrAClQDSEpsCwJPIhrEBRQpiSytXlQwDhcBilFPfu3UMVFxdjt9ujFTzfcLBADCoEEAFr1ZbrrNjch2vtEImPBgHob7fTcWE+bVXJNJ/NiFQlEGLvieXHKmYqGB8fRx05cgSbzYaIsPvywV8pKFaA7fGtLTzz61YWpo/xVTHQbufsq5lcez9zWuWhk5mvFwMEg0H0+vXrMU2Tn1wp3CtCiQ5DjGd3A/m/v8IDCZP8r4iNmyRrWx/j/5qktykZpXKzAjVDVxPzGqemptDr1q1jX3NRnIJarcDKK2hgR2ULXRfncv7UYv7xpovhnhiW5Mz+kefeSKO6LJ1A1xzEuk/Ojm4mRibpuZaMZW3OCtRUND60NmiICCIUShisx7a2sLMiQn4s77uEQgIabnqdfHIlgT1/qQeg8vs5dHhdCNB1wYn3RIiC995j26stjAbsNH+YiZJCESnS1Y/XxIXu8r4YIPv/VkVs3CTnTy2ms34xro1+sp9po6sxlTu34ultmsPVvy6is86FCHgO+DDs49zpjufBpCG+seYOC9OHaTidieicb9ouVAhKtouAseI710ma7pLuqwmgYfHqAFt+6WdLoQ/LBl11Lm7VudAa8vb72PCin9TlAWIsGGhLACD+kSAZnusYBii1XQAPYWDllt6ov2lrBkDBR2+6Ofuak2//3M+G/T4wAAPW7fPhKfRTVeqk9qQbFKRmDUTxS3N7QYGYmwzCkqklBGlPDEcTNv+sg9tNCbTXuvBWujE0bHrZj9JE1B/wU1Pm5PwJN6YBS9a2kVvQEcWnrh5GTFD3lxkYkqRMgYQlwVldUvDnen73LHTUuqitdKM0eAr9AFQfd1J/yo2aJn+2sn4Wdn5qEFODJskgBIjx5T0uCrQA08pnIjS9PERDjPnfOKXAMEBECUoGEIHBj+2zkt76UQ6dXheGAev3+cg74Kf6uJPqcicbfuond7cPy4SOiy7+tD9nFvZurx00KOk3CNEC+mE+vjSPBc7IWqgqTaPT60IMcO/xsXGa3HfKjRgRdbl7/KDg0jtubje6aHj7c7J3dgLQ2zoPwwQ91SooOQdAW1VKVMHty0kA5Bb48BycJn/LjWFGbLv4thvvb53kFvjJ+XEdWkPfjQVR/CcNKYgGMc8JWt5Fa2j+MIPPuyI2pa4IoHSkt6vLIuRaQ9q32khzt4GCxtNu6k46GeiIR2lIfDQQsafPzq1LGRGL9Gk9d+vrwewvfHPQOoexQVjxdB/auk/zmaUMdsfz6bVUtIalT7bxveP1ZHh6GPDPYeSzeD69kcpIfxymFWLNrka+ljhBTWkWwz2JiJT84YHnz2iPx0P20PkmRF5i6HYiwZFJsn/YzdezbzE3cQibY5xV266z6RfXohakb+xB9CjanCD9qTbW7Grk4WV38VZm0l6dhQiEw9taHSuDqrS0FIfDwXM3X9mHMsvRAk/sauDpQy38P+GtzOTGB9mEpkD0C2dS8n8zOjqK9ng8WJZFU+JTjasGvaCNXPpvJBPoMlm0OoDNMfWVxONfWNSUPUZ7TUQ56tCZlPwSgMnJSVRpaSmxsbFE1raw82ZxAZZRQUiBYUKGp5UlOX2krBzmoUVjiIKhHge9rfPo+Wcy3ZeXIYASgL1/X5RfMXMvj46OosrLy7HZbGitUUohIuzoem0RofALaOsghgWGjky0MiJTL8b0lOvI8hN1DKXKP0jd3TNTWDgcJhgMoo4ePYrD4Yi+KmaeLlprnrtXFo9h/AAlG1AqE8yFmBrC+jO0bgH9EVpO/1F2Dc5g//OAsbEx/j0Af+USsQynL1UAAAAASUVORK5CYII=');\n}\n/* top right bottom left */\ndiv.vis-network div.vis-manipulation div.vis-label,\ndiv.vis-network div.vis-edit-mode div.vis-label {\n  margin: 0 0 0 23px;\n  line-height: 25px;\n}\ndiv.vis-network div.vis-manipulation div.vis-separator-line {\n  float:left;\n  display:inline-block;\n  width:1px;\n  height:21px;\n  background-color: #bdbdbd;\n  margin: 0px 7px 0 15px; /*top right bottom left*/\n}\n\n/* TODO: is this redundant?\ndiv.network-navigation_wrapper {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n*/\n";
    styleInject(css_248z$3);
    ManipulationSystem = function() {
      function ManipulationSystem2(body, canvas, selectionHandler, interactionHandler) {
        var _this = this, _context, _context2;
        classCallCheck(this, ManipulationSystem2);
        this.body = body;
        this.canvas = canvas;
        this.selectionHandler = selectionHandler;
        this.interactionHandler = interactionHandler;
        this.editMode = false;
        this.manipulationDiv = void 0;
        this.editModeDiv = void 0;
        this.closeDiv = void 0;
        this.manipulationHammers = [];
        this.temporaryUIFunctions = {};
        this.temporaryEventFunctions = [];
        this.touchTime = 0;
        this.temporaryIds = {
          nodes: [],
          edges: []
        };
        this.guiEnabled = false;
        this.inMode = false;
        this.selectedControlNode = void 0;
        this.options = {};
        this.defaultOptions = {
          enabled: false,
          initiallyActive: false,
          addNode: true,
          addEdge: true,
          editNode: void 0,
          editEdge: true,
          deleteNode: true,
          deleteEdge: true,
          controlNodeStyle: {
            shape: "dot",
            size: 6,
            color: {
              background: "#ff0000",
              border: "#3c3c3c",
              highlight: {
                background: "#07f968",
                border: "#3c3c3c"
              }
            },
            borderWidth: 2,
            borderWidthSelected: 2
          }
        };
        assign$2(this.options, this.defaultOptions);
        this.body.emitter.on("destroy", function() {
          _this._clean();
        });
        this.body.emitter.on("_dataChanged", bind$2(_context = this._restore).call(_context, this));
        this.body.emitter.on("_resetData", bind$2(_context2 = this._restore).call(_context2, this));
      }
      createClass(ManipulationSystem2, [{
        key: "_restore",
        value: function _restore() {
          if (this.inMode !== false) {
            if (this.options.initiallyActive === true) {
              this.enableEditMode();
            } else {
              this.disableEditMode();
            }
          }
        }
        /**
         * Set the Options
         *
         * @param {Object} options
         * @param {Object} allOptions
         * @param {Object} globalOptions
         */
      }, {
        key: "setOptions",
        value: function setOptions(options2, allOptions2, globalOptions) {
          if (allOptions2 !== void 0) {
            if (allOptions2.locale !== void 0) {
              this.options.locale = allOptions2.locale;
            } else {
              this.options.locale = globalOptions.locale;
            }
            if (allOptions2.locales !== void 0) {
              this.options.locales = allOptions2.locales;
            } else {
              this.options.locales = globalOptions.locales;
            }
          }
          if (options2 !== void 0) {
            if (typeof options2 === "boolean") {
              this.options.enabled = options2;
            } else {
              this.options.enabled = true;
              deepExtend(this.options, options2);
            }
            if (this.options.initiallyActive === true) {
              this.editMode = true;
            }
            this._setup();
          }
        }
        /**
         * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
         *
         * @private
         */
      }, {
        key: "toggleEditMode",
        value: function toggleEditMode() {
          if (this.editMode === true) {
            this.disableEditMode();
          } else {
            this.enableEditMode();
          }
        }
        /**
         * Enables Edit Mode
         */
      }, {
        key: "enableEditMode",
        value: function enableEditMode() {
          this.editMode = true;
          this._clean();
          if (this.guiEnabled === true) {
            this.manipulationDiv.style.display = "block";
            this.closeDiv.style.display = "block";
            this.editModeDiv.style.display = "none";
            this.showManipulatorToolbar();
          }
        }
        /**
         * Disables Edit Mode
         */
      }, {
        key: "disableEditMode",
        value: function disableEditMode() {
          this.editMode = false;
          this._clean();
          if (this.guiEnabled === true) {
            this.manipulationDiv.style.display = "none";
            this.closeDiv.style.display = "none";
            this.editModeDiv.style.display = "block";
            this._createEditButton();
          }
        }
        /**
         * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
         *
         * @private
         */
      }, {
        key: "showManipulatorToolbar",
        value: function showManipulatorToolbar() {
          this._clean();
          this.manipulationDOM = {};
          if (this.guiEnabled === true) {
            var _context3, _context4;
            this.editMode = true;
            this.manipulationDiv.style.display = "block";
            this.closeDiv.style.display = "block";
            var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();
            var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
            var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
            var locale = this.options.locales[this.options.locale];
            var needSeperator = false;
            if (this.options.addNode !== false) {
              this._createAddNodeButton(locale);
              needSeperator = true;
            }
            if (this.options.addEdge !== false) {
              if (needSeperator === true) {
                this._createSeperator(1);
              } else {
                needSeperator = true;
              }
              this._createAddEdgeButton(locale);
            }
            if (selectedNodeCount === 1 && typeof this.options.editNode === "function") {
              if (needSeperator === true) {
                this._createSeperator(2);
              } else {
                needSeperator = true;
              }
              this._createEditNodeButton(locale);
            } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
              if (needSeperator === true) {
                this._createSeperator(3);
              } else {
                needSeperator = true;
              }
              this._createEditEdgeButton(locale);
            }
            if (selectedTotalCount !== 0) {
              if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
                if (needSeperator === true) {
                  this._createSeperator(4);
                }
                this._createDeleteButton(locale);
              } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
                if (needSeperator === true) {
                  this._createSeperator(4);
                }
                this._createDeleteButton(locale);
              }
            }
            this._bindHammerToDiv(this.closeDiv, bind$2(_context3 = this.toggleEditMode).call(_context3, this));
            this._temporaryBindEvent("select", bind$2(_context4 = this.showManipulatorToolbar).call(_context4, this));
          }
          this.body.emitter.emit("_redraw");
        }
        /**
         * Create the toolbar for adding Nodes
         */
      }, {
        key: "addNodeMode",
        value: function addNodeMode() {
          var _context6;
          if (this.editMode !== true) {
            this.enableEditMode();
          }
          this._clean();
          this.inMode = "addNode";
          if (this.guiEnabled === true) {
            var _context5;
            var locale = this.options.locales[this.options.locale];
            this.manipulationDOM = {};
            this._createBackButton(locale);
            this._createSeperator();
            this._createDescription(locale["addDescription"] || this.options.locales["en"]["addDescription"]);
            this._bindHammerToDiv(this.closeDiv, bind$2(_context5 = this.toggleEditMode).call(_context5, this));
          }
          this._temporaryBindEvent("click", bind$2(_context6 = this._performAddNode).call(_context6, this));
        }
        /**
         * call the bound function to handle the editing of the node. The node has to be selected.
         */
      }, {
        key: "editNode",
        value: function editNode() {
          var _this2 = this;
          if (this.editMode !== true) {
            this.enableEditMode();
          }
          this._clean();
          var node = this.selectionHandler._getSelectedNode();
          if (node !== void 0) {
            this.inMode = "editNode";
            if (typeof this.options.editNode === "function") {
              if (node.isCluster !== true) {
                var data2 = deepExtend({}, node.options, false);
                data2.x = node.x;
                data2.y = node.y;
                if (this.options.editNode.length === 2) {
                  this.options.editNode(data2, function(finalizedData) {
                    if (finalizedData !== null && finalizedData !== void 0 && _this2.inMode === "editNode") {
                      _this2.body.data.nodes.getDataSet().update(finalizedData);
                    }
                    _this2.showManipulatorToolbar();
                  });
                } else {
                  throw new Error("The function for edit does not support two arguments (data, callback)");
                }
              } else {
                alert(this.options.locales[this.options.locale]["editClusterError"] || this.options.locales["en"]["editClusterError"]);
              }
            } else {
              throw new Error("No function has been configured to handle the editing of nodes.");
            }
          } else {
            this.showManipulatorToolbar();
          }
        }
        /**
         * create the toolbar to connect nodes
         */
      }, {
        key: "addEdgeMode",
        value: function addEdgeMode() {
          var _context8, _context9, _context10, _context11, _context12;
          if (this.editMode !== true) {
            this.enableEditMode();
          }
          this._clean();
          this.inMode = "addEdge";
          if (this.guiEnabled === true) {
            var _context7;
            var locale = this.options.locales[this.options.locale];
            this.manipulationDOM = {};
            this._createBackButton(locale);
            this._createSeperator();
            this._createDescription(locale["edgeDescription"] || this.options.locales["en"]["edgeDescription"]);
            this._bindHammerToDiv(this.closeDiv, bind$2(_context7 = this.toggleEditMode).call(_context7, this));
          }
          this._temporaryBindUI("onTouch", bind$2(_context8 = this._handleConnect).call(_context8, this));
          this._temporaryBindUI("onDragEnd", bind$2(_context9 = this._finishConnect).call(_context9, this));
          this._temporaryBindUI("onDrag", bind$2(_context10 = this._dragControlNode).call(_context10, this));
          this._temporaryBindUI("onRelease", bind$2(_context11 = this._finishConnect).call(_context11, this));
          this._temporaryBindUI("onDragStart", bind$2(_context12 = this._dragStartEdge).call(_context12, this));
          this._temporaryBindUI("onHold", function() {
          });
        }
        /**
         * create the toolbar to edit edges
         */
      }, {
        key: "editEdgeMode",
        value: function editEdgeMode() {
          if (this.editMode !== true) {
            this.enableEditMode();
          }
          this._clean();
          this.inMode = "editEdge";
          if (_typeof_1(this.options.editEdge) === "object" && typeof this.options.editEdge.editWithoutDrag === "function") {
            this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
            if (this.edgeBeingEditedId !== void 0) {
              var edge = this.body.edges[this.edgeBeingEditedId];
              this._performEditEdge(edge.from.id, edge.to.id);
              return;
            }
          }
          if (this.guiEnabled === true) {
            var _context13;
            var locale = this.options.locales[this.options.locale];
            this.manipulationDOM = {};
            this._createBackButton(locale);
            this._createSeperator();
            this._createDescription(locale["editEdgeDescription"] || this.options.locales["en"]["editEdgeDescription"]);
            this._bindHammerToDiv(this.closeDiv, bind$2(_context13 = this.toggleEditMode).call(_context13, this));
          }
          this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
          if (this.edgeBeingEditedId !== void 0) {
            var _context14, _context15, _context16, _context17;
            var _edge = this.body.edges[this.edgeBeingEditedId];
            var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);
            var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);
            this.temporaryIds.nodes.push(controlNodeFrom.id);
            this.temporaryIds.nodes.push(controlNodeTo.id);
            this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
            this.body.nodeIndices.push(controlNodeFrom.id);
            this.body.nodes[controlNodeTo.id] = controlNodeTo;
            this.body.nodeIndices.push(controlNodeTo.id);
            this._temporaryBindUI("onTouch", bind$2(_context14 = this._controlNodeTouch).call(_context14, this));
            this._temporaryBindUI("onTap", function() {
            });
            this._temporaryBindUI("onHold", function() {
            });
            this._temporaryBindUI("onDragStart", bind$2(_context15 = this._controlNodeDragStart).call(_context15, this));
            this._temporaryBindUI("onDrag", bind$2(_context16 = this._controlNodeDrag).call(_context16, this));
            this._temporaryBindUI("onDragEnd", bind$2(_context17 = this._controlNodeDragEnd).call(_context17, this));
            this._temporaryBindUI("onMouseMove", function() {
            });
            this._temporaryBindEvent("beforeDrawing", function(ctx) {
              var positions = _edge.edgeType.findBorderPositions(ctx);
              if (controlNodeFrom.selected === false) {
                controlNodeFrom.x = positions.from.x;
                controlNodeFrom.y = positions.from.y;
              }
              if (controlNodeTo.selected === false) {
                controlNodeTo.x = positions.to.x;
                controlNodeTo.y = positions.to.y;
              }
            });
            this.body.emitter.emit("_redraw");
          } else {
            this.showManipulatorToolbar();
          }
        }
        /**
         * delete everything in the selection
         */
      }, {
        key: "deleteSelected",
        value: function deleteSelected() {
          var _this3 = this;
          if (this.editMode !== true) {
            this.enableEditMode();
          }
          this._clean();
          this.inMode = "delete";
          var selectedNodes = this.selectionHandler.getSelectedNodes();
          var selectedEdges = this.selectionHandler.getSelectedEdges();
          var deleteFunction = void 0;
          if (selectedNodes.length > 0) {
            for (var i = 0; i < selectedNodes.length; i++) {
              if (this.body.nodes[selectedNodes[i]].isCluster === true) {
                alert(this.options.locales[this.options.locale]["deleteClusterError"] || this.options.locales["en"]["deleteClusterError"]);
                return;
              }
            }
            if (typeof this.options.deleteNode === "function") {
              deleteFunction = this.options.deleteNode;
            }
          } else if (selectedEdges.length > 0) {
            if (typeof this.options.deleteEdge === "function") {
              deleteFunction = this.options.deleteEdge;
            }
          }
          if (typeof deleteFunction === "function") {
            var data2 = {
              nodes: selectedNodes,
              edges: selectedEdges
            };
            if (deleteFunction.length === 2) {
              deleteFunction(data2, function(finalizedData) {
                if (finalizedData !== null && finalizedData !== void 0 && _this3.inMode === "delete") {
                  _this3.body.data.edges.getDataSet().remove(finalizedData.edges);
                  _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);
                  _this3.body.emitter.emit("startSimulation");
                  _this3.showManipulatorToolbar();
                } else {
                  _this3.body.emitter.emit("startSimulation");
                  _this3.showManipulatorToolbar();
                }
              });
            } else {
              throw new Error("The function for delete does not support two arguments (data, callback)");
            }
          } else {
            this.body.data.edges.getDataSet().remove(selectedEdges);
            this.body.data.nodes.getDataSet().remove(selectedNodes);
            this.body.emitter.emit("startSimulation");
            this.showManipulatorToolbar();
          }
        }
        //********************************************** PRIVATE ***************************************//
        /**
         * draw or remove the DOM
         * @private
         */
      }, {
        key: "_setup",
        value: function _setup() {
          if (this.options.enabled === true) {
            this.guiEnabled = true;
            this._createWrappers();
            if (this.editMode === false) {
              this._createEditButton();
            } else {
              this.showManipulatorToolbar();
            }
          } else {
            this._removeManipulationDOM();
            this.guiEnabled = false;
          }
        }
        /**
         * create the div overlays that contain the DOM
         * @private
         */
      }, {
        key: "_createWrappers",
        value: function _createWrappers() {
          if (this.manipulationDiv === void 0) {
            this.manipulationDiv = document.createElement("div");
            this.manipulationDiv.className = "vis-manipulation";
            if (this.editMode === true) {
              this.manipulationDiv.style.display = "block";
            } else {
              this.manipulationDiv.style.display = "none";
            }
            this.canvas.frame.appendChild(this.manipulationDiv);
          }
          if (this.editModeDiv === void 0) {
            this.editModeDiv = document.createElement("div");
            this.editModeDiv.className = "vis-edit-mode";
            if (this.editMode === true) {
              this.editModeDiv.style.display = "none";
            } else {
              this.editModeDiv.style.display = "block";
            }
            this.canvas.frame.appendChild(this.editModeDiv);
          }
          if (this.closeDiv === void 0) {
            this.closeDiv = document.createElement("div");
            this.closeDiv.className = "vis-close";
            this.closeDiv.style.display = this.manipulationDiv.style.display;
            this.canvas.frame.appendChild(this.closeDiv);
          }
        }
        /**
         * generate a new target node. Used for creating new edges and editing edges
         *
         * @param {number} x
         * @param {number} y
         * @returns {Node}
         * @private
         */
      }, {
        key: "_getNewTargetNode",
        value: function _getNewTargetNode(x, y) {
          var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);
          controlNodeStyle.id = "targetNode" + v4();
          controlNodeStyle.hidden = false;
          controlNodeStyle.physics = false;
          controlNodeStyle.x = x;
          controlNodeStyle.y = y;
          var node = this.body.functions.createNode(controlNodeStyle);
          node.shape.boundingBox = {
            left: x,
            right: x,
            top: y,
            bottom: y
          };
          return node;
        }
        /**
         * Create the edit button
         */
      }, {
        key: "_createEditButton",
        value: function _createEditButton() {
          var _context18;
          this._clean();
          this.manipulationDOM = {};
          recursiveDOMDelete(this.editModeDiv);
          var locale = this.options.locales[this.options.locale];
          var button = this._createButton("editMode", "vis-button vis-edit vis-edit-mode", locale["edit"] || this.options.locales["en"]["edit"]);
          this.editModeDiv.appendChild(button);
          this._bindHammerToDiv(button, bind$2(_context18 = this.toggleEditMode).call(_context18, this));
        }
        /**
         * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
         * @private
         */
      }, {
        key: "_clean",
        value: function _clean() {
          this.inMode = false;
          if (this.guiEnabled === true) {
            recursiveDOMDelete(this.editModeDiv);
            recursiveDOMDelete(this.manipulationDiv);
            this._cleanManipulatorHammers();
          }
          this._cleanupTemporaryNodesAndEdges();
          this._unbindTemporaryUIs();
          this._unbindTemporaryEvents();
          this.body.emitter.emit("restorePhysics");
        }
        /**
         * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
         * @private
         */
      }, {
        key: "_cleanManipulatorHammers",
        value: function _cleanManipulatorHammers() {
          if (this.manipulationHammers.length != 0) {
            for (var i = 0; i < this.manipulationHammers.length; i++) {
              this.manipulationHammers[i].destroy();
            }
            this.manipulationHammers = [];
          }
        }
        /**
         * Remove all DOM elements created by this module.
         * @private
         */
      }, {
        key: "_removeManipulationDOM",
        value: function _removeManipulationDOM() {
          this._clean();
          recursiveDOMDelete(this.manipulationDiv);
          recursiveDOMDelete(this.editModeDiv);
          recursiveDOMDelete(this.closeDiv);
          if (this.manipulationDiv) {
            this.canvas.frame.removeChild(this.manipulationDiv);
          }
          if (this.editModeDiv) {
            this.canvas.frame.removeChild(this.editModeDiv);
          }
          if (this.closeDiv) {
            this.canvas.frame.removeChild(this.closeDiv);
          }
          this.manipulationDiv = void 0;
          this.editModeDiv = void 0;
          this.closeDiv = void 0;
        }
        /**
         * create a seperator line. the index is to differentiate in the manipulation dom
         * @param {number} [index=1]
         * @private
         */
      }, {
        key: "_createSeperator",
        value: function _createSeperator() {
          var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
          this.manipulationDOM["seperatorLineDiv" + index2] = document.createElement("div");
          this.manipulationDOM["seperatorLineDiv" + index2].className = "vis-separator-line";
          this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + index2]);
        }
        // ----------------------    DOM functions for buttons    --------------------------//
        /**
         *
         * @param {Locale} locale
         * @private
         */
      }, {
        key: "_createAddNodeButton",
        value: function _createAddNodeButton(locale) {
          var _context19;
          var button = this._createButton("addNode", "vis-button vis-add", locale["addNode"] || this.options.locales["en"]["addNode"]);
          this.manipulationDiv.appendChild(button);
          this._bindHammerToDiv(button, bind$2(_context19 = this.addNodeMode).call(_context19, this));
        }
        /**
         *
         * @param {Locale} locale
         * @private
         */
      }, {
        key: "_createAddEdgeButton",
        value: function _createAddEdgeButton(locale) {
          var _context20;
          var button = this._createButton("addEdge", "vis-button vis-connect", locale["addEdge"] || this.options.locales["en"]["addEdge"]);
          this.manipulationDiv.appendChild(button);
          this._bindHammerToDiv(button, bind$2(_context20 = this.addEdgeMode).call(_context20, this));
        }
        /**
         *
         * @param {Locale} locale
         * @private
         */
      }, {
        key: "_createEditNodeButton",
        value: function _createEditNodeButton(locale) {
          var _context21;
          var button = this._createButton("editNode", "vis-button vis-edit", locale["editNode"] || this.options.locales["en"]["editNode"]);
          this.manipulationDiv.appendChild(button);
          this._bindHammerToDiv(button, bind$2(_context21 = this.editNode).call(_context21, this));
        }
        /**
         *
         * @param {Locale} locale
         * @private
         */
      }, {
        key: "_createEditEdgeButton",
        value: function _createEditEdgeButton(locale) {
          var _context22;
          var button = this._createButton("editEdge", "vis-button vis-edit", locale["editEdge"] || this.options.locales["en"]["editEdge"]);
          this.manipulationDiv.appendChild(button);
          this._bindHammerToDiv(button, bind$2(_context22 = this.editEdgeMode).call(_context22, this));
        }
        /**
         *
         * @param {Locale} locale
         * @private
         */
      }, {
        key: "_createDeleteButton",
        value: function _createDeleteButton(locale) {
          var _context23;
          var deleteBtnClass;
          if (this.options.rtl) {
            deleteBtnClass = "vis-button vis-delete-rtl";
          } else {
            deleteBtnClass = "vis-button vis-delete";
          }
          var button = this._createButton("delete", deleteBtnClass, locale["del"] || this.options.locales["en"]["del"]);
          this.manipulationDiv.appendChild(button);
          this._bindHammerToDiv(button, bind$2(_context23 = this.deleteSelected).call(_context23, this));
        }
        /**
         *
         * @param {Locale} locale
         * @private
         */
      }, {
        key: "_createBackButton",
        value: function _createBackButton(locale) {
          var _context24;
          var button = this._createButton("back", "vis-button vis-back", locale["back"] || this.options.locales["en"]["back"]);
          this.manipulationDiv.appendChild(button);
          this._bindHammerToDiv(button, bind$2(_context24 = this.showManipulatorToolbar).call(_context24, this));
        }
        /**
         *
         * @param {number|string} id
         * @param {string} className
         * @param {label} label
         * @param {string} labelClassName
         * @returns {HTMLElement}
         * @private
         */
      }, {
        key: "_createButton",
        value: function _createButton(id2, className, label) {
          var labelClassName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "vis-label";
          this.manipulationDOM[id2 + "Div"] = document.createElement("div");
          this.manipulationDOM[id2 + "Div"].className = className;
          this.manipulationDOM[id2 + "Label"] = document.createElement("div");
          this.manipulationDOM[id2 + "Label"].className = labelClassName;
          this.manipulationDOM[id2 + "Label"].innerHTML = label;
          this.manipulationDOM[id2 + "Div"].appendChild(this.manipulationDOM[id2 + "Label"]);
          return this.manipulationDOM[id2 + "Div"];
        }
        /**
         *
         * @param {Label} label
         * @private
         */
      }, {
        key: "_createDescription",
        value: function _createDescription(label) {
          this.manipulationDiv.appendChild(this._createButton("description", "vis-button vis-none", label));
        }
        // -------------------------- End of DOM functions for buttons ------------------------------//
        /**
         * this binds an event until cleanup by the clean functions.
         * @param {Event}  event   The event
         * @param {function} newFunction
         * @private
         */
      }, {
        key: "_temporaryBindEvent",
        value: function _temporaryBindEvent(event, newFunction) {
          this.temporaryEventFunctions.push({
            event,
            boundFunction: newFunction
          });
          this.body.emitter.on(event, newFunction);
        }
        /**
         * this overrides an UI function until cleanup by the clean function
         * @param {string} UIfunctionName
         * @param {function} newFunction
         * @private
         */
      }, {
        key: "_temporaryBindUI",
        value: function _temporaryBindUI(UIfunctionName, newFunction) {
          if (this.body.eventListeners[UIfunctionName] !== void 0) {
            this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
            this.body.eventListeners[UIfunctionName] = newFunction;
          } else {
            throw new Error("This UI function does not exist. Typo? You tried: " + UIfunctionName + " possible are: " + stringify$2(keys$3(this.body.eventListeners)));
          }
        }
        /**
         * Restore the overridden UI functions to their original state.
         *
         * @private
         */
      }, {
        key: "_unbindTemporaryUIs",
        value: function _unbindTemporaryUIs() {
          for (var functionName in this.temporaryUIFunctions) {
            if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName)) {
              this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
              delete this.temporaryUIFunctions[functionName];
            }
          }
          this.temporaryUIFunctions = {};
        }
        /**
         * Unbind the events created by _temporaryBindEvent
         * @private
         */
      }, {
        key: "_unbindTemporaryEvents",
        value: function _unbindTemporaryEvents() {
          for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
            var eventName = this.temporaryEventFunctions[i].event;
            var boundFunction = this.temporaryEventFunctions[i].boundFunction;
            this.body.emitter.off(eventName, boundFunction);
          }
          this.temporaryEventFunctions = [];
        }
        /**
         * Bind an hammer instance to a DOM element.
         *
         * @param {Element} domElement
         * @param {function} boundFunction
         */
      }, {
        key: "_bindHammerToDiv",
        value: function _bindHammerToDiv(domElement, boundFunction) {
          var hammer$1 = new hammer(domElement, {});
          onTouch(hammer$1, boundFunction);
          this.manipulationHammers.push(hammer$1);
        }
        /**
         * Neatly clean up temporary edges and nodes
         * @private
         */
      }, {
        key: "_cleanupTemporaryNodesAndEdges",
        value: function _cleanupTemporaryNodesAndEdges() {
          for (var i = 0; i < this.temporaryIds.edges.length; i++) {
            var _context25;
            this.body.edges[this.temporaryIds.edges[i]].disconnect();
            delete this.body.edges[this.temporaryIds.edges[i]];
            var indexTempEdge = indexOf$3(_context25 = this.body.edgeIndices).call(_context25, this.temporaryIds.edges[i]);
            if (indexTempEdge !== -1) {
              var _context26;
              splice$2(_context26 = this.body.edgeIndices).call(_context26, indexTempEdge, 1);
            }
          }
          for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
            var _context27;
            delete this.body.nodes[this.temporaryIds.nodes[_i]];
            var indexTempNode = indexOf$3(_context27 = this.body.nodeIndices).call(_context27, this.temporaryIds.nodes[_i]);
            if (indexTempNode !== -1) {
              var _context28;
              splice$2(_context28 = this.body.nodeIndices).call(_context28, indexTempNode, 1);
            }
          }
          this.temporaryIds = {
            nodes: [],
            edges: []
          };
        }
        // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//
        /**
         * the touch is used to get the position of the initial click
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "_controlNodeTouch",
        value: function _controlNodeTouch(event) {
          this.selectionHandler.unselectAll();
          this.lastTouch = this.body.functions.getPointer(event.center);
          this.lastTouch.translation = assign$2({}, this.body.view.translation);
        }
        /**
         * the drag start is used to mark one of the control nodes as selected.
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "_controlNodeDragStart",
        value: function _controlNodeDragStart(event) {
          var pointer = this.lastTouch;
          var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
          var from2 = this.body.nodes[this.temporaryIds.nodes[0]];
          var to = this.body.nodes[this.temporaryIds.nodes[1]];
          var edge = this.body.edges[this.edgeBeingEditedId];
          this.selectedControlNode = void 0;
          var fromSelect = from2.isOverlappingWith(pointerObj);
          var toSelect = to.isOverlappingWith(pointerObj);
          if (fromSelect === true) {
            this.selectedControlNode = from2;
            edge.edgeType.from = from2;
          } else if (toSelect === true) {
            this.selectedControlNode = to;
            edge.edgeType.to = to;
          }
          if (this.selectedControlNode !== void 0) {
            this.selectionHandler.selectObject(this.selectedControlNode);
          }
          this.body.emitter.emit("_redraw");
        }
        /**
         * dragging the control nodes or the canvas
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "_controlNodeDrag",
        value: function _controlNodeDrag(event) {
          this.body.emitter.emit("disablePhysics");
          var pointer = this.body.functions.getPointer(event.center);
          var pos = this.canvas.DOMtoCanvas(pointer);
          if (this.selectedControlNode !== void 0) {
            this.selectedControlNode.x = pos.x;
            this.selectedControlNode.y = pos.y;
          } else {
            this.interactionHandler.onDrag(event);
          }
          this.body.emitter.emit("_redraw");
        }
        /**
         * connecting or restoring the control nodes.
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "_controlNodeDragEnd",
        value: function _controlNodeDragEnd(event) {
          var pointer = this.body.functions.getPointer(event.center);
          var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
          var edge = this.body.edges[this.edgeBeingEditedId];
          if (this.selectedControlNode === void 0) {
            return;
          }
          this.selectionHandler.unselectAll();
          var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
          var node = void 0;
          for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
            if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
              node = this.body.nodes[overlappingNodeIds[i]];
              break;
            }
          }
          if (node !== void 0 && this.selectedControlNode !== void 0) {
            if (node.isCluster === true) {
              alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
            } else {
              var from2 = this.body.nodes[this.temporaryIds.nodes[0]];
              if (this.selectedControlNode.id === from2.id) {
                this._performEditEdge(node.id, edge.to.id);
              } else {
                this._performEditEdge(edge.from.id, node.id);
              }
            }
          } else {
            edge.updateEdgeType();
            this.body.emitter.emit("restorePhysics");
          }
          this.body.emitter.emit("_redraw");
        }
        // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//
        // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
        /**
         * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
         * to walk the user through the process.
         *
         * @param {Event} event
         * @private
         */
      }, {
        key: "_handleConnect",
        value: function _handleConnect(event) {
          if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 100) {
            this.lastTouch = this.body.functions.getPointer(event.center);
            this.lastTouch.translation = assign$2({}, this.body.view.translation);
            this.interactionHandler.drag.pointer = this.lastTouch;
            this.interactionHandler.drag.translation = this.lastTouch.translation;
            var pointer = this.lastTouch;
            var node = this.selectionHandler.getNodeAt(pointer);
            if (node !== void 0) {
              if (node.isCluster === true) {
                alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
              } else {
                var targetNode = this._getNewTargetNode(node.x, node.y);
                this.body.nodes[targetNode.id] = targetNode;
                this.body.nodeIndices.push(targetNode.id);
                var connectionEdge = this.body.functions.createEdge({
                  id: "connectionEdge" + v4(),
                  from: node.id,
                  to: targetNode.id,
                  physics: false,
                  smooth: {
                    enabled: true,
                    type: "continuous",
                    roundness: 0.5
                  }
                });
                this.body.edges[connectionEdge.id] = connectionEdge;
                this.body.edgeIndices.push(connectionEdge.id);
                this.temporaryIds.nodes.push(targetNode.id);
                this.temporaryIds.edges.push(connectionEdge.id);
              }
            }
            this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
          }
        }
        /**
         *
         * @param {Event} event
         * @private
         */
      }, {
        key: "_dragControlNode",
        value: function _dragControlNode(event) {
          var pointer = this.body.functions.getPointer(event.center);
          var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
          var connectFromId = void 0;
          if (this.temporaryIds.edges[0] !== void 0) {
            connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
          }
          var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
          var node = void 0;
          for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
            var _context29;
            if (indexOf$3(_context29 = this.temporaryIds.nodes).call(_context29, overlappingNodeIds[i]) === -1) {
              node = this.body.nodes[overlappingNodeIds[i]];
              break;
            }
          }
          event.controlEdge = {
            from: connectFromId,
            to: node ? node.id : void 0
          };
          this.selectionHandler._generateClickEvent("controlNodeDragging", event, pointer);
          if (this.temporaryIds.nodes[0] !== void 0) {
            var targetNode = this.body.nodes[this.temporaryIds.nodes[0]];
            targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
            targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
            this.body.emitter.emit("_redraw");
          } else {
            this.interactionHandler.onDrag(event);
          }
        }
        /**
         * Connect the new edge to the target if one exists, otherwise remove temp line
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "_finishConnect",
        value: function _finishConnect(event) {
          var pointer = this.body.functions.getPointer(event.center);
          var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
          var connectFromId = void 0;
          if (this.temporaryIds.edges[0] !== void 0) {
            connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
          }
          var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
          var node = void 0;
          for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
            var _context30;
            if (indexOf$3(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {
              node = this.body.nodes[overlappingNodeIds[i]];
              break;
            }
          }
          this._cleanupTemporaryNodesAndEdges();
          if (node !== void 0) {
            if (node.isCluster === true) {
              alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
            } else {
              if (this.body.nodes[connectFromId] !== void 0 && this.body.nodes[node.id] !== void 0) {
                this._performAddEdge(connectFromId, node.id);
              }
            }
          }
          event.controlEdge = {
            from: connectFromId,
            to: node ? node.id : void 0
          };
          this.selectionHandler._generateClickEvent("controlNodeDragEnd", event, pointer);
          this.body.emitter.emit("_redraw");
        }
        /**
         *
         * @param {Event} event
         * @private
         */
      }, {
        key: "_dragStartEdge",
        value: function _dragStartEdge(event) {
          var pointer = this.lastTouch;
          this.selectionHandler._generateClickEvent("dragStart", event, pointer, void 0, true);
        }
        // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//
        // ------------------------------ Performing all the actual data manipulation ------------------------//
        /**
         * Adds a node on the specified location
         *
         * @param {Object} clickData
         * @private
         */
      }, {
        key: "_performAddNode",
        value: function _performAddNode(clickData) {
          var _this4 = this;
          var defaultData = {
            id: v4(),
            x: clickData.pointer.canvas.x,
            y: clickData.pointer.canvas.y,
            label: "new"
          };
          if (typeof this.options.addNode === "function") {
            if (this.options.addNode.length === 2) {
              this.options.addNode(defaultData, function(finalizedData) {
                if (finalizedData !== null && finalizedData !== void 0 && _this4.inMode === "addNode") {
                  _this4.body.data.nodes.getDataSet().add(finalizedData);
                }
                _this4.showManipulatorToolbar();
              });
            } else {
              this.showManipulatorToolbar();
              throw new Error("The function for add does not support two arguments (data,callback)");
            }
          } else {
            this.body.data.nodes.getDataSet().add(defaultData);
            this.showManipulatorToolbar();
          }
        }
        /**
         * connect two nodes with a new edge.
         *
         * @param {Node.id} sourceNodeId
         * @param {Node.id} targetNodeId
         * @private
         */
      }, {
        key: "_performAddEdge",
        value: function _performAddEdge(sourceNodeId, targetNodeId) {
          var _this5 = this;
          var defaultData = {
            from: sourceNodeId,
            to: targetNodeId
          };
          if (typeof this.options.addEdge === "function") {
            if (this.options.addEdge.length === 2) {
              this.options.addEdge(defaultData, function(finalizedData) {
                if (finalizedData !== null && finalizedData !== void 0 && _this5.inMode === "addEdge") {
                  _this5.body.data.edges.getDataSet().add(finalizedData);
                  _this5.selectionHandler.unselectAll();
                  _this5.showManipulatorToolbar();
                }
              });
            } else {
              throw new Error("The function for connect does not support two arguments (data,callback)");
            }
          } else {
            this.body.data.edges.getDataSet().add(defaultData);
            this.selectionHandler.unselectAll();
            this.showManipulatorToolbar();
          }
        }
        /**
         * connect two nodes with a new edge.
         *
         * @param {Node.id} sourceNodeId
         * @param {Node.id} targetNodeId
         * @private
         */
      }, {
        key: "_performEditEdge",
        value: function _performEditEdge(sourceNodeId, targetNodeId) {
          var _this6 = this;
          var defaultData = {
            id: this.edgeBeingEditedId,
            from: sourceNodeId,
            to: targetNodeId,
            label: this.body.data.edges.get(this.edgeBeingEditedId).label
          };
          var eeFunct = this.options.editEdge;
          if (_typeof_1(eeFunct) === "object") {
            eeFunct = eeFunct.editWithoutDrag;
          }
          if (typeof eeFunct === "function") {
            if (eeFunct.length === 2) {
              eeFunct(defaultData, function(finalizedData) {
                if (finalizedData === null || finalizedData === void 0 || _this6.inMode !== "editEdge") {
                  _this6.body.edges[defaultData.id].updateEdgeType();
                  _this6.body.emitter.emit("_redraw");
                  _this6.showManipulatorToolbar();
                } else {
                  _this6.body.data.edges.getDataSet().update(finalizedData);
                  _this6.selectionHandler.unselectAll();
                  _this6.showManipulatorToolbar();
                }
              });
            } else {
              throw new Error("The function for edit does not support two arguments (data, callback)");
            }
          } else {
            this.body.data.edges.getDataSet().update(defaultData);
            this.selectionHandler.unselectAll();
            this.showManipulatorToolbar();
          }
        }
      }]);
      return ManipulationSystem2;
    }();
    css_248z$4 = `div.vis-configuration {
    position:relative;
    display:block;
    float:left;
    font-size:12px;
}

div.vis-configuration-wrapper {
    display:block;
    width:700px;
}

div.vis-configuration-wrapper::after {
  clear: both;
  content: "";
  display: block;
}

div.vis-configuration.vis-config-option-container{
    display:block;
    width:495px;
    background-color: #ffffff;
    border:2px solid #f7f8fa;
    border-radius:4px;
    margin-top:20px;
    left:10px;
    padding-left:5px;
}

div.vis-configuration.vis-config-button{
    display:block;
    width:495px;
    height:25px;
    vertical-align: middle;
    line-height:25px;
    background-color: #f7f8fa;
    border:2px solid #ceced0;
    border-radius:4px;
    margin-top:20px;
    left:10px;
    padding-left:5px;
    cursor: pointer;
    margin-bottom:30px;
}

div.vis-configuration.vis-config-button.hover{
    background-color: #4588e6;
    border:2px solid #214373;
    color:#ffffff;
}

div.vis-configuration.vis-config-item{
    display:block;
    float:left;
    width:495px;
    height:25px;
    vertical-align: middle;
    line-height:25px;
}


div.vis-configuration.vis-config-item.vis-config-s2{
    left:10px;
    background-color: #f7f8fa;
    padding-left:5px;
    border-radius:3px;
}
div.vis-configuration.vis-config-item.vis-config-s3{
    left:20px;
    background-color: #e4e9f0;
    padding-left:5px;
    border-radius:3px;
}
div.vis-configuration.vis-config-item.vis-config-s4{
    left:30px;
    background-color: #cfd8e6;
    padding-left:5px;
    border-radius:3px;
}

div.vis-configuration.vis-config-header{
    font-size:18px;
    font-weight: bold;
}

div.vis-configuration.vis-config-label{
    width:120px;
    height:25px;
    line-height: 25px;
}

div.vis-configuration.vis-config-label.vis-config-s3{
    width:110px;
}
div.vis-configuration.vis-config-label.vis-config-s4{
    width:100px;
}

div.vis-configuration.vis-config-colorBlock{
    top:1px;
    width:30px;
    height:19px;
    border:1px solid #444444;
    border-radius:2px;
    padding:0px;
    margin:0px;
    cursor:pointer;
}

input.vis-configuration.vis-config-checkbox {
    left:-5px;
}


input.vis-configuration.vis-config-rangeinput{
    position:relative;
    top:-5px;
    width:60px;
    /*height:13px;*/
    padding:1px;
    margin:0;
    pointer-events:none;
}

input.vis-configuration.vis-config-range{
    /*removes default webkit styles*/
    -webkit-appearance: none;

    /*fix for FF unable to apply focus style bug */
    border: 0px solid white;
    background-color:rgba(0,0,0,0);

    /*required for proper track sizing in FF*/
    width: 300px;
    height:20px;
}
input.vis-configuration.vis-config-range::-webkit-slider-runnable-track {
    width: 300px;
    height: 5px;
    background: #dedede; /* Old browsers */
    background: -moz-linear-gradient(top,  #dedede 0%, #c8c8c8 99%); /* FF3.6+ */
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#dedede), color-stop(99%,#c8c8c8)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top,  #dedede 0%,#c8c8c8 99%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #dedede 0%,#c8c8c8 99%); /* IE10+ */
    background: linear-gradient(to bottom,  #dedede 0%,#c8c8c8 99%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */

    border: 1px solid #999999;
    box-shadow: #aaaaaa 0px 0px 3px 0px;
    border-radius: 3px;
}
input.vis-configuration.vis-config-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    border: 1px solid #14334b;
    height: 17px;
    width: 17px;
    border-radius: 50%;
    background: #3876c2; /* Old browsers */
    background: -moz-linear-gradient(top,  #3876c2 0%, #385380 100%); /* FF3.6+ */
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#3876c2), color-stop(100%,#385380)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top,  #3876c2 0%,#385380 100%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #3876c2 0%,#385380 100%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #3876c2 0%,#385380 100%); /* IE10+ */
    background: linear-gradient(to bottom,  #3876c2 0%,#385380 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3876c2', endColorstr='#385380',GradientType=0 ); /* IE6-9 */
    box-shadow: #111927 0px 0px 1px 0px;
    margin-top: -7px;
}
input.vis-configuration.vis-config-range:focus {
    outline: none;
}
input.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track {
    background: #9d9d9d; /* Old browsers */
    background: -moz-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* FF3.6+ */
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#9d9d9d), color-stop(99%,#c8c8c8)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top,  #9d9d9d 0%,#c8c8c8 99%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #9d9d9d 0%,#c8c8c8 99%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #9d9d9d 0%,#c8c8c8 99%); /* IE10+ */
    background: linear-gradient(to bottom,  #9d9d9d 0%,#c8c8c8 99%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9d9d9d', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */
}

input.vis-configuration.vis-config-range::-moz-range-track {
    width: 300px;
    height: 10px;
    background: #dedede; /* Old browsers */
    background: -moz-linear-gradient(top,  #dedede 0%, #c8c8c8 99%); /* FF3.6+ */
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#dedede), color-stop(99%,#c8c8c8)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top,  #dedede 0%,#c8c8c8 99%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #dedede 0%,#c8c8c8 99%); /* IE10+ */
    background: linear-gradient(to bottom,  #dedede 0%,#c8c8c8 99%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */

    border: 1px solid #999999;
    box-shadow: #aaaaaa 0px 0px 3px 0px;
    border-radius: 3px;
}
input.vis-configuration.vis-config-range::-moz-range-thumb {
    border: none;
    height: 16px;
    width: 16px;

    border-radius: 50%;
    background:  #385380;
}

/*hide the outline behind the border*/
input.vis-configuration.vis-config-range:-moz-focusring{
    outline: 1px solid white;
    outline-offset: -1px;
}

input.vis-configuration.vis-config-range::-ms-track {
    width: 300px;
    height: 5px;

    /*remove bg colour from the track, we'll use ms-fill-lower and ms-fill-upper instead */
    background: transparent;

    /*leave room for the larger thumb to overflow with a transparent border */
    border-color: transparent;
    border-width: 6px 0;

    /*remove default tick marks*/
    color: transparent;
}
input.vis-configuration.vis-config-range::-ms-fill-lower {
    background: #777;
    border-radius: 10px;
}
input.vis-configuration.vis-config-range::-ms-fill-upper {
    background: #ddd;
    border-radius: 10px;
}
input.vis-configuration.vis-config-range::-ms-thumb {
    border: none;
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background:  #385380;
}
input.vis-configuration.vis-config-range:focus::-ms-fill-lower {
    background: #888;
}
input.vis-configuration.vis-config-range:focus::-ms-fill-upper {
    background: #ccc;
}

.vis-configuration-popup {
    position: absolute;
    background: rgba(57, 76, 89, 0.85);
    border: 2px solid #f2faff;
    line-height:30px;
    height:30px;
    width:150px;
    text-align:center;
    color: #ffffff;
    font-size:14px;
    border-radius:4px;
    -webkit-transition: opacity 0.3s ease-in-out;
    -moz-transition: opacity 0.3s ease-in-out;
    transition: opacity 0.3s ease-in-out;
}
.vis-configuration-popup:after, .vis-configuration-popup:before {
    left: 100%;
    top: 50%;
    border: solid transparent;
    content: " ";
    height: 0;
    width: 0;
    position: absolute;
    pointer-events: none;
}

.vis-configuration-popup:after {
    border-color: rgba(136, 183, 213, 0);
    border-left-color: rgba(57, 76, 89, 0.85);
    border-width: 8px;
    margin-top: -8px;
}
.vis-configuration-popup:before {
    border-color: rgba(194, 225, 245, 0);
    border-left-color: #f2faff;
    border-width: 12px;
    margin-top: -12px;
}`;
    styleInject(css_248z$4);
    css_248z$5 = `
div.vis-color-picker {
  position:absolute;
  top: 0px;
  left: 30px;
  margin-top:-140px;
  margin-left:30px;
  width:310px;
  height:444px;
  z-index: 1;
  padding: 10px;
  border-radius:15px;
  background-color:#ffffff;
  display: none;
  box-shadow: rgba(0,0,0,0.5) 0px 0px 10px 0px;
}

div.vis-color-picker div.vis-arrow {
  position: absolute;
  top:147px;
  left:5px;
}

div.vis-color-picker div.vis-arrow::after,
div.vis-color-picker div.vis-arrow::before {
  right: 100%;
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none;
}

div.vis-color-picker div.vis-arrow:after {
  border-color: rgba(255, 255, 255, 0);
  border-right-color: #ffffff;
  border-width: 30px;
  margin-top: -30px;
}

div.vis-color-picker div.vis-color {
  position:absolute;
  width: 289px;
  height: 289px;
  cursor: pointer;
}



div.vis-color-picker div.vis-brightness {
  position: absolute;
  top:313px;
}

div.vis-color-picker div.vis-opacity {
  position:absolute;
  top:350px;
}

div.vis-color-picker div.vis-selector {
  position:absolute;
  top:137px;
  left:137px;
  width:15px;
  height:15px;
  border-radius:15px;
  border:1px solid #ffffff;
  background: #4c4c4c; /* Old browsers */
  background: -moz-linear-gradient(top,  #4c4c4c 0%, #595959 12%, #666666 25%, #474747 39%, #2c2c2c 50%, #000000 51%, #111111 60%, #2b2b2b 76%, #1c1c1c 91%, #131313 100%); /* FF3.6+ */
  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#4c4c4c), color-stop(12%,#595959), color-stop(25%,#666666), color-stop(39%,#474747), color-stop(50%,#2c2c2c), color-stop(51%,#000000), color-stop(60%,#111111), color-stop(76%,#2b2b2b), color-stop(91%,#1c1c1c), color-stop(100%,#131313)); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(top,  #4c4c4c 0%,#595959 12%,#666666 25%,#474747 39%,#2c2c2c 50%,#000000 51%,#111111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313 100%); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(top,  #4c4c4c 0%,#595959 12%,#666666 25%,#474747 39%,#2c2c2c 50%,#000000 51%,#111111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313 100%); /* Opera 11.10+ */
  background: -ms-linear-gradient(top,  #4c4c4c 0%,#595959 12%,#666666 25%,#474747 39%,#2c2c2c 50%,#000000 51%,#111111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313 100%); /* IE10+ */
  background: linear-gradient(to bottom,  #4c4c4c 0%,#595959 12%,#666666 25%,#474747 39%,#2c2c2c 50%,#000000 51%,#111111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313 100%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c4c4c', endColorstr='#131313',GradientType=0 ); /* IE6-9 */
}



div.vis-color-picker div.vis-new-color {
  position:absolute;
  width:140px;
  height:20px;
  border:1px solid rgba(0,0,0,0.1);
  border-radius:5px;
  top:380px;
  left:159px;
  text-align:right;
  padding-right:2px;
  font-size:10px;
  color:rgba(0,0,0,0.4);
  vertical-align:middle;
  line-height:20px;

}

div.vis-color-picker div.vis-initial-color {
  position:absolute;
  width:140px;
  height:20px;
  border:1px solid rgba(0,0,0,0.1);
  border-radius:5px;
  top:380px;
  left:10px;
  text-align:left;
  padding-left:2px;
  font-size:10px;
  color:rgba(0,0,0,0.4);
  vertical-align:middle;
  line-height:20px;
}

div.vis-color-picker div.vis-label {
  position:absolute;
  width:300px;
  left:10px;
}

div.vis-color-picker div.vis-label.vis-brightness {
  top:300px;
}

div.vis-color-picker div.vis-label.vis-opacity {
  top:338px;
}

div.vis-color-picker div.vis-button {
  position:absolute;
  width:68px;
  height:25px;
  border-radius:10px;
  vertical-align: middle;
  text-align:center;
  line-height: 25px;
  top:410px;
  border:2px solid #d9d9d9;
  background-color: #f7f7f7;
  cursor:pointer;
}

div.vis-color-picker div.vis-button.vis-cancel {
  /*border:2px solid #ff4e33;*/
  /*background-color: #ff7761;*/
  left:5px;
}
div.vis-color-picker div.vis-button.vis-load {
  /*border:2px solid #a153e6;*/
  /*background-color: #cb8dff;*/
  left:82px;
}
div.vis-color-picker div.vis-button.vis-apply {
  /*border:2px solid #4588e6;*/
  /*background-color: #82b6ff;*/
  left:159px;
}
div.vis-color-picker div.vis-button.vis-save {
  /*border:2px solid #45e655;*/
  /*background-color: #6dff7c;*/
  left:236px;
}


div.vis-color-picker input.vis-range {
  width: 290px;
  height:20px;
}

/* TODO: is this redundant?
div.vis-color-picker input.vis-range-brightness {
  width: 289px !important;
}


div.vis-color-picker input.vis-saturation-range {
  width: 289px !important;
}*/`;
    styleInject(css_248z$5);
    htmlColors = {
      black: "#000000",
      navy: "#000080",
      darkblue: "#00008B",
      mediumblue: "#0000CD",
      blue: "#0000FF",
      darkgreen: "#006400",
      green: "#008000",
      teal: "#008080",
      darkcyan: "#008B8B",
      deepskyblue: "#00BFFF",
      darkturquoise: "#00CED1",
      mediumspringgreen: "#00FA9A",
      lime: "#00FF00",
      springgreen: "#00FF7F",
      aqua: "#00FFFF",
      cyan: "#00FFFF",
      midnightblue: "#191970",
      dodgerblue: "#1E90FF",
      lightseagreen: "#20B2AA",
      forestgreen: "#228B22",
      seagreen: "#2E8B57",
      darkslategray: "#2F4F4F",
      limegreen: "#32CD32",
      mediumseagreen: "#3CB371",
      turquoise: "#40E0D0",
      royalblue: "#4169E1",
      steelblue: "#4682B4",
      darkslateblue: "#483D8B",
      mediumturquoise: "#48D1CC",
      indigo: "#4B0082",
      darkolivegreen: "#556B2F",
      cadetblue: "#5F9EA0",
      cornflowerblue: "#6495ED",
      mediumaquamarine: "#66CDAA",
      dimgray: "#696969",
      slateblue: "#6A5ACD",
      olivedrab: "#6B8E23",
      slategray: "#708090",
      lightslategray: "#778899",
      mediumslateblue: "#7B68EE",
      lawngreen: "#7CFC00",
      chartreuse: "#7FFF00",
      aquamarine: "#7FFFD4",
      maroon: "#800000",
      purple: "#800080",
      olive: "#808000",
      gray: "#808080",
      skyblue: "#87CEEB",
      lightskyblue: "#87CEFA",
      blueviolet: "#8A2BE2",
      darkred: "#8B0000",
      darkmagenta: "#8B008B",
      saddlebrown: "#8B4513",
      darkseagreen: "#8FBC8F",
      lightgreen: "#90EE90",
      mediumpurple: "#9370D8",
      darkviolet: "#9400D3",
      palegreen: "#98FB98",
      darkorchid: "#9932CC",
      yellowgreen: "#9ACD32",
      sienna: "#A0522D",
      brown: "#A52A2A",
      darkgray: "#A9A9A9",
      lightblue: "#ADD8E6",
      greenyellow: "#ADFF2F",
      paleturquoise: "#AFEEEE",
      lightsteelblue: "#B0C4DE",
      powderblue: "#B0E0E6",
      firebrick: "#B22222",
      darkgoldenrod: "#B8860B",
      mediumorchid: "#BA55D3",
      rosybrown: "#BC8F8F",
      darkkhaki: "#BDB76B",
      silver: "#C0C0C0",
      mediumvioletred: "#C71585",
      indianred: "#CD5C5C",
      peru: "#CD853F",
      chocolate: "#D2691E",
      tan: "#D2B48C",
      lightgrey: "#D3D3D3",
      palevioletred: "#D87093",
      thistle: "#D8BFD8",
      orchid: "#DA70D6",
      goldenrod: "#DAA520",
      crimson: "#DC143C",
      gainsboro: "#DCDCDC",
      plum: "#DDA0DD",
      burlywood: "#DEB887",
      lightcyan: "#E0FFFF",
      lavender: "#E6E6FA",
      darksalmon: "#E9967A",
      violet: "#EE82EE",
      palegoldenrod: "#EEE8AA",
      lightcoral: "#F08080",
      khaki: "#F0E68C",
      aliceblue: "#F0F8FF",
      honeydew: "#F0FFF0",
      azure: "#F0FFFF",
      sandybrown: "#F4A460",
      wheat: "#F5DEB3",
      beige: "#F5F5DC",
      whitesmoke: "#F5F5F5",
      mintcream: "#F5FFFA",
      ghostwhite: "#F8F8FF",
      salmon: "#FA8072",
      antiquewhite: "#FAEBD7",
      linen: "#FAF0E6",
      lightgoldenrodyellow: "#FAFAD2",
      oldlace: "#FDF5E6",
      red: "#FF0000",
      fuchsia: "#FF00FF",
      magenta: "#FF00FF",
      deeppink: "#FF1493",
      orangered: "#FF4500",
      tomato: "#FF6347",
      hotpink: "#FF69B4",
      coral: "#FF7F50",
      darkorange: "#FF8C00",
      lightsalmon: "#FFA07A",
      orange: "#FFA500",
      lightpink: "#FFB6C1",
      pink: "#FFC0CB",
      gold: "#FFD700",
      peachpuff: "#FFDAB9",
      navajowhite: "#FFDEAD",
      moccasin: "#FFE4B5",
      bisque: "#FFE4C4",
      mistyrose: "#FFE4E1",
      blanchedalmond: "#FFEBCD",
      papayawhip: "#FFEFD5",
      lavenderblush: "#FFF0F5",
      seashell: "#FFF5EE",
      cornsilk: "#FFF8DC",
      lemonchiffon: "#FFFACD",
      floralwhite: "#FFFAF0",
      snow: "#FFFAFA",
      yellow: "#FFFF00",
      lightyellow: "#FFFFE0",
      ivory: "#FFFFF0",
      white: "#FFFFFF"
    };
    ColorPicker = function() {
      function ColorPicker2() {
        var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        classCallCheck(this, ColorPicker2);
        this.pixelRatio = pixelRatio;
        this.generated = false;
        this.centerCoordinates = {
          x: 289 / 2,
          y: 289 / 2
        };
        this.r = 289 * 0.49;
        this.color = {
          r: 255,
          g: 255,
          b: 255,
          a: 1
        };
        this.hueCircle = void 0;
        this.initialColor = {
          r: 255,
          g: 255,
          b: 255,
          a: 1
        };
        this.previousColor = void 0;
        this.applied = false;
        this.updateCallback = function() {
        };
        this.closeCallback = function() {
        };
        this._create();
      }
      createClass(ColorPicker2, [{
        key: "insertTo",
        value: function insertTo(container) {
          if (this.hammer !== void 0) {
            this.hammer.destroy();
            this.hammer = void 0;
          }
          this.container = container;
          this.container.appendChild(this.frame);
          this._bindHammer();
          this._setSize();
        }
        /**
         * the callback is executed on apply and save. Bind it to the application
         * @param {function} callback
         */
      }, {
        key: "setUpdateCallback",
        value: function setUpdateCallback(callback) {
          if (typeof callback === "function") {
            this.updateCallback = callback;
          } else {
            throw new Error("Function attempted to set as colorPicker update callback is not a function.");
          }
        }
        /**
         * the callback is executed on apply and save. Bind it to the application
         * @param {function} callback
         */
      }, {
        key: "setCloseCallback",
        value: function setCloseCallback(callback) {
          if (typeof callback === "function") {
            this.closeCallback = callback;
          } else {
            throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
          }
        }
        /**
         *
         * @param {string} color
         * @returns {String}
         * @private
         */
      }, {
        key: "_isColorString",
        value: function _isColorString(color) {
          if (typeof color === "string") {
            return htmlColors[color];
          }
        }
        /**
         * Set the color of the colorPicker
         * Supported formats:
         * 'red'                   --> HTML color string
         * '#ffffff'               --> hex string
         * 'rgb(255,255,255)'      --> rgb string
         * 'rgba(255,255,255,1.0)' --> rgba string
         * {r:255,g:255,b:255}     --> rgb object
         * {r:255,g:255,b:255,a:1.0} --> rgba object
         * @param {string|Object} color
         * @param {boolean} [setInitial=true]
         */
      }, {
        key: "setColor",
        value: function setColor(color) {
          var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (color === "none") {
            return;
          }
          var rgba;
          var htmlColor = this._isColorString(color);
          if (htmlColor !== void 0) {
            color = htmlColor;
          }
          if (isString(color) === true) {
            if (isValidRGB(color) === true) {
              var rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
              rgba = {
                r: rgbaArray[0],
                g: rgbaArray[1],
                b: rgbaArray[2],
                a: 1
              };
            } else if (isValidRGBA(color) === true) {
              var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");
              rgba = {
                r: _rgbaArray[0],
                g: _rgbaArray[1],
                b: _rgbaArray[2],
                a: _rgbaArray[3]
              };
            } else if (isValidHex(color) === true) {
              var rgbObj = hexToRGB(color);
              rgba = {
                r: rgbObj.r,
                g: rgbObj.g,
                b: rgbObj.b,
                a: 1
              };
            }
          } else {
            if (color instanceof Object) {
              if (color.r !== void 0 && color.g !== void 0 && color.b !== void 0) {
                var alpha = color.a !== void 0 ? color.a : "1.0";
                rgba = {
                  r: color.r,
                  g: color.g,
                  b: color.b,
                  a: alpha
                };
              }
            }
          }
          if (rgba === void 0) {
            throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + stringify$2(color));
          } else {
            this._setColor(rgba, setInitial);
          }
        }
        /**
         * this shows the color picker.
         * The hue circle is constructed once and stored.
         */
      }, {
        key: "show",
        value: function show() {
          if (this.closeCallback !== void 0) {
            this.closeCallback();
            this.closeCallback = void 0;
          }
          this.applied = false;
          this.frame.style.display = "block";
          this._generateHueCircle();
        }
        // ------------------------------------------ PRIVATE ----------------------------- //
        /**
         * Hide the picker. Is called by the cancel button.
         * Optional boolean to store the previous color for easy access later on.
         * @param {boolean} [storePrevious=true]
         * @private
         */
      }, {
        key: "_hide",
        value: function _hide() {
          var _this = this;
          var storePrevious = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (storePrevious === true) {
            this.previousColor = assign$2({}, this.color);
          }
          if (this.applied === true) {
            this.updateCallback(this.initialColor);
          }
          this.frame.style.display = "none";
          setTimeout$2(function() {
            if (_this.closeCallback !== void 0) {
              _this.closeCallback();
              _this.closeCallback = void 0;
            }
          }, 0);
        }
        /**
         * bound to the save button. Saves and hides.
         * @private
         */
      }, {
        key: "_save",
        value: function _save() {
          this.updateCallback(this.color);
          this.applied = false;
          this._hide();
        }
        /**
         * Bound to apply button. Saves but does not close. Is undone by the cancel button.
         * @private
         */
      }, {
        key: "_apply",
        value: function _apply() {
          this.applied = true;
          this.updateCallback(this.color);
          this._updatePicker(this.color);
        }
        /**
         * load the color from the previous session.
         * @private
         */
      }, {
        key: "_loadLast",
        value: function _loadLast() {
          if (this.previousColor !== void 0) {
            this.setColor(this.previousColor, false);
          } else {
            alert("There is no last color to load...");
          }
        }
        /**
         * set the color, place the picker
         * @param {Object} rgba
         * @param {boolean} [setInitial=true]
         * @private
         */
      }, {
        key: "_setColor",
        value: function _setColor(rgba) {
          var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (setInitial === true) {
            this.initialColor = assign$2({}, rgba);
          }
          this.color = rgba;
          var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
          var angleConvert = 2 * Math.PI;
          var radius = this.r * hsv.s;
          var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
          var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
          this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
          this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";
          this._updatePicker(rgba);
        }
        /**
         * bound to opacity control
         * @param {number} value
         * @private
         */
      }, {
        key: "_setOpacity",
        value: function _setOpacity(value) {
          this.color.a = value / 100;
          this._updatePicker(this.color);
        }
        /**
         * bound to brightness control
         * @param {number} value
         * @private
         */
      }, {
        key: "_setBrightness",
        value: function _setBrightness(value) {
          var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
          hsv.v = value / 100;
          var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
          rgba["a"] = this.color.a;
          this.color = rgba;
          this._updatePicker();
        }
        /**
         * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
         * @param {Object} rgba
         * @private
         */
      }, {
        key: "_updatePicker",
        value: function _updatePicker() {
          var rgba = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.color;
          var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
          var ctx = this.colorPickerCanvas.getContext("2d");
          if (this.pixelRation === void 0) {
            this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
          }
          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
          var w = this.colorPickerCanvas.clientWidth;
          var h = this.colorPickerCanvas.clientHeight;
          ctx.clearRect(0, 0, w, h);
          ctx.putImageData(this.hueCircle, 0, 0);
          ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
          ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
          fill$2(ctx).call(ctx);
          this.brightnessRange.value = 100 * hsv.v;
          this.opacityRange.value = 100 * rgba.a;
          this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
          this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
        }
        /**
         * used by create to set the size of the canvas.
         * @private
         */
      }, {
        key: "_setSize",
        value: function _setSize() {
          this.colorPickerCanvas.style.width = "100%";
          this.colorPickerCanvas.style.height = "100%";
          this.colorPickerCanvas.width = 289 * this.pixelRatio;
          this.colorPickerCanvas.height = 289 * this.pixelRatio;
        }
        /**
         * create all dom elements
         * TODO: cleanup, lots of similar dom elements
         * @private
         */
      }, {
        key: "_create",
        value: function _create() {
          var _context, _context2, _context3, _context4;
          this.frame = document.createElement("div");
          this.frame.className = "vis-color-picker";
          this.colorPickerDiv = document.createElement("div");
          this.colorPickerSelector = document.createElement("div");
          this.colorPickerSelector.className = "vis-selector";
          this.colorPickerDiv.appendChild(this.colorPickerSelector);
          this.colorPickerCanvas = document.createElement("canvas");
          this.colorPickerDiv.appendChild(this.colorPickerCanvas);
          if (!this.colorPickerCanvas.getContext) {
            var noCanvas = document.createElement("DIV");
            noCanvas.style.color = "red";
            noCanvas.style.fontWeight = "bold";
            noCanvas.style.padding = "10px";
            noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
            this.colorPickerCanvas.appendChild(noCanvas);
          } else {
            var ctx = this.colorPickerCanvas.getContext("2d");
            this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
            this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
          }
          this.colorPickerDiv.className = "vis-color";
          this.opacityDiv = document.createElement("div");
          this.opacityDiv.className = "vis-opacity";
          this.brightnessDiv = document.createElement("div");
          this.brightnessDiv.className = "vis-brightness";
          this.arrowDiv = document.createElement("div");
          this.arrowDiv.className = "vis-arrow";
          this.opacityRange = document.createElement("input");
          try {
            this.opacityRange.type = "range";
            this.opacityRange.min = "0";
            this.opacityRange.max = "100";
          } catch (err) {
          }
          this.opacityRange.value = "100";
          this.opacityRange.className = "vis-range";
          this.brightnessRange = document.createElement("input");
          try {
            this.brightnessRange.type = "range";
            this.brightnessRange.min = "0";
            this.brightnessRange.max = "100";
          } catch (err) {
          }
          this.brightnessRange.value = "100";
          this.brightnessRange.className = "vis-range";
          this.opacityDiv.appendChild(this.opacityRange);
          this.brightnessDiv.appendChild(this.brightnessRange);
          var me = this;
          this.opacityRange.onchange = function() {
            me._setOpacity(this.value);
          };
          this.opacityRange.oninput = function() {
            me._setOpacity(this.value);
          };
          this.brightnessRange.onchange = function() {
            me._setBrightness(this.value);
          };
          this.brightnessRange.oninput = function() {
            me._setBrightness(this.value);
          };
          this.brightnessLabel = document.createElement("div");
          this.brightnessLabel.className = "vis-label vis-brightness";
          this.brightnessLabel.innerHTML = "brightness:";
          this.opacityLabel = document.createElement("div");
          this.opacityLabel.className = "vis-label vis-opacity";
          this.opacityLabel.innerHTML = "opacity:";
          this.newColorDiv = document.createElement("div");
          this.newColorDiv.className = "vis-new-color";
          this.newColorDiv.innerHTML = "new";
          this.initialColorDiv = document.createElement("div");
          this.initialColorDiv.className = "vis-initial-color";
          this.initialColorDiv.innerHTML = "initial";
          this.cancelButton = document.createElement("div");
          this.cancelButton.className = "vis-button vis-cancel";
          this.cancelButton.innerHTML = "cancel";
          this.cancelButton.onclick = bind$2(_context = this._hide).call(_context, this, false);
          this.applyButton = document.createElement("div");
          this.applyButton.className = "vis-button vis-apply";
          this.applyButton.innerHTML = "apply";
          this.applyButton.onclick = bind$2(_context2 = this._apply).call(_context2, this);
          this.saveButton = document.createElement("div");
          this.saveButton.className = "vis-button vis-save";
          this.saveButton.innerHTML = "save";
          this.saveButton.onclick = bind$2(_context3 = this._save).call(_context3, this);
          this.loadButton = document.createElement("div");
          this.loadButton.className = "vis-button vis-load";
          this.loadButton.innerHTML = "load last";
          this.loadButton.onclick = bind$2(_context4 = this._loadLast).call(_context4, this);
          this.frame.appendChild(this.colorPickerDiv);
          this.frame.appendChild(this.arrowDiv);
          this.frame.appendChild(this.brightnessLabel);
          this.frame.appendChild(this.brightnessDiv);
          this.frame.appendChild(this.opacityLabel);
          this.frame.appendChild(this.opacityDiv);
          this.frame.appendChild(this.newColorDiv);
          this.frame.appendChild(this.initialColorDiv);
          this.frame.appendChild(this.cancelButton);
          this.frame.appendChild(this.applyButton);
          this.frame.appendChild(this.saveButton);
          this.frame.appendChild(this.loadButton);
        }
        /**
         * bind hammer to the color picker
         * @private
         */
      }, {
        key: "_bindHammer",
        value: function _bindHammer() {
          var _this2 = this;
          this.drag = {};
          this.pinch = {};
          this.hammer = new hammer(this.colorPickerCanvas);
          this.hammer.get("pinch").set({
            enable: true
          });
          onTouch(this.hammer, function(event) {
            _this2._moveSelector(event);
          });
          this.hammer.on("tap", function(event) {
            _this2._moveSelector(event);
          });
          this.hammer.on("panstart", function(event) {
            _this2._moveSelector(event);
          });
          this.hammer.on("panmove", function(event) {
            _this2._moveSelector(event);
          });
          this.hammer.on("panend", function(event) {
            _this2._moveSelector(event);
          });
        }
        /**
         * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
         * @private
         */
      }, {
        key: "_generateHueCircle",
        value: function _generateHueCircle() {
          if (this.generated === false) {
            var ctx = this.colorPickerCanvas.getContext("2d");
            if (this.pixelRation === void 0) {
              this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
            }
            ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
            var w = this.colorPickerCanvas.clientWidth;
            var h = this.colorPickerCanvas.clientHeight;
            ctx.clearRect(0, 0, w, h);
            var x, y, hue, sat;
            this.centerCoordinates = {
              x: w * 0.5,
              y: h * 0.5
            };
            this.r = 0.49 * w;
            var angleConvert = 2 * Math.PI / 360;
            var hfac = 1 / 360;
            var sfac = 1 / this.r;
            var rgb;
            for (hue = 0; hue < 360; hue++) {
              for (sat = 0; sat < this.r; sat++) {
                x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
                y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
                rgb = HSVToRGB(hue * hfac, sat * sfac, 1);
                ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
              }
            }
            ctx.strokeStyle = "rgba(0,0,0,1)";
            ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
            ctx.stroke();
            this.hueCircle = ctx.getImageData(0, 0, w, h);
          }
          this.generated = true;
        }
        /**
         * move the selector. This is called by hammer functions.
         *
         * @param {Event}  event   The event
         * @private
         */
      }, {
        key: "_moveSelector",
        value: function _moveSelector(event) {
          var rect = this.colorPickerDiv.getBoundingClientRect();
          var left = event.center.x - rect.left;
          var top = event.center.y - rect.top;
          var centerY = 0.5 * this.colorPickerDiv.clientHeight;
          var centerX = 0.5 * this.colorPickerDiv.clientWidth;
          var x = left - centerX;
          var y = top - centerY;
          var angle = Math.atan2(x, y);
          var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
          var newTop = Math.cos(angle) * radius + centerY;
          var newLeft = Math.sin(angle) * radius + centerX;
          this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
          this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px";
          var h = angle / (2 * Math.PI);
          h = h < 0 ? h + 1 : h;
          var s = radius / this.r;
          var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
          hsv.h = h;
          hsv.s = s;
          var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
          rgba["a"] = this.color.a;
          this.color = rgba;
          this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
          this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
        }
      }]);
      return ColorPicker2;
    }();
    Configurator = function() {
      function Configurator2(parentModule, defaultContainer, configureOptions2) {
        var pixelRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        classCallCheck(this, Configurator2);
        this.parent = parentModule;
        this.changedOptions = [];
        this.container = defaultContainer;
        this.allowCreation = false;
        this.options = {};
        this.initialized = false;
        this.popupCounter = 0;
        this.defaultOptions = {
          enabled: false,
          filter: true,
          container: void 0,
          showButton: true
        };
        assign$2(this.options, this.defaultOptions);
        this.configureOptions = configureOptions2;
        this.moduleOptions = {};
        this.domElements = [];
        this.popupDiv = {};
        this.popupLimit = 5;
        this.popupHistory = {};
        this.colorPicker = new ColorPicker(pixelRatio);
        this.wrapper = void 0;
      }
      createClass(Configurator2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2 !== void 0) {
            this.popupHistory = {};
            this._removePopup();
            var enabled = true;
            if (typeof options2 === "string") {
              this.options.filter = options2;
            } else if (options2 instanceof Array) {
              this.options.filter = options2.join();
            } else if (_typeof_1(options2) === "object") {
              if (options2 == null) {
                throw new TypeError("options cannot be null");
              }
              if (options2.container !== void 0) {
                this.options.container = options2.container;
              }
              if (filter$2(options2) !== void 0) {
                this.options.filter = filter$2(options2);
              }
              if (options2.showButton !== void 0) {
                this.options.showButton = options2.showButton;
              }
              if (options2.enabled !== void 0) {
                enabled = options2.enabled;
              }
            } else if (typeof options2 === "boolean") {
              this.options.filter = true;
              enabled = options2;
            } else if (typeof options2 === "function") {
              this.options.filter = options2;
              enabled = true;
            }
            if (filter$2(this.options) === false) {
              enabled = false;
            }
            this.options.enabled = enabled;
          }
          this._clean();
        }
        /**
         *
         * @param {Object} moduleOptions
         */
      }, {
        key: "setModuleOptions",
        value: function setModuleOptions(moduleOptions) {
          this.moduleOptions = moduleOptions;
          if (this.options.enabled === true) {
            this._clean();
            if (this.options.container !== void 0) {
              this.container = this.options.container;
            }
            this._create();
          }
        }
        /**
         * Create all DOM elements
         * @private
         */
      }, {
        key: "_create",
        value: function _create() {
          this._clean();
          this.changedOptions = [];
          var filter3 = filter$2(this.options);
          var counter = 0;
          var show = false;
          for (var option in this.configureOptions) {
            if (Object.prototype.hasOwnProperty.call(this.configureOptions, option)) {
              this.allowCreation = false;
              show = false;
              if (typeof filter3 === "function") {
                show = filter3(option, []);
                show = show || this._handleObject(this.configureOptions[option], [option], true);
              } else if (filter3 === true || indexOf$3(filter3).call(filter3, option) !== -1) {
                show = true;
              }
              if (show !== false) {
                this.allowCreation = true;
                if (counter > 0) {
                  this._makeItem([]);
                }
                this._makeHeader(option);
                this._handleObject(this.configureOptions[option], [option]);
              }
              counter++;
            }
          }
          this._makeButton();
          this._push();
        }
        /**
         * draw all DOM elements on the screen
         * @private
         */
      }, {
        key: "_push",
        value: function _push() {
          this.wrapper = document.createElement("div");
          this.wrapper.className = "vis-configuration-wrapper";
          this.container.appendChild(this.wrapper);
          for (var i = 0; i < this.domElements.length; i++) {
            this.wrapper.appendChild(this.domElements[i]);
          }
          this._showPopupIfNeeded();
        }
        /**
         * delete all DOM elements
         * @private
         */
      }, {
        key: "_clean",
        value: function _clean() {
          for (var i = 0; i < this.domElements.length; i++) {
            this.wrapper.removeChild(this.domElements[i]);
          }
          if (this.wrapper !== void 0) {
            this.container.removeChild(this.wrapper);
            this.wrapper = void 0;
          }
          this.domElements = [];
          this._removePopup();
        }
        /**
         * get the value from the actualOptions if it exists
         * @param {array} path    | where to look for the actual option
         * @returns {*}
         * @private
         */
      }, {
        key: "_getValue",
        value: function _getValue(path2) {
          var base = this.moduleOptions;
          for (var i = 0; i < path2.length; i++) {
            if (base[path2[i]] !== void 0) {
              base = base[path2[i]];
            } else {
              base = void 0;
              break;
            }
          }
          return base;
        }
        /**
         * all option elements are wrapped in an item
         * @param {Array} path    | where to look for the actual option
         * @param {Array.<Element>} domElements
         * @returns {number}
         * @private
         */
      }, {
        key: "_makeItem",
        value: function _makeItem(path2) {
          if (this.allowCreation === true) {
            var item = document.createElement("div");
            item.className = "vis-configuration vis-config-item vis-config-s" + path2.length;
            for (var _len = arguments.length, domElements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              domElements[_key - 1] = arguments[_key];
            }
            forEach$2(domElements).call(domElements, function(element) {
              item.appendChild(element);
            });
            this.domElements.push(item);
            return this.domElements.length;
          }
          return 0;
        }
        /**
         * header for major subjects
         * @param {string} name
         * @private
         */
      }, {
        key: "_makeHeader",
        value: function _makeHeader(name) {
          var div = document.createElement("div");
          div.className = "vis-configuration vis-config-header";
          div.innerHTML = name;
          this._makeItem([], div);
        }
        /**
         * make a label, if it is an object label, it gets different styling.
         * @param {string} name
         * @param {array} path    | where to look for the actual option
         * @param {string} objectLabel
         * @returns {HTMLElement}
         * @private
         */
      }, {
        key: "_makeLabel",
        value: function _makeLabel(name, path2) {
          var objectLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var div = document.createElement("div");
          div.className = "vis-configuration vis-config-label vis-config-s" + path2.length;
          if (objectLabel === true) {
            div.innerHTML = "<i><b>" + name + ":</b></i>";
          } else {
            div.innerHTML = name + ":";
          }
          return div;
        }
        /**
         * make a dropdown list for multiple possible string optoins
         * @param {Array.<number>} arr
         * @param {number} value
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_makeDropdown",
        value: function _makeDropdown(arr, value, path2) {
          var select = document.createElement("select");
          select.className = "vis-configuration vis-config-select";
          var selectedValue = 0;
          if (value !== void 0) {
            if (indexOf$3(arr).call(arr, value) !== -1) {
              selectedValue = indexOf$3(arr).call(arr, value);
            }
          }
          for (var i = 0; i < arr.length; i++) {
            var option = document.createElement("option");
            option.value = arr[i];
            if (i === selectedValue) {
              option.selected = "selected";
            }
            option.innerHTML = arr[i];
            select.appendChild(option);
          }
          var me = this;
          select.onchange = function() {
            me._update(this.value, path2);
          };
          var label = this._makeLabel(path2[path2.length - 1], path2);
          this._makeItem(path2, label, select);
        }
        /**
         * make a range object for numeric options
         * @param {Array.<number>} arr
         * @param {number} value
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_makeRange",
        value: function _makeRange(arr, value, path2) {
          var defaultValue = arr[0];
          var min2 = arr[1];
          var max2 = arr[2];
          var step = arr[3];
          var range = document.createElement("input");
          range.className = "vis-configuration vis-config-range";
          try {
            range.type = "range";
            range.min = min2;
            range.max = max2;
          } catch (err) {
          }
          range.step = step;
          var popupString = "";
          var popupValue = 0;
          if (value !== void 0) {
            var factor = 1.2;
            if (value < 0 && value * factor < min2) {
              range.min = Math.ceil(value * factor);
              popupValue = range.min;
              popupString = "range increased";
            } else if (value / factor < min2) {
              range.min = Math.ceil(value / factor);
              popupValue = range.min;
              popupString = "range increased";
            }
            if (value * factor > max2 && max2 !== 1) {
              range.max = Math.ceil(value * factor);
              popupValue = range.max;
              popupString = "range increased";
            }
            range.value = value;
          } else {
            range.value = defaultValue;
          }
          var input = document.createElement("input");
          input.className = "vis-configuration vis-config-rangeinput";
          input.value = range.value;
          var me = this;
          range.onchange = function() {
            input.value = this.value;
            me._update(Number(this.value), path2);
          };
          range.oninput = function() {
            input.value = this.value;
          };
          var label = this._makeLabel(path2[path2.length - 1], path2);
          var itemIndex = this._makeItem(path2, label, range, input);
          if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
            this.popupHistory[itemIndex] = popupValue;
            this._setupPopup(popupString, itemIndex);
          }
        }
        /**
         * make a button object
         * @private
         */
      }, {
        key: "_makeButton",
        value: function _makeButton() {
          var _this = this;
          if (this.options.showButton === true) {
            var generateButton = document.createElement("div");
            generateButton.className = "vis-configuration vis-config-button";
            generateButton.innerHTML = "generate options";
            generateButton.onclick = function() {
              _this._printOptions();
            };
            generateButton.onmouseover = function() {
              generateButton.className = "vis-configuration vis-config-button hover";
            };
            generateButton.onmouseout = function() {
              generateButton.className = "vis-configuration vis-config-button";
            };
            this.optionsContainer = document.createElement("div");
            this.optionsContainer.className = "vis-configuration vis-config-option-container";
            this.domElements.push(this.optionsContainer);
            this.domElements.push(generateButton);
          }
        }
        /**
         * prepare the popup
         * @param {string} string
         * @param {number} index
         * @private
         */
      }, {
        key: "_setupPopup",
        value: function _setupPopup(string2, index2) {
          var _this2 = this;
          if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
            var div = document.createElement("div");
            div.id = "vis-configuration-popup";
            div.className = "vis-configuration-popup";
            div.innerHTML = string2;
            div.onclick = function() {
              _this2._removePopup();
            };
            this.popupCounter += 1;
            this.popupDiv = {
              html: div,
              index: index2
            };
          }
        }
        /**
         * remove the popup from the dom
         * @private
         */
      }, {
        key: "_removePopup",
        value: function _removePopup() {
          if (this.popupDiv.html !== void 0) {
            this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
            clearTimeout(this.popupDiv.hideTimeout);
            clearTimeout(this.popupDiv.deleteTimeout);
            this.popupDiv = {};
          }
        }
        /**
         * Show the popup if it is needed.
         * @private
         */
      }, {
        key: "_showPopupIfNeeded",
        value: function _showPopupIfNeeded() {
          var _this3 = this;
          if (this.popupDiv.html !== void 0) {
            var correspondingElement = this.domElements[this.popupDiv.index];
            var rect = correspondingElement.getBoundingClientRect();
            this.popupDiv.html.style.left = rect.left + "px";
            this.popupDiv.html.style.top = rect.top - 30 + "px";
            document.body.appendChild(this.popupDiv.html);
            this.popupDiv.hideTimeout = setTimeout$2(function() {
              _this3.popupDiv.html.style.opacity = 0;
            }, 1500);
            this.popupDiv.deleteTimeout = setTimeout$2(function() {
              _this3._removePopup();
            }, 1800);
          }
        }
        /**
         * make a checkbox for boolean options.
         * @param {number} defaultValue
         * @param {number} value
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_makeCheckbox",
        value: function _makeCheckbox(defaultValue, value, path2) {
          var checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "vis-configuration vis-config-checkbox";
          checkbox.checked = defaultValue;
          if (value !== void 0) {
            checkbox.checked = value;
            if (value !== defaultValue) {
              if (_typeof_1(defaultValue) === "object") {
                if (value !== defaultValue.enabled) {
                  this.changedOptions.push({
                    path: path2,
                    value
                  });
                }
              } else {
                this.changedOptions.push({
                  path: path2,
                  value
                });
              }
            }
          }
          var me = this;
          checkbox.onchange = function() {
            me._update(this.checked, path2);
          };
          var label = this._makeLabel(path2[path2.length - 1], path2);
          this._makeItem(path2, label, checkbox);
        }
        /**
         * make a text input field for string options.
         * @param {number} defaultValue
         * @param {number} value
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_makeTextInput",
        value: function _makeTextInput(defaultValue, value, path2) {
          var checkbox = document.createElement("input");
          checkbox.type = "text";
          checkbox.className = "vis-configuration vis-config-text";
          checkbox.value = value;
          if (value !== defaultValue) {
            this.changedOptions.push({
              path: path2,
              value
            });
          }
          var me = this;
          checkbox.onchange = function() {
            me._update(this.value, path2);
          };
          var label = this._makeLabel(path2[path2.length - 1], path2);
          this._makeItem(path2, label, checkbox);
        }
        /**
         * make a color field with a color picker for color fields
         * @param {Array.<number>} arr
         * @param {number} value
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_makeColorField",
        value: function _makeColorField(arr, value, path2) {
          var _this4 = this;
          var defaultColor = arr[1];
          var div = document.createElement("div");
          value = value === void 0 ? defaultColor : value;
          if (value !== "none") {
            div.className = "vis-configuration vis-config-colorBlock";
            div.style.backgroundColor = value;
          } else {
            div.className = "vis-configuration vis-config-colorBlock none";
          }
          value = value === void 0 ? defaultColor : value;
          div.onclick = function() {
            _this4._showColorPicker(value, div, path2);
          };
          var label = this._makeLabel(path2[path2.length - 1], path2);
          this._makeItem(path2, label, div);
        }
        /**
         * used by the color buttons to call the color picker.
         * @param {number} value
         * @param {HTMLElement} div
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_showColorPicker",
        value: function _showColorPicker(value, div, path2) {
          var _this5 = this;
          div.onclick = function() {
          };
          this.colorPicker.insertTo(div);
          this.colorPicker.show();
          this.colorPicker.setColor(value);
          this.colorPicker.setUpdateCallback(function(color) {
            var colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
            div.style.backgroundColor = colorString;
            _this5._update(colorString, path2);
          });
          this.colorPicker.setCloseCallback(function() {
            div.onclick = function() {
              _this5._showColorPicker(value, div, path2);
            };
          });
        }
        /**
         * parse an object and draw the correct items
         * @param {Object} obj
         * @param {array} [path=[]]    | where to look for the actual option
         * @param {boolean} [checkOnly=false]
         * @returns {boolean}
         * @private
         */
      }, {
        key: "_handleObject",
        value: function _handleObject(obj) {
          var path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var checkOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var show = false;
          var filter3 = filter$2(this.options);
          var visibleInSet = false;
          for (var subObj in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, subObj)) {
              show = true;
              var item = obj[subObj];
              var newPath = copyAndExtendArray(path2, subObj);
              if (typeof filter3 === "function") {
                show = filter3(subObj, path2);
                if (show === false) {
                  if (!(item instanceof Array) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
                    this.allowCreation = false;
                    show = this._handleObject(item, newPath, true);
                    this.allowCreation = checkOnly === false;
                  }
                }
              }
              if (show !== false) {
                visibleInSet = true;
                var value = this._getValue(newPath);
                if (item instanceof Array) {
                  this._handleArray(item, value, newPath);
                } else if (typeof item === "string") {
                  this._makeTextInput(item, value, newPath);
                } else if (typeof item === "boolean") {
                  this._makeCheckbox(item, value, newPath);
                } else if (item instanceof Object) {
                  var draw = true;
                  if (indexOf$3(path2).call(path2, "physics") !== -1) {
                    if (this.moduleOptions.physics.solver !== subObj && subObj !== "wind") {
                      draw = false;
                    }
                  }
                  if (draw === true) {
                    if (item.enabled !== void 0) {
                      var enabledPath = copyAndExtendArray(newPath, "enabled");
                      var enabledValue = this._getValue(enabledPath);
                      if (enabledValue === true) {
                        var label = this._makeLabel(subObj, newPath, true);
                        this._makeItem(newPath, label);
                        visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                      } else {
                        this._makeCheckbox(item, enabledValue, newPath);
                      }
                    } else {
                      var _label = this._makeLabel(subObj, newPath, true);
                      this._makeItem(newPath, _label);
                      visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                    }
                  }
                } else {
                  console.error("dont know how to handle", item, subObj, newPath);
                }
              }
            }
          }
          return visibleInSet;
        }
        /**
         * handle the array type of option
         * @param {Array.<number>} arr
         * @param {number} value
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_handleArray",
        value: function _handleArray(arr, value, path2) {
          if (typeof arr[0] === "string" && arr[0] === "color") {
            this._makeColorField(arr, value, path2);
            if (arr[1] !== value) {
              this.changedOptions.push({
                path: path2,
                value
              });
            }
          } else if (typeof arr[0] === "string") {
            this._makeDropdown(arr, value, path2);
            if (arr[0] !== value) {
              this.changedOptions.push({
                path: path2,
                value
              });
            }
          } else if (typeof arr[0] === "number") {
            this._makeRange(arr, value, path2);
            if (arr[0] !== value) {
              this.changedOptions.push({
                path: path2,
                value: Number(value)
              });
            }
          }
        }
        /**
         * called to update the network with the new settings.
         * @param {number} value
         * @param {array} path    | where to look for the actual option
         * @private
         */
      }, {
        key: "_update",
        value: function _update(value, path2) {
          var options2 = this._constructOptions(value, path2);
          if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
            this.parent.body.emitter.emit("configChange", options2);
          }
          this.initialized = true;
          this.parent.setOptions(options2);
        }
        /**
         *
         * @param {string|Boolean} value
         * @param {Array.<string>} path
         * @param {{}} optionsObj
         * @returns {{}}
         * @private
         */
      }, {
        key: "_constructOptions",
        value: function _constructOptions(value, path2) {
          var optionsObj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var pointer = optionsObj;
          value = value === "true" ? true : value;
          value = value === "false" ? false : value;
          for (var i = 0; i < path2.length; i++) {
            if (path2[i] !== "global") {
              if (pointer[path2[i]] === void 0) {
                pointer[path2[i]] = {};
              }
              if (i !== path2.length - 1) {
                pointer = pointer[path2[i]];
              } else {
                pointer[path2[i]] = value;
              }
            }
          }
          return optionsObj;
        }
        /**
         * @private
         */
      }, {
        key: "_printOptions",
        value: function _printOptions() {
          var options2 = this.getOptions();
          this.optionsContainer.innerHTML = "<pre>var options = " + stringify$2(options2, null, 2) + "</pre>";
        }
        /**
         *
         * @returns {{}} options
         */
      }, {
        key: "getOptions",
        value: function getOptions() {
          var options2 = {};
          for (var i = 0; i < this.changedOptions.length; i++) {
            this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options2);
          }
          return options2;
        }
      }]);
      return Configurator2;
    }();
    string = "string";
    bool = "boolean";
    number = "number";
    array = "array";
    object = "object";
    dom = "dom";
    any = "any";
    endPoints = ["arrow", "bar", "box", "circle", "crow", "curve", "diamond", "image", "inv_curve", "inv_triangle", "triangle", "vee"];
    allOptions$1 = {
      configure: {
        enabled: {
          boolean: bool
        },
        filter: {
          boolean: bool,
          string,
          array,
          "function": "function"
        },
        container: {
          dom
        },
        showButton: {
          boolean: bool
        },
        __type__: {
          object,
          boolean: bool,
          string,
          array,
          "function": "function"
        }
      },
      edges: {
        arrows: {
          to: {
            enabled: {
              boolean: bool
            },
            scaleFactor: {
              number
            },
            type: {
              string: endPoints
            },
            imageHeight: {
              number
            },
            imageWidth: {
              number
            },
            src: {
              string
            },
            __type__: {
              object,
              boolean: bool
            }
          },
          middle: {
            enabled: {
              boolean: bool
            },
            scaleFactor: {
              number
            },
            type: {
              string: endPoints
            },
            imageWidth: {
              number
            },
            imageHeight: {
              number
            },
            src: {
              string
            },
            __type__: {
              object,
              boolean: bool
            }
          },
          from: {
            enabled: {
              boolean: bool
            },
            scaleFactor: {
              number
            },
            type: {
              string: endPoints
            },
            imageWidth: {
              number
            },
            imageHeight: {
              number
            },
            src: {
              string
            },
            __type__: {
              object,
              boolean: bool
            }
          },
          __type__: {
            string: ["from", "to", "middle"],
            object
          }
        },
        endPointOffset: {
          from: {
            number
          },
          to: {
            number
          },
          __type__: {
            object,
            number
          }
        },
        arrowStrikethrough: {
          boolean: bool
        },
        background: {
          enabled: {
            boolean: bool
          },
          color: {
            string
          },
          size: {
            number
          },
          dashes: {
            boolean: bool,
            array
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        chosen: {
          label: {
            boolean: bool,
            "function": "function"
          },
          edge: {
            boolean: bool,
            "function": "function"
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        color: {
          color: {
            string
          },
          highlight: {
            string
          },
          hover: {
            string
          },
          inherit: {
            string: ["from", "to", "both"],
            boolean: bool
          },
          opacity: {
            number
          },
          __type__: {
            object,
            string
          }
        },
        dashes: {
          boolean: bool,
          array
        },
        font: {
          color: {
            string
          },
          size: {
            number
          },
          // px
          face: {
            string
          },
          background: {
            string
          },
          strokeWidth: {
            number
          },
          // px
          strokeColor: {
            string
          },
          align: {
            string: ["horizontal", "top", "middle", "bottom"]
          },
          vadjust: {
            number
          },
          multi: {
            boolean: bool,
            string
          },
          bold: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          boldital: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          ital: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          mono: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          __type__: {
            object,
            string
          }
        },
        hidden: {
          boolean: bool
        },
        hoverWidth: {
          "function": "function",
          number
        },
        label: {
          string,
          "undefined": "undefined"
        },
        labelHighlightBold: {
          boolean: bool
        },
        length: {
          number,
          "undefined": "undefined"
        },
        physics: {
          boolean: bool
        },
        scaling: {
          min: {
            number
          },
          max: {
            number
          },
          label: {
            enabled: {
              boolean: bool
            },
            min: {
              number
            },
            max: {
              number
            },
            maxVisible: {
              number
            },
            drawThreshold: {
              number
            },
            __type__: {
              object,
              boolean: bool
            }
          },
          customScalingFunction: {
            "function": "function"
          },
          __type__: {
            object
          }
        },
        selectionWidth: {
          "function": "function",
          number
        },
        selfReferenceSize: {
          number
        },
        selfReference: {
          size: {
            number
          },
          angle: {
            number
          },
          renderBehindTheNode: {
            boolean: bool
          },
          __type__: {
            object
          }
        },
        shadow: {
          enabled: {
            boolean: bool
          },
          color: {
            string
          },
          size: {
            number
          },
          x: {
            number
          },
          y: {
            number
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        smooth: {
          enabled: {
            boolean: bool
          },
          type: {
            string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"]
          },
          roundness: {
            number
          },
          forceDirection: {
            string: ["horizontal", "vertical", "none"],
            boolean: bool
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        title: {
          string,
          "undefined": "undefined"
        },
        width: {
          number
        },
        widthConstraint: {
          maximum: {
            number
          },
          __type__: {
            object,
            boolean: bool,
            number
          }
        },
        value: {
          number,
          "undefined": "undefined"
        },
        __type__: {
          object
        }
      },
      groups: {
        useDefaultGroups: {
          boolean: bool
        },
        __any__: "get from nodes, will be overwritten below",
        __type__: {
          object
        }
      },
      interaction: {
        dragNodes: {
          boolean: bool
        },
        dragView: {
          boolean: bool
        },
        hideEdgesOnDrag: {
          boolean: bool
        },
        hideEdgesOnZoom: {
          boolean: bool
        },
        hideNodesOnDrag: {
          boolean: bool
        },
        hover: {
          boolean: bool
        },
        keyboard: {
          enabled: {
            boolean: bool
          },
          speed: {
            x: {
              number
            },
            y: {
              number
            },
            zoom: {
              number
            },
            __type__: {
              object
            }
          },
          bindToWindow: {
            boolean: bool
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        multiselect: {
          boolean: bool
        },
        navigationButtons: {
          boolean: bool
        },
        selectable: {
          boolean: bool
        },
        selectConnectedEdges: {
          boolean: bool
        },
        hoverConnectedEdges: {
          boolean: bool
        },
        tooltipDelay: {
          number
        },
        zoomView: {
          boolean: bool
        },
        zoomSpeed: {
          number
        },
        __type__: {
          object
        }
      },
      layout: {
        randomSeed: {
          "undefined": "undefined",
          number,
          string
        },
        improvedLayout: {
          boolean: bool
        },
        clusterThreshold: {
          number
        },
        hierarchical: {
          enabled: {
            boolean: bool
          },
          levelSeparation: {
            number
          },
          nodeSpacing: {
            number
          },
          treeSpacing: {
            number
          },
          blockShifting: {
            boolean: bool
          },
          edgeMinimization: {
            boolean: bool
          },
          parentCentralization: {
            boolean: bool
          },
          direction: {
            string: ["UD", "DU", "LR", "RL"]
          },
          // UD, DU, LR, RL
          sortMethod: {
            string: ["hubsize", "directed"]
          },
          // hubsize, directed
          shakeTowards: {
            string: ["leaves", "roots"]
          },
          // leaves, roots
          __type__: {
            object,
            boolean: bool
          }
        },
        __type__: {
          object
        }
      },
      manipulation: {
        enabled: {
          boolean: bool
        },
        initiallyActive: {
          boolean: bool
        },
        addNode: {
          boolean: bool,
          "function": "function"
        },
        addEdge: {
          boolean: bool,
          "function": "function"
        },
        editNode: {
          "function": "function"
        },
        editEdge: {
          editWithoutDrag: {
            "function": "function"
          },
          __type__: {
            object,
            boolean: bool,
            "function": "function"
          }
        },
        deleteNode: {
          boolean: bool,
          "function": "function"
        },
        deleteEdge: {
          boolean: bool,
          "function": "function"
        },
        controlNodeStyle: "get from nodes, will be overwritten below",
        __type__: {
          object,
          boolean: bool
        }
      },
      nodes: {
        borderWidth: {
          number
        },
        borderWidthSelected: {
          number,
          "undefined": "undefined"
        },
        brokenImage: {
          string,
          "undefined": "undefined"
        },
        chosen: {
          label: {
            boolean: bool,
            "function": "function"
          },
          node: {
            boolean: bool,
            "function": "function"
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        color: {
          border: {
            string
          },
          background: {
            string
          },
          highlight: {
            border: {
              string
            },
            background: {
              string
            },
            __type__: {
              object,
              string
            }
          },
          hover: {
            border: {
              string
            },
            background: {
              string
            },
            __type__: {
              object,
              string
            }
          },
          __type__: {
            object,
            string
          }
        },
        opacity: {
          number,
          "undefined": "undefined"
        },
        fixed: {
          x: {
            boolean: bool
          },
          y: {
            boolean: bool
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        font: {
          align: {
            string
          },
          color: {
            string
          },
          size: {
            number
          },
          // px
          face: {
            string
          },
          background: {
            string
          },
          strokeWidth: {
            number
          },
          // px
          strokeColor: {
            string
          },
          vadjust: {
            number
          },
          multi: {
            boolean: bool,
            string
          },
          bold: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          boldital: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          ital: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          mono: {
            color: {
              string
            },
            size: {
              number
            },
            // px
            face: {
              string
            },
            mod: {
              string
            },
            vadjust: {
              number
            },
            __type__: {
              object,
              string
            }
          },
          __type__: {
            object,
            string
          }
        },
        group: {
          string,
          number,
          "undefined": "undefined"
        },
        heightConstraint: {
          minimum: {
            number
          },
          valign: {
            string
          },
          __type__: {
            object,
            boolean: bool,
            number
          }
        },
        hidden: {
          boolean: bool
        },
        icon: {
          face: {
            string
          },
          code: {
            string
          },
          //'\uf007',
          size: {
            number
          },
          //50,
          color: {
            string
          },
          weight: {
            string,
            number
          },
          __type__: {
            object
          }
        },
        id: {
          string,
          number
        },
        image: {
          selected: {
            string,
            "undefined": "undefined"
          },
          // --> URL
          unselected: {
            string,
            "undefined": "undefined"
          },
          // --> URL
          __type__: {
            object,
            string
          }
        },
        imagePadding: {
          top: {
            number
          },
          right: {
            number
          },
          bottom: {
            number
          },
          left: {
            number
          },
          __type__: {
            object,
            number
          }
        },
        label: {
          string,
          "undefined": "undefined"
        },
        labelHighlightBold: {
          boolean: bool
        },
        level: {
          number,
          "undefined": "undefined"
        },
        margin: {
          top: {
            number
          },
          right: {
            number
          },
          bottom: {
            number
          },
          left: {
            number
          },
          __type__: {
            object,
            number
          }
        },
        mass: {
          number
        },
        physics: {
          boolean: bool
        },
        scaling: {
          min: {
            number
          },
          max: {
            number
          },
          label: {
            enabled: {
              boolean: bool
            },
            min: {
              number
            },
            max: {
              number
            },
            maxVisible: {
              number
            },
            drawThreshold: {
              number
            },
            __type__: {
              object,
              boolean: bool
            }
          },
          customScalingFunction: {
            "function": "function"
          },
          __type__: {
            object
          }
        },
        shadow: {
          enabled: {
            boolean: bool
          },
          color: {
            string
          },
          size: {
            number
          },
          x: {
            number
          },
          y: {
            number
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        shape: {
          string: ["custom", "ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]
        },
        customRenderer: {
          "function": "function"
        },
        shapeProperties: {
          borderDashes: {
            boolean: bool,
            array
          },
          borderRadius: {
            number
          },
          interpolation: {
            boolean: bool
          },
          useImageSize: {
            boolean: bool
          },
          useBorderWithImage: {
            boolean: bool
          },
          coordinateOrigin: {
            string: ["center", "top-left"]
          },
          __type__: {
            object
          }
        },
        size: {
          number
        },
        title: {
          string,
          dom,
          "undefined": "undefined"
        },
        value: {
          number,
          "undefined": "undefined"
        },
        widthConstraint: {
          minimum: {
            number
          },
          maximum: {
            number
          },
          __type__: {
            object,
            boolean: bool,
            number
          }
        },
        x: {
          number
        },
        y: {
          number
        },
        __type__: {
          object
        }
      },
      physics: {
        enabled: {
          boolean: bool
        },
        barnesHut: {
          theta: {
            number
          },
          gravitationalConstant: {
            number
          },
          centralGravity: {
            number
          },
          springLength: {
            number
          },
          springConstant: {
            number
          },
          damping: {
            number
          },
          avoidOverlap: {
            number
          },
          __type__: {
            object
          }
        },
        forceAtlas2Based: {
          theta: {
            number
          },
          gravitationalConstant: {
            number
          },
          centralGravity: {
            number
          },
          springLength: {
            number
          },
          springConstant: {
            number
          },
          damping: {
            number
          },
          avoidOverlap: {
            number
          },
          __type__: {
            object
          }
        },
        repulsion: {
          centralGravity: {
            number
          },
          springLength: {
            number
          },
          springConstant: {
            number
          },
          nodeDistance: {
            number
          },
          damping: {
            number
          },
          __type__: {
            object
          }
        },
        hierarchicalRepulsion: {
          centralGravity: {
            number
          },
          springLength: {
            number
          },
          springConstant: {
            number
          },
          nodeDistance: {
            number
          },
          damping: {
            number
          },
          avoidOverlap: {
            number
          },
          __type__: {
            object
          }
        },
        maxVelocity: {
          number
        },
        minVelocity: {
          number
        },
        // px/s
        solver: {
          string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"]
        },
        stabilization: {
          enabled: {
            boolean: bool
          },
          iterations: {
            number
          },
          // maximum number of iteration to stabilize
          updateInterval: {
            number
          },
          onlyDynamicEdges: {
            boolean: bool
          },
          fit: {
            boolean: bool
          },
          __type__: {
            object,
            boolean: bool
          }
        },
        timestep: {
          number
        },
        adaptiveTimestep: {
          boolean: bool
        },
        wind: {
          x: {
            number
          },
          y: {
            number
          },
          __type__: {
            object
          }
        },
        __type__: {
          object,
          boolean: bool
        }
      },
      //globals :
      autoResize: {
        boolean: bool
      },
      clickToUse: {
        boolean: bool
      },
      locale: {
        string
      },
      locales: {
        __any__: {
          any
        },
        __type__: {
          object
        }
      },
      height: {
        string
      },
      width: {
        string
      },
      __type__: {
        object
      }
    };
    allOptions$1.groups.__any__ = allOptions$1.nodes;
    allOptions$1.manipulation.controlNodeStyle = allOptions$1.nodes;
    configureOptions = {
      nodes: {
        borderWidth: [1, 0, 10, 1],
        borderWidthSelected: [2, 0, 10, 1],
        color: {
          border: ["color", "#2B7CE9"],
          background: ["color", "#97C2FC"],
          highlight: {
            border: ["color", "#2B7CE9"],
            background: ["color", "#D2E5FF"]
          },
          hover: {
            border: ["color", "#2B7CE9"],
            background: ["color", "#D2E5FF"]
          }
        },
        opacity: [0, 0, 1, 0.1],
        fixed: {
          x: false,
          y: false
        },
        font: {
          color: ["color", "#343434"],
          size: [14, 0, 100, 1],
          // px
          face: ["arial", "verdana", "tahoma"],
          background: ["color", "none"],
          strokeWidth: [0, 0, 50, 1],
          // px
          strokeColor: ["color", "#ffffff"]
        },
        //group: 'string',
        hidden: false,
        labelHighlightBold: true,
        //icon: {
        //  face: 'string',  //'FontAwesome',
        //  code: 'string',  //'\uf007',
        //  size: [50, 0, 200, 1],  //50,
        //  color: ['color','#2B7CE9']   //'#aa00ff'
        //},
        //image: 'string', // --> URL
        physics: true,
        scaling: {
          min: [10, 0, 200, 1],
          max: [30, 0, 200, 1],
          label: {
            enabled: false,
            min: [14, 0, 200, 1],
            max: [30, 0, 200, 1],
            maxVisible: [30, 0, 200, 1],
            drawThreshold: [5, 0, 20, 1]
          }
        },
        shadow: {
          enabled: false,
          color: "rgba(0,0,0,0.5)",
          size: [10, 0, 20, 1],
          x: [5, -30, 30, 1],
          y: [5, -30, 30, 1]
        },
        shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
        shapeProperties: {
          borderDashes: false,
          borderRadius: [6, 0, 20, 1],
          interpolation: true,
          useImageSize: false
        },
        size: [25, 0, 200, 1]
      },
      edges: {
        arrows: {
          to: {
            enabled: false,
            scaleFactor: [1, 0, 3, 0.05],
            type: "arrow"
          },
          middle: {
            enabled: false,
            scaleFactor: [1, 0, 3, 0.05],
            type: "arrow"
          },
          from: {
            enabled: false,
            scaleFactor: [1, 0, 3, 0.05],
            type: "arrow"
          }
        },
        endPointOffset: {
          from: [0, -10, 10, 1],
          to: [0, -10, 10, 1]
        },
        arrowStrikethrough: true,
        color: {
          color: ["color", "#848484"],
          highlight: ["color", "#848484"],
          hover: ["color", "#848484"],
          inherit: ["from", "to", "both", true, false],
          opacity: [1, 0, 1, 0.05]
        },
        dashes: false,
        font: {
          color: ["color", "#343434"],
          size: [14, 0, 100, 1],
          // px
          face: ["arial", "verdana", "tahoma"],
          background: ["color", "none"],
          strokeWidth: [2, 0, 50, 1],
          // px
          strokeColor: ["color", "#ffffff"],
          align: ["horizontal", "top", "middle", "bottom"]
        },
        hidden: false,
        hoverWidth: [1.5, 0, 5, 0.1],
        labelHighlightBold: true,
        physics: true,
        scaling: {
          min: [1, 0, 100, 1],
          max: [15, 0, 100, 1],
          label: {
            enabled: true,
            min: [14, 0, 200, 1],
            max: [30, 0, 200, 1],
            maxVisible: [30, 0, 200, 1],
            drawThreshold: [5, 0, 20, 1]
          }
        },
        selectionWidth: [1.5, 0, 5, 0.1],
        selfReferenceSize: [20, 0, 200, 1],
        selfReference: {
          size: [20, 0, 200, 1],
          angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],
          renderBehindTheNode: true
        },
        shadow: {
          enabled: false,
          color: "rgba(0,0,0,0.5)",
          size: [10, 0, 20, 1],
          x: [5, -30, 30, 1],
          y: [5, -30, 30, 1]
        },
        smooth: {
          enabled: true,
          type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
          forceDirection: ["horizontal", "vertical", "none"],
          roundness: [0.5, 0, 1, 0.05]
        },
        width: [1, 0, 30, 1]
      },
      layout: {
        //randomSeed: [0, 0, 500, 1],
        //improvedLayout: true,
        hierarchical: {
          enabled: false,
          levelSeparation: [150, 20, 500, 5],
          nodeSpacing: [100, 20, 500, 5],
          treeSpacing: [200, 20, 500, 5],
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: true,
          direction: ["UD", "DU", "LR", "RL"],
          // UD, DU, LR, RL
          sortMethod: ["hubsize", "directed"],
          // hubsize, directed
          shakeTowards: ["leaves", "roots"]
          // leaves, roots
        }
      },
      interaction: {
        dragNodes: true,
        dragView: true,
        hideEdgesOnDrag: false,
        hideEdgesOnZoom: false,
        hideNodesOnDrag: false,
        hover: false,
        keyboard: {
          enabled: false,
          speed: {
            x: [10, 0, 40, 1],
            y: [10, 0, 40, 1],
            zoom: [0.02, 0, 0.1, 5e-3]
          },
          bindToWindow: true
        },
        multiselect: false,
        navigationButtons: false,
        selectable: true,
        selectConnectedEdges: true,
        hoverConnectedEdges: true,
        tooltipDelay: [300, 0, 1e3, 25],
        zoomView: true,
        zoomSpeed: [1, 0.1, 2, 0.1]
      },
      manipulation: {
        enabled: false,
        initiallyActive: false
      },
      physics: {
        enabled: true,
        barnesHut: {
          theta: [0.5, 0.1, 1, 0.05],
          gravitationalConstant: [-2e3, -3e4, 0, 50],
          centralGravity: [0.3, 0, 10, 0.05],
          springLength: [95, 0, 500, 5],
          springConstant: [0.04, 0, 1.2, 5e-3],
          damping: [0.09, 0, 1, 0.01],
          avoidOverlap: [0, 0, 1, 0.01]
        },
        forceAtlas2Based: {
          theta: [0.5, 0.1, 1, 0.05],
          gravitationalConstant: [-50, -500, 0, 1],
          centralGravity: [0.01, 0, 1, 5e-3],
          springLength: [95, 0, 500, 5],
          springConstant: [0.08, 0, 1.2, 5e-3],
          damping: [0.4, 0, 1, 0.01],
          avoidOverlap: [0, 0, 1, 0.01]
        },
        repulsion: {
          centralGravity: [0.2, 0, 10, 0.05],
          springLength: [200, 0, 500, 5],
          springConstant: [0.05, 0, 1.2, 5e-3],
          nodeDistance: [100, 0, 500, 5],
          damping: [0.09, 0, 1, 0.01]
        },
        hierarchicalRepulsion: {
          centralGravity: [0.2, 0, 10, 0.05],
          springLength: [100, 0, 500, 5],
          springConstant: [0.01, 0, 1.2, 5e-3],
          nodeDistance: [120, 0, 500, 5],
          damping: [0.09, 0, 1, 0.01],
          avoidOverlap: [0, 0, 1, 0.01]
        },
        maxVelocity: [50, 0, 150, 1],
        minVelocity: [0.1, 0.01, 0.5, 0.01],
        solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
        timestep: [0.5, 0.01, 1, 0.01],
        wind: {
          x: [0, -10, 10, 0.1],
          y: [0, -10, 10, 0.1]
        }
        //adaptiveTimestep: true
      }
    };
    options = Object.freeze({
      __proto__: null,
      allOptions: allOptions$1,
      configureOptions
    });
    FloydWarshall = function() {
      function FloydWarshall2() {
        classCallCheck(this, FloydWarshall2);
      }
      createClass(FloydWarshall2, [{
        key: "getDistances",
        value: function getDistances(body, nodesArray, edgesArray) {
          var D_matrix = {};
          var edges = body.edges;
          for (var i = 0; i < nodesArray.length; i++) {
            var node = nodesArray[i];
            var cell = {};
            D_matrix[node] = cell;
            for (var j = 0; j < nodesArray.length; j++) {
              cell[nodesArray[j]] = i == j ? 0 : 1e9;
            }
          }
          for (var _i = 0; _i < edgesArray.length; _i++) {
            var edge = edges[edgesArray[_i]];
            if (edge.connected === true && D_matrix[edge.fromId] !== void 0 && D_matrix[edge.toId] !== void 0) {
              D_matrix[edge.fromId][edge.toId] = 1;
              D_matrix[edge.toId][edge.fromId] = 1;
            }
          }
          var nodeCount = nodesArray.length;
          for (var k = 0; k < nodeCount; k++) {
            var knode = nodesArray[k];
            var kcolm = D_matrix[knode];
            for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
              var inode = nodesArray[_i2];
              var icolm = D_matrix[inode];
              for (var _j = _i2 + 1; _j < nodeCount; _j++) {
                var jnode = nodesArray[_j];
                var jcolm = D_matrix[jnode];
                var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
                icolm[jnode] = val;
                jcolm[inode] = val;
              }
            }
          }
          return D_matrix;
        }
      }]);
      return FloydWarshall2;
    }();
    KamadaKawai = function() {
      function KamadaKawai2(body, edgeLength, edgeStrength) {
        classCallCheck(this, KamadaKawai2);
        this.body = body;
        this.springLength = edgeLength;
        this.springConstant = edgeStrength;
        this.distanceSolver = new FloydWarshall();
      }
      createClass(KamadaKawai2, [{
        key: "setOptions",
        value: function setOptions(options2) {
          if (options2) {
            if (options2.springLength) {
              this.springLength = options2.springLength;
            }
            if (options2.springConstant) {
              this.springConstant = options2.springConstant;
            }
          }
        }
        /**
         * Position the system
         * @param {Array.<Node>} nodesArray
         * @param {Array.<vis.Edge>} edgesArray
         * @param {boolean} [ignoreClusters=false]
         */
      }, {
        key: "solve",
        value: function solve(nodesArray, edgesArray) {
          var ignoreClusters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray);
          this._createL_matrix(D_matrix);
          this._createK_matrix(D_matrix);
          this._createE_matrix();
          var threshold = 0.01;
          var innerThreshold = 1;
          var iterations = 0;
          var maxIterations = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3));
          var maxInnerIterations = 5;
          var maxEnergy = 1e9;
          var highE_nodeId = 0, dE_dx = 0, dE_dy = 0, delta_m = 0, subIterations = 0;
          while (maxEnergy > threshold && iterations < maxIterations) {
            iterations += 1;
            var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);
            var _this$_getHighestEner2 = slicedToArray(_this$_getHighestEner, 4);
            highE_nodeId = _this$_getHighestEner2[0];
            maxEnergy = _this$_getHighestEner2[1];
            dE_dx = _this$_getHighestEner2[2];
            dE_dy = _this$_getHighestEner2[3];
            delta_m = maxEnergy;
            subIterations = 0;
            while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
              subIterations += 1;
              this._moveNode(highE_nodeId, dE_dx, dE_dy);
              var _this$_getEnergy = this._getEnergy(highE_nodeId);
              var _this$_getEnergy2 = slicedToArray(_this$_getEnergy, 3);
              delta_m = _this$_getEnergy2[0];
              dE_dx = _this$_getEnergy2[1];
              dE_dy = _this$_getEnergy2[2];
            }
          }
        }
        /**
         * get the node with the highest energy
         * @param {boolean} ignoreClusters
         * @returns {number[]}
         * @private
         */
      }, {
        key: "_getHighestEnergyNode",
        value: function _getHighestEnergyNode(ignoreClusters) {
          var nodesArray = this.body.nodeIndices;
          var nodes = this.body.nodes;
          var maxEnergy = 0;
          var maxEnergyNodeId = nodesArray[0];
          var dE_dx_max = 0, dE_dy_max = 0;
          for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
            var m = nodesArray[nodeIdx];
            if (nodes[m].predefinedPosition === false || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x === true || nodes[m].options.fixed.y === true) {
              var _this$_getEnergy3 = this._getEnergy(m), _this$_getEnergy4 = slicedToArray(_this$_getEnergy3, 3), delta_m = _this$_getEnergy4[0], dE_dx = _this$_getEnergy4[1], dE_dy = _this$_getEnergy4[2];
              if (maxEnergy < delta_m) {
                maxEnergy = delta_m;
                maxEnergyNodeId = m;
                dE_dx_max = dE_dx;
                dE_dy_max = dE_dy;
              }
            }
          }
          return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
        }
        /**
         * calculate the energy of a single node
         * @param {Node.id} m
         * @returns {number[]}
         * @private
         */
      }, {
        key: "_getEnergy",
        value: function _getEnergy(m) {
          var _this$E_sums$m = slicedToArray(this.E_sums[m], 2), dE_dx = _this$E_sums$m[0], dE_dy = _this$E_sums$m[1];
          var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
          return [delta_m, dE_dx, dE_dy];
        }
        /**
         * move the node based on it's energy
         * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
         * @param {number} m
         * @param {number} dE_dx
         * @param {number} dE_dy
         * @private
         */
      }, {
        key: "_moveNode",
        value: function _moveNode(m, dE_dx, dE_dy) {
          var nodesArray = this.body.nodeIndices;
          var nodes = this.body.nodes;
          var d2E_dx2 = 0;
          var d2E_dxdy = 0;
          var d2E_dy2 = 0;
          var x_m = nodes[m].x;
          var y_m = nodes[m].y;
          var km = this.K_matrix[m];
          var lm = this.L_matrix[m];
          for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
            var i = nodesArray[iIdx];
            if (i !== m) {
              var x_i = nodes[i].x;
              var y_i = nodes[i].y;
              var kmat = km[i];
              var lmat = lm[i];
              var denominator = 1 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
              d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
              d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
              d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
            }
          }
          var A = d2E_dx2, B = d2E_dxdy, C = dE_dx, D = d2E_dy2, E = dE_dy;
          var dy = (C / A + E / B) / (B / A - D / B);
          var dx = -(B * dy + C) / A;
          nodes[m].x += dx;
          nodes[m].y += dy;
          this._updateE_matrix(m);
        }
        /**
         * Create the L matrix: edge length times shortest path
         * @param {Object} D_matrix
         * @private
         */
      }, {
        key: "_createL_matrix",
        value: function _createL_matrix(D_matrix) {
          var nodesArray = this.body.nodeIndices;
          var edgeLength = this.springLength;
          this.L_matrix = [];
          for (var i = 0; i < nodesArray.length; i++) {
            this.L_matrix[nodesArray[i]] = {};
            for (var j = 0; j < nodesArray.length; j++) {
              this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
            }
          }
        }
        /**
         * Create the K matrix: spring constants times shortest path
         * @param {Object} D_matrix
         * @private
         */
      }, {
        key: "_createK_matrix",
        value: function _createK_matrix(D_matrix) {
          var nodesArray = this.body.nodeIndices;
          var edgeStrength = this.springConstant;
          this.K_matrix = [];
          for (var i = 0; i < nodesArray.length; i++) {
            this.K_matrix[nodesArray[i]] = {};
            for (var j = 0; j < nodesArray.length; j++) {
              this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
            }
          }
        }
        /**
         *  Create matrix with all energies between nodes
         *  @private
         */
      }, {
        key: "_createE_matrix",
        value: function _createE_matrix() {
          var nodesArray = this.body.nodeIndices;
          var nodes = this.body.nodes;
          this.E_matrix = {};
          this.E_sums = {};
          for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
            this.E_matrix[nodesArray[mIdx]] = [];
          }
          for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
            var m = nodesArray[_mIdx];
            var x_m = nodes[m].x;
            var y_m = nodes[m].y;
            var dE_dx = 0;
            var dE_dy = 0;
            for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
              var i = nodesArray[iIdx];
              if (i !== m) {
                var x_i = nodes[i].x;
                var y_i = nodes[i].y;
                var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
                this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
                this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
                dE_dx += this.E_matrix[m][iIdx][0];
                dE_dy += this.E_matrix[m][iIdx][1];
              }
            }
            this.E_sums[m] = [dE_dx, dE_dy];
          }
        }
        /**
         * Update method, just doing single column (rows are auto-updated) (update all sums)
         *
         * @param {number} m
         * @private
         */
      }, {
        key: "_updateE_matrix",
        value: function _updateE_matrix(m) {
          var nodesArray = this.body.nodeIndices;
          var nodes = this.body.nodes;
          var colm = this.E_matrix[m];
          var kcolm = this.K_matrix[m];
          var lcolm = this.L_matrix[m];
          var x_m = nodes[m].x;
          var y_m = nodes[m].y;
          var dE_dx = 0;
          var dE_dy = 0;
          for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
            var i = nodesArray[iIdx];
            if (i !== m) {
              var cell = colm[iIdx];
              var oldDx = cell[0];
              var oldDy = cell[1];
              var x_i = nodes[i].x;
              var y_i = nodes[i].y;
              var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
              var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
              var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
              colm[iIdx] = [dx, dy];
              dE_dx += dx;
              dE_dy += dy;
              var sum = this.E_sums[i];
              sum[0] += dx - oldDx;
              sum[1] += dy - oldDy;
            }
          }
          this.E_sums[m] = [dE_dx, dE_dy];
        }
      }]);
      return KamadaKawai2;
    }();
    componentEmitter(Network.prototype);
    Network.prototype.setOptions = function(options2) {
      var _this2 = this;
      if (options2 === null) {
        options2 = void 0;
      }
      if (options2 !== void 0) {
        var errorFound2 = Validator.validate(options2, allOptions$1);
        if (errorFound2 === true) {
          console.log("%cErrors have been found in the supplied options object.", printStyle);
        }
        var fields = ["locale", "locales", "clickToUse"];
        selectiveDeepExtend(fields, this.options, options2);
        if (options2.locale !== void 0) {
          options2.locale = normalizeLanguageCode(options2.locales || this.options.locales, options2.locale);
        }
        options2 = this.layoutEngine.setOptions(options2.layout, options2);
        this.canvas.setOptions(options2);
        this.groups.setOptions(options2.groups);
        this.nodesHandler.setOptions(options2.nodes);
        this.edgesHandler.setOptions(options2.edges);
        this.physics.setOptions(options2.physics);
        this.manipulation.setOptions(options2.manipulation, options2, this.options);
        this.interactionHandler.setOptions(options2.interaction);
        this.renderer.setOptions(options2.interaction);
        this.selectionHandler.setOptions(options2.interaction);
        if (options2.groups !== void 0) {
          this.body.emitter.emit("refreshNodes");
        }
        if ("configure" in options2) {
          if (!this.configurator) {
            this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio);
          }
          this.configurator.setOptions(options2.configure);
        }
        if (this.configurator && this.configurator.options.enabled === true) {
          var networkOptions = {
            nodes: {},
            edges: {},
            layout: {},
            interaction: {},
            manipulation: {},
            physics: {},
            global: {}
          };
          deepExtend(networkOptions.nodes, this.nodesHandler.options);
          deepExtend(networkOptions.edges, this.edgesHandler.options);
          deepExtend(networkOptions.layout, this.layoutEngine.options);
          deepExtend(networkOptions.interaction, this.selectionHandler.options);
          deepExtend(networkOptions.interaction, this.renderer.options);
          deepExtend(networkOptions.interaction, this.interactionHandler.options);
          deepExtend(networkOptions.manipulation, this.manipulation.options);
          deepExtend(networkOptions.physics, this.physics.options);
          deepExtend(networkOptions.global, this.canvas.options);
          deepExtend(networkOptions.global, this.options);
          this.configurator.setModuleOptions(networkOptions);
        }
        if (options2.clickToUse !== void 0) {
          if (options2.clickToUse === true) {
            if (this.activator === void 0) {
              this.activator = new Activator(this.canvas.frame);
              this.activator.on("change", function() {
                _this2.body.emitter.emit("activate");
              });
            }
          } else {
            if (this.activator !== void 0) {
              this.activator.destroy();
              delete this.activator;
            }
            this.body.emitter.emit("activate");
          }
        } else {
          this.body.emitter.emit("activate");
        }
        this.canvas.setSize();
        this.body.emitter.emit("startSimulation");
      }
    };
    Network.prototype._updateVisibleIndices = function() {
      var nodes = this.body.nodes;
      var edges = this.body.edges;
      this.body.nodeIndices = [];
      this.body.edgeIndices = [];
      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {
            this.body.nodeIndices.push(nodes[nodeId].id);
          }
        }
      }
      for (var edgeId in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
          var edge = edges[edgeId];
          var fromNode = nodes[edge.fromId];
          var toNode = nodes[edge.toId];
          var edgeNodesPresent = fromNode !== void 0 && toNode !== void 0;
          var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && toNode.options.hidden === false;
          if (isVisible) {
            this.body.edgeIndices.push(edge.id);
          }
        }
      }
    };
    Network.prototype.bindEventListeners = function() {
      var _this3 = this;
      this.body.emitter.on("_dataChanged", function() {
        _this3.edgesHandler._updateState();
        _this3.body.emitter.emit("_dataUpdated");
      });
      this.body.emitter.on("_dataUpdated", function() {
        _this3.clustering._updateState();
        _this3._updateVisibleIndices();
        _this3._updateValueRange(_this3.body.nodes);
        _this3._updateValueRange(_this3.body.edges);
        _this3.body.emitter.emit("startSimulation");
        _this3.body.emitter.emit("_requestRedraw");
      });
    };
    Network.prototype.setData = function(data2) {
      this.body.emitter.emit("resetPhysics");
      this.body.emitter.emit("_resetData");
      this.selectionHandler.unselectAll();
      if (data2 && data2.dot && (data2.nodes || data2.edges)) {
        throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');
      }
      this.setOptions(data2 && data2.options);
      if (data2 && data2.dot) {
        console.log("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");
        var dotData = DOTToGraph(data2.dot);
        this.setData(dotData);
        return;
      } else if (data2 && data2.gephi) {
        console.log("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
        var gephiData = parseGephi(data2.gephi);
        this.setData(gephiData);
        return;
      } else {
        this.nodesHandler.setData(data2 && data2.nodes, true);
        this.edgesHandler.setData(data2 && data2.edges, true);
      }
      this.body.emitter.emit("_dataChanged");
      this.body.emitter.emit("_dataLoaded");
      this.body.emitter.emit("initPhysics");
    };
    Network.prototype.destroy = function() {
      this.body.emitter.emit("destroy");
      this.body.emitter.off();
      this.off();
      delete this.groups;
      delete this.canvas;
      delete this.selectionHandler;
      delete this.interactionHandler;
      delete this.view;
      delete this.renderer;
      delete this.physics;
      delete this.layoutEngine;
      delete this.clustering;
      delete this.manipulation;
      delete this.nodesHandler;
      delete this.edgesHandler;
      delete this.configurator;
      delete this.images;
      for (var nodeId in this.body.nodes) {
        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) continue;
        delete this.body.nodes[nodeId];
      }
      for (var edgeId in this.body.edges) {
        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) continue;
        delete this.body.edges[edgeId];
      }
      recursiveDOMDelete(this.body.container);
    };
    Network.prototype._updateValueRange = function(obj) {
      var id2;
      var valueMin = void 0;
      var valueMax = void 0;
      var valueTotal = 0;
      for (id2 in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, id2)) {
          var value = obj[id2].getValue();
          if (value !== void 0) {
            valueMin = valueMin === void 0 ? value : Math.min(value, valueMin);
            valueMax = valueMax === void 0 ? value : Math.max(value, valueMax);
            valueTotal += value;
          }
        }
      }
      if (valueMin !== void 0 && valueMax !== void 0) {
        for (id2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, id2)) {
            obj[id2].setValueRange(valueMin, valueMax, valueTotal);
          }
        }
      }
    };
    Network.prototype.isActive = function() {
      return !this.activator || this.activator.active;
    };
    Network.prototype.setSize = function() {
      return this.canvas.setSize.apply(this.canvas, arguments);
    };
    Network.prototype.canvasToDOM = function() {
      return this.canvas.canvasToDOM.apply(this.canvas, arguments);
    };
    Network.prototype.DOMtoCanvas = function() {
      return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
    };
    Network.prototype.findNode = function() {
      return this.clustering.findNode.apply(this.clustering, arguments);
    };
    Network.prototype.isCluster = function() {
      return this.clustering.isCluster.apply(this.clustering, arguments);
    };
    Network.prototype.openCluster = function() {
      return this.clustering.openCluster.apply(this.clustering, arguments);
    };
    Network.prototype.cluster = function() {
      return this.clustering.cluster.apply(this.clustering, arguments);
    };
    Network.prototype.getNodesInCluster = function() {
      return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
    };
    Network.prototype.clusterByConnection = function() {
      return this.clustering.clusterByConnection.apply(this.clustering, arguments);
    };
    Network.prototype.clusterByHubsize = function() {
      return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
    };
    Network.prototype.updateClusteredNode = function() {
      return this.clustering.updateClusteredNode.apply(this.clustering, arguments);
    };
    Network.prototype.getClusteredEdges = function() {
      return this.clustering.getClusteredEdges.apply(this.clustering, arguments);
    };
    Network.prototype.getBaseEdge = function() {
      return this.clustering.getBaseEdge.apply(this.clustering, arguments);
    };
    Network.prototype.getBaseEdges = function() {
      return this.clustering.getBaseEdges.apply(this.clustering, arguments);
    };
    Network.prototype.updateEdge = function() {
      return this.clustering.updateEdge.apply(this.clustering, arguments);
    };
    Network.prototype.clusterOutliers = function() {
      return this.clustering.clusterOutliers.apply(this.clustering, arguments);
    };
    Network.prototype.getSeed = function() {
      return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
    };
    Network.prototype.enableEditMode = function() {
      return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
    };
    Network.prototype.disableEditMode = function() {
      return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
    };
    Network.prototype.addNodeMode = function() {
      return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
    };
    Network.prototype.editNode = function() {
      return this.manipulation.editNode.apply(this.manipulation, arguments);
    };
    Network.prototype.editNodeMode = function() {
      console.log("Deprecated: Please use editNode instead of editNodeMode.");
      return this.manipulation.editNode.apply(this.manipulation, arguments);
    };
    Network.prototype.addEdgeMode = function() {
      return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
    };
    Network.prototype.editEdgeMode = function() {
      return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
    };
    Network.prototype.deleteSelected = function() {
      return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
    };
    Network.prototype.getPositions = function() {
      return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
    };
    Network.prototype.getPosition = function() {
      return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);
    };
    Network.prototype.storePositions = function() {
      return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
    };
    Network.prototype.moveNode = function() {
      return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
    };
    Network.prototype.getBoundingBox = function() {
      return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
    };
    Network.prototype.getConnectedNodes = function(objectId) {
      if (this.body.nodes[objectId] !== void 0) {
        return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
      } else {
        return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
      }
    };
    Network.prototype.getConnectedEdges = function() {
      return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
    };
    Network.prototype.startSimulation = function() {
      return this.physics.startSimulation.apply(this.physics, arguments);
    };
    Network.prototype.stopSimulation = function() {
      return this.physics.stopSimulation.apply(this.physics, arguments);
    };
    Network.prototype.stabilize = function() {
      return this.physics.stabilize.apply(this.physics, arguments);
    };
    Network.prototype.getSelection = function() {
      return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
    };
    Network.prototype.setSelection = function() {
      return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
    };
    Network.prototype.getSelectedNodes = function() {
      return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
    };
    Network.prototype.getSelectedEdges = function() {
      return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
    };
    Network.prototype.getNodeAt = function() {
      var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
      if (node !== void 0 && node.id !== void 0) {
        return node.id;
      }
      return node;
    };
    Network.prototype.getEdgeAt = function() {
      var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
      if (edge !== void 0 && edge.id !== void 0) {
        return edge.id;
      }
      return edge;
    };
    Network.prototype.selectNodes = function() {
      return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
    };
    Network.prototype.selectEdges = function() {
      return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
    };
    Network.prototype.unselectAll = function() {
      this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
      this.redraw();
    };
    Network.prototype.redraw = function() {
      return this.renderer.redraw.apply(this.renderer, arguments);
    };
    Network.prototype.getScale = function() {
      return this.view.getScale.apply(this.view, arguments);
    };
    Network.prototype.getViewPosition = function() {
      return this.view.getViewPosition.apply(this.view, arguments);
    };
    Network.prototype.fit = function() {
      return this.view.fit.apply(this.view, arguments);
    };
    Network.prototype.moveTo = function() {
      return this.view.moveTo.apply(this.view, arguments);
    };
    Network.prototype.focus = function() {
      return this.view.focus.apply(this.view, arguments);
    };
    Network.prototype.releaseNode = function() {
      return this.view.releaseNode.apply(this.view, arguments);
    };
    Network.prototype.getOptionsFromConfigurator = function() {
      var options2 = {};
      if (this.configurator) {
        options2 = this.configurator.getOptions.apply(this.configurator);
      }
      return options2;
    };
    parseDOTNetwork = DOTToGraph;
  }
});

// node_modules/react-vis-network-graph/node_modules/vis-network/standalone/esm/index.js
var init_esm = __esm({
  "node_modules/react-vis-network-graph/node_modules/vis-network/standalone/esm/index.js"() {
    init_vis_network();
  }
});

// node_modules/react-vis-network-graph/node_modules/vis-network/standalone/index.js
var standalone_exports = {};
__export(standalone_exports, {
  DataSet: () => DataSet,
  DataView: () => DataView,
  Network: () => Network,
  NetworkImages: () => Images,
  Queue: () => Queue,
  data: () => index$1,
  networkDOTParser: () => dotparser,
  networkGephiParser: () => gephiParser,
  networkOptions: () => options,
  parseDOTNetwork: () => parseDOTNetwork,
  parseGephiNetwork: () => parseGephi
});
var init_standalone = __esm({
  "node_modules/react-vis-network-graph/node_modules/vis-network/standalone/index.js"() {
    init_esm();
  }
});

// node_modules/react-vis-network-graph/node_modules/uuid/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/react-vis-network-graph/node_modules/uuid/rng-browser.js"(exports, module) {
    var rng2;
    var crypto2 = global.crypto || global.msCrypto;
    if (crypto2 && crypto2.getRandomValues) {
      _rnds8 = new Uint8Array(16);
      rng2 = function whatwgRNG() {
        crypto2.getRandomValues(_rnds8);
        return _rnds8;
      };
    }
    var _rnds8;
    if (!rng2) {
      _rnds = new Array(16);
      rng2 = function() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0) r = Math.random() * 4294967296;
          _rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return _rnds;
      };
    }
    var _rnds;
    module.exports = rng2;
  }
});

// node_modules/react-vis-network-graph/node_modules/uuid/uuid.js
var require_uuid = __commonJS({
  "node_modules/react-vis-network-graph/node_modules/uuid/uuid.js"(exports, module) {
    var _rng = require_rng_browser();
    var _byteToHex = [];
    var _hexToByte = {};
    for (i = 0; i < 256; i++) {
      _byteToHex[i] = (i + 256).toString(16).substr(1);
      _hexToByte[_byteToHex[i]] = i;
    }
    var i;
    function parse(s, buf, offset) {
      var i2 = buf && offset || 0, ii = 0;
      buf = buf || [];
      s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
        if (ii < 16) {
          buf[i2 + ii++] = _hexToByte[oct];
        }
      });
      while (ii < 16) {
        buf[i2 + ii++] = 0;
      }
      return buf;
    }
    function unparse(buf, offset) {
      var i2 = offset || 0, bth = _byteToHex;
      return bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]];
    }
    var _seedBytes = _rng();
    var _nodeId = [
      _seedBytes[0] | 1,
      _seedBytes[1],
      _seedBytes[2],
      _seedBytes[3],
      _seedBytes[4],
      _seedBytes[5]
    ];
    var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 16383;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options2, buf, offset) {
      var i2 = buf && offset || 0;
      var b = buf || [];
      options2 = options2 || {};
      var clockseq = options2.clockseq !== void 0 ? options2.clockseq : _clockseq;
      var msecs = options2.msecs !== void 0 ? options2.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options2.nsecs !== void 0 ? options2.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options2.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options2.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i2++] = tl >>> 24 & 255;
      b[i2++] = tl >>> 16 & 255;
      b[i2++] = tl >>> 8 & 255;
      b[i2++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i2++] = tmh >>> 8 & 255;
      b[i2++] = tmh & 255;
      b[i2++] = tmh >>> 24 & 15 | 16;
      b[i2++] = tmh >>> 16 & 255;
      b[i2++] = clockseq >>> 8 | 128;
      b[i2++] = clockseq & 255;
      var node = options2.node || _nodeId;
      for (var n = 0; n < 6; n++) {
        b[i2 + n] = node[n];
      }
      return buf ? buf : unparse(b);
    }
    function v42(options2, buf, offset) {
      var i2 = buf && offset || 0;
      if (typeof options2 == "string") {
        buf = options2 == "binary" ? new Array(16) : null;
        options2 = null;
      }
      options2 = options2 || {};
      var rnds = options2.random || (options2.rng || _rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ii++) {
          buf[i2 + ii] = rnds[ii];
        }
      }
      return buf || unparse(rnds);
    }
    var uuid = v42;
    uuid.v1 = v1;
    uuid.v4 = v42;
    uuid.parse = parse;
    uuid.unparse = unparse;
    module.exports = uuid;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols4 = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject2(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject2(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols4) {
          symbols = getOwnPropertySymbols4(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has2 = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has2;
    function checkPropTypes(typeSpecs, values3, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has2(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign3 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has2 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data2) {
        this.message = message;
        this.data = data2 && typeof data2 === "object" ? data2 : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has2(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign3({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has2(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator2 = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator2.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator2.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol2(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol2(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-vis-network-graph/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-vis-network-graph/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass2 = /* @__PURE__ */ function() {
      function defineProperties4(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties4(Constructor.prototype, protoProps);
        if (staticProps) defineProperties4(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _defaultsDeep = require_defaultsDeep2();
    var _defaultsDeep2 = _interopRequireDefault(_defaultsDeep);
    var _isEqual = require_isEqual();
    var _isEqual2 = _interopRequireDefault(_isEqual);
    var _differenceWith = require_differenceWith();
    var _differenceWith2 = _interopRequireDefault(_differenceWith);
    var _standalone = (init_standalone(), __toCommonJS(standalone_exports));
    var _uuid = require_uuid();
    var _uuid2 = _interopRequireDefault(_uuid);
    var _propTypes = require_prop_types();
    var _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn2(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Graph = function(_Component) {
      _inherits2(Graph2, _Component);
      function Graph2(props) {
        _classCallCheck2(this, Graph2);
        var _this = _possibleConstructorReturn2(this, (Graph2.__proto__ || Object.getPrototypeOf(Graph2)).call(this, props));
        var identifier = props.identifier;
        _this.updateGraph = _this.updateGraph.bind(_this);
        _this.state = {
          identifier: identifier !== void 0 ? identifier : _uuid2.default.v4()
        };
        _this.container = _react2.default.createRef();
        return _this;
      }
      _createClass2(Graph2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.edges = new _standalone.DataSet(this.props.graph.edges);
          this.nodes = new _standalone.DataSet(this.props.graph.nodes);
          this.updateGraph();
        }
      }, {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
          var nodesChange = !(0, _isEqual2.default)(this.props.graph.nodes, nextProps.graph.nodes);
          var edgesChange = !(0, _isEqual2.default)(this.props.graph.edges, nextProps.graph.edges);
          var optionsChange = !(0, _isEqual2.default)(this.props.options, nextProps.options);
          var eventsChange = !(0, _isEqual2.default)(this.props.events, nextProps.events);
          if (nodesChange) {
            var idIsEqual = function idIsEqual2(n1, n2) {
              return n1.id === n2.id;
            };
            var nodesRemoved = (0, _differenceWith2.default)(this.props.graph.nodes, nextProps.graph.nodes, idIsEqual);
            var nodesAdded = (0, _differenceWith2.default)(nextProps.graph.nodes, this.props.graph.nodes, idIsEqual);
            var nodesChanged = (0, _differenceWith2.default)((0, _differenceWith2.default)(nextProps.graph.nodes, this.props.graph.nodes, _isEqual2.default), nodesAdded);
            this.patchNodes({ nodesRemoved, nodesAdded, nodesChanged });
          }
          if (edgesChange) {
            var _idIsEqual = function _idIsEqual2(p1, p2) {
              return p1.id === p2.id;
            };
            var edgesRemoved = (0, _differenceWith2.default)(this.props.graph.edges, nextProps.graph.edges, _idIsEqual);
            var edgesAdded = (0, _differenceWith2.default)(nextProps.graph.edges, this.props.graph.edges, _idIsEqual);
            var edgesChanged = (0, _differenceWith2.default)((0, _differenceWith2.default)(nextProps.graph.edges, this.props.graph.edges, _isEqual2.default), edgesAdded);
            this.patchEdges({ edgesRemoved, edgesAdded, edgesChanged });
          }
          if (optionsChange) {
            this.Network.setOptions(nextProps.options);
          }
          if (eventsChange) {
            var events = this.props.events || {};
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = Object.keys(events)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var eventName = _step.value;
                this.Network.off(eventName, events[eventName]);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            events = nextProps.events || {};
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = Object.keys(events)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _eventName = _step2.value;
                this.Network.on(_eventName, events[_eventName]);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
          return false;
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.updateGraph();
        }
      }, {
        key: "patchEdges",
        value: function patchEdges(_ref) {
          var edgesRemoved = _ref.edgesRemoved, edgesAdded = _ref.edgesAdded, edgesChanged = _ref.edgesChanged;
          this.edges.remove(edgesRemoved);
          this.edges.add(edgesAdded);
          this.edges.update(edgesChanged);
        }
      }, {
        key: "patchNodes",
        value: function patchNodes(_ref2) {
          var nodesRemoved = _ref2.nodesRemoved, nodesAdded = _ref2.nodesAdded, nodesChanged = _ref2.nodesChanged;
          this.nodes.remove(nodesRemoved);
          this.nodes.add(nodesAdded);
          this.nodes.update(nodesChanged);
        }
      }, {
        key: "updateGraph",
        value: function updateGraph() {
          var defaultOptions = {
            physics: {
              stabilization: false
            },
            autoResize: false,
            edges: {
              smooth: false,
              color: "#000000",
              width: 0.5,
              arrows: {
                to: {
                  enabled: true,
                  scaleFactor: 0.5
                }
              }
            }
          };
          var options2 = (0, _defaultsDeep2.default)(defaultOptions, this.props.options);
          var data2 = {
            nodes: this.nodes,
            edges: this.edges
          };
          this.Network = new _standalone.Network(this.container.current, data2, options2);
          if (this.props.getNetwork) {
            this.props.getNetwork(this.Network);
          }
          if (this.props.getNodes) {
            this.props.getNodes(this.nodes);
          }
          if (this.props.getEdges) {
            this.props.getEdges(this.edges);
          }
          var events = this.props.events || {};
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = Object.keys(events)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var eventName = _step3.value;
              this.Network.on(eventName, events[eventName]);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }, {
        key: "render",
        value: function render() {
          var identifier = this.state.identifier;
          var style = this.props.style;
          return _react2.default.createElement("div", {
            id: identifier,
            ref: this.container,
            style
          }, identifier);
        }
      }]);
      return Graph2;
    }(_react.Component);
    Graph.defaultProps = {
      graph: {},
      style: { width: "100%", height: "100%" }
    };
    Graph.propTypes = {
      graph: _propTypes2.default.object,
      style: _propTypes2.default.object,
      getNetwork: _propTypes2.default.func,
      getNodes: _propTypes2.default.func,
      getEdges: _propTypes2.default.func
    };
    exports.default = Graph;
  }
});
export default require_lib();
/*! Bundled license information:

vis-network/standalone/esm/vis-network.js:
  (**
   * vis-network
   * https://visjs.github.io/vis-network/
   *
   * A dynamic, browser-based visualization library.
   *
   * @version 7.10.2
   * @date    2020-07-25T19:58:51.154Z
   *
   * @copyright (c) 2011-2017 Almende B.V, http://almende.com
   * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
   *
   * @license
   * vis.js is dual licensed under both
   *
   *   1. The Apache 2.0 License
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   *   and
   *
   *   2. The MIT License
   *      http://opensource.org/licenses/MIT
   *
   * vis.js may be distributed under either license.
   *)
  (**
   * vis-util
   * https://github.com/visjs/vis-util
   *
   * utilitie collection for visjs
   *
   * @version 4.3.3
   * @date    2020-07-18T16:20:10.745Z
   *
   * @copyright (c) 2011-2017 Almende B.V, http://almende.com
   * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
   *
   * @license
   * vis.js is dual licensed under both
   *
   *   1. The Apache 2.0 License
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   *   and
   *
   *   2. The MIT License
   *      http://opensource.org/licenses/MIT
   *
   * vis.js may be distributed under either license.
   *)
  (*! Hammer.JS - v2.0.17-rc - 2019-12-16
   * http://naver.github.io/egjs
   *
   * Forked By Naver egjs
   * Copyright (c) hammerjs
   * Licensed under the MIT license *)
  (*! moment.js *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=react-vis-network-graph.js.map
